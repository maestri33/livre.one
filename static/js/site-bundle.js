var SiteJS;(()=>{"use strict";var __webpack_modules__={5293:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n// EXTERNAL MODULE: ./node_modules/htmx.org/dist/htmx.esm.js\nvar htmx_esm = __webpack_require__(4037);\n;// ./assets/javascript/htmx.js\n\nwindow.htmx = htmx_esm/* default */.A;\n;// ./node_modules/alpinejs/dist/module.esm.js\n// packages/alpinejs/src/scheduler.js\nvar flushPending = false;\nvar flushing = false;\nvar queue = [];\nvar lastFlushedIndex = -1;\nfunction scheduler(callback) {\n  queueJob(callback);\n}\nfunction queueJob(job) {\n  if (!queue.includes(job))\n    queue.push(job);\n  queueFlush();\n}\nfunction dequeueJob(job) {\n  let index = queue.indexOf(job);\n  if (index !== -1 && index > lastFlushedIndex)\n    queue.splice(index, 1);\n}\nfunction queueFlush() {\n  if (!flushing && !flushPending) {\n    flushPending = true;\n    queueMicrotask(flushJobs);\n  }\n}\nfunction flushJobs() {\n  flushPending = false;\n  flushing = true;\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n    lastFlushedIndex = i;\n  }\n  queue.length = 0;\n  lastFlushedIndex = -1;\n  flushing = false;\n}\n\n// packages/alpinejs/src/reactivity.js\nvar reactive;\nvar effect;\nvar release;\nvar raw;\nvar shouldSchedule = true;\nfunction disableEffectScheduling(callback) {\n  shouldSchedule = false;\n  callback();\n  shouldSchedule = true;\n}\nfunction setReactivityEngine(engine) {\n  reactive = engine.reactive;\n  release = engine.release;\n  effect = (callback) => engine.effect(callback, { scheduler: (task) => {\n    if (shouldSchedule) {\n      scheduler(task);\n    } else {\n      task();\n    }\n  } });\n  raw = engine.raw;\n}\nfunction overrideEffect(override) {\n  effect = override;\n}\nfunction elementBoundEffect(el) {\n  let cleanup2 = () => {\n  };\n  let wrappedEffect = (callback) => {\n    let effectReference = effect(callback);\n    if (!el._x_effects) {\n      el._x_effects = /* @__PURE__ */ new Set();\n      el._x_runEffects = () => {\n        el._x_effects.forEach((i) => i());\n      };\n    }\n    el._x_effects.add(effectReference);\n    cleanup2 = () => {\n      if (effectReference === void 0)\n        return;\n      el._x_effects.delete(effectReference);\n      release(effectReference);\n    };\n    return effectReference;\n  };\n  return [wrappedEffect, () => {\n    cleanup2();\n  }];\n}\nfunction watch(getter, callback) {\n  let firstTime = true;\n  let oldValue;\n  let effectReference = effect(() => {\n    let value = getter();\n    JSON.stringify(value);\n    if (!firstTime) {\n      queueMicrotask(() => {\n        callback(value, oldValue);\n        oldValue = value;\n      });\n    } else {\n      oldValue = value;\n    }\n    firstTime = false;\n  });\n  return () => release(effectReference);\n}\n\n// packages/alpinejs/src/mutation.js\nvar onAttributeAddeds = [];\nvar onElRemoveds = [];\nvar onElAddeds = [];\nfunction onElAdded(callback) {\n  onElAddeds.push(callback);\n}\nfunction onElRemoved(el, callback) {\n  if (typeof callback === \"function\") {\n    if (!el._x_cleanups)\n      el._x_cleanups = [];\n    el._x_cleanups.push(callback);\n  } else {\n    callback = el;\n    onElRemoveds.push(callback);\n  }\n}\nfunction onAttributesAdded(callback) {\n  onAttributeAddeds.push(callback);\n}\nfunction onAttributeRemoved(el, name, callback) {\n  if (!el._x_attributeCleanups)\n    el._x_attributeCleanups = {};\n  if (!el._x_attributeCleanups[name])\n    el._x_attributeCleanups[name] = [];\n  el._x_attributeCleanups[name].push(callback);\n}\nfunction cleanupAttributes(el, names) {\n  if (!el._x_attributeCleanups)\n    return;\n  Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {\n    if (names === void 0 || names.includes(name)) {\n      value.forEach((i) => i());\n      delete el._x_attributeCleanups[name];\n    }\n  });\n}\nfunction cleanupElement(el) {\n  el._x_effects?.forEach(dequeueJob);\n  while (el._x_cleanups?.length)\n    el._x_cleanups.pop()();\n}\nvar observer = new MutationObserver(onMutate);\nvar currentlyObserving = false;\nfunction startObservingMutations() {\n  observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });\n  currentlyObserving = true;\n}\nfunction stopObservingMutations() {\n  flushObserver();\n  observer.disconnect();\n  currentlyObserving = false;\n}\nvar queuedMutations = [];\nfunction flushObserver() {\n  let records = observer.takeRecords();\n  queuedMutations.push(() => records.length > 0 && onMutate(records));\n  let queueLengthWhenTriggered = queuedMutations.length;\n  queueMicrotask(() => {\n    if (queuedMutations.length === queueLengthWhenTriggered) {\n      while (queuedMutations.length > 0)\n        queuedMutations.shift()();\n    }\n  });\n}\nfunction mutateDom(callback) {\n  if (!currentlyObserving)\n    return callback();\n  stopObservingMutations();\n  let result = callback();\n  startObservingMutations();\n  return result;\n}\nvar isCollecting = false;\nvar deferredMutations = [];\nfunction deferMutations() {\n  isCollecting = true;\n}\nfunction flushAndStopDeferringMutations() {\n  isCollecting = false;\n  onMutate(deferredMutations);\n  deferredMutations = [];\n}\nfunction onMutate(mutations) {\n  if (isCollecting) {\n    deferredMutations = deferredMutations.concat(mutations);\n    return;\n  }\n  let addedNodes = /* @__PURE__ */ new Set();\n  let removedNodes = /* @__PURE__ */ new Set();\n  let addedAttributes = /* @__PURE__ */ new Map();\n  let removedAttributes = /* @__PURE__ */ new Map();\n  for (let i = 0; i < mutations.length; i++) {\n    if (mutations[i].target._x_ignoreMutationObserver)\n      continue;\n    if (mutations[i].type === \"childList\") {\n      mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.add(node));\n      mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.add(node));\n    }\n    if (mutations[i].type === \"attributes\") {\n      let el = mutations[i].target;\n      let name = mutations[i].attributeName;\n      let oldValue = mutations[i].oldValue;\n      let add2 = () => {\n        if (!addedAttributes.has(el))\n          addedAttributes.set(el, []);\n        addedAttributes.get(el).push({ name, value: el.getAttribute(name) });\n      };\n      let remove = () => {\n        if (!removedAttributes.has(el))\n          removedAttributes.set(el, []);\n        removedAttributes.get(el).push(name);\n      };\n      if (el.hasAttribute(name) && oldValue === null) {\n        add2();\n      } else if (el.hasAttribute(name)) {\n        remove();\n        add2();\n      } else {\n        remove();\n      }\n    }\n  }\n  removedAttributes.forEach((attrs, el) => {\n    cleanupAttributes(el, attrs);\n  });\n  addedAttributes.forEach((attrs, el) => {\n    onAttributeAddeds.forEach((i) => i(el, attrs));\n  });\n  for (let node of removedNodes) {\n    if (addedNodes.has(node))\n      continue;\n    onElRemoveds.forEach((i) => i(node));\n  }\n  addedNodes.forEach((node) => {\n    node._x_ignoreSelf = true;\n    node._x_ignore = true;\n  });\n  for (let node of addedNodes) {\n    if (removedNodes.has(node))\n      continue;\n    if (!node.isConnected)\n      continue;\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n    onElAddeds.forEach((i) => i(node));\n    node._x_ignore = true;\n    node._x_ignoreSelf = true;\n  }\n  addedNodes.forEach((node) => {\n    delete node._x_ignoreSelf;\n    delete node._x_ignore;\n  });\n  addedNodes = null;\n  removedNodes = null;\n  addedAttributes = null;\n  removedAttributes = null;\n}\n\n// packages/alpinejs/src/scope.js\nfunction scope(node) {\n  return mergeProxies(closestDataStack(node));\n}\nfunction addScopeToNode(node, data2, referenceNode) {\n  node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];\n  return () => {\n    node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);\n  };\n}\nfunction closestDataStack(node) {\n  if (node._x_dataStack)\n    return node._x_dataStack;\n  if (typeof ShadowRoot === \"function\" && node instanceof ShadowRoot) {\n    return closestDataStack(node.host);\n  }\n  if (!node.parentNode) {\n    return [];\n  }\n  return closestDataStack(node.parentNode);\n}\nfunction mergeProxies(objects) {\n  return new Proxy({ objects }, mergeProxyTrap);\n}\nvar mergeProxyTrap = {\n  ownKeys({ objects }) {\n    return Array.from(\n      new Set(objects.flatMap((i) => Object.keys(i)))\n    );\n  },\n  has({ objects }, name) {\n    if (name == Symbol.unscopables)\n      return false;\n    return objects.some(\n      (obj) => Object.prototype.hasOwnProperty.call(obj, name) || Reflect.has(obj, name)\n    );\n  },\n  get({ objects }, name, thisProxy) {\n    if (name == \"toJSON\")\n      return collapseProxies;\n    return Reflect.get(\n      objects.find(\n        (obj) => Reflect.has(obj, name)\n      ) || {},\n      name,\n      thisProxy\n    );\n  },\n  set({ objects }, name, value, thisProxy) {\n    const target = objects.find(\n      (obj) => Object.prototype.hasOwnProperty.call(obj, name)\n    ) || objects[objects.length - 1];\n    const descriptor = Object.getOwnPropertyDescriptor(target, name);\n    if (descriptor?.set && descriptor?.get)\n      return descriptor.set.call(thisProxy, value) || true;\n    return Reflect.set(target, name, value);\n  }\n};\nfunction collapseProxies() {\n  let keys = Reflect.ownKeys(this);\n  return keys.reduce((acc, key) => {\n    acc[key] = Reflect.get(this, key);\n    return acc;\n  }, {});\n}\n\n// packages/alpinejs/src/interceptor.js\nfunction initInterceptors(data2) {\n  let isObject2 = (val) => typeof val === \"object\" && !Array.isArray(val) && val !== null;\n  let recurse = (obj, basePath = \"\") => {\n    Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {\n      if (enumerable === false || value === void 0)\n        return;\n      if (typeof value === \"object\" && value !== null && value.__v_skip)\n        return;\n      let path = basePath === \"\" ? key : `${basePath}.${key}`;\n      if (typeof value === \"object\" && value !== null && value._x_interceptor) {\n        obj[key] = value.initialize(data2, path, key);\n      } else {\n        if (isObject2(value) && value !== obj && !(value instanceof Element)) {\n          recurse(value, path);\n        }\n      }\n    });\n  };\n  return recurse(data2);\n}\nfunction interceptor(callback, mutateObj = () => {\n}) {\n  let obj = {\n    initialValue: void 0,\n    _x_interceptor: true,\n    initialize(data2, path, key) {\n      return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);\n    }\n  };\n  mutateObj(obj);\n  return (initialValue) => {\n    if (typeof initialValue === \"object\" && initialValue !== null && initialValue._x_interceptor) {\n      let initialize = obj.initialize.bind(obj);\n      obj.initialize = (data2, path, key) => {\n        let innerValue = initialValue.initialize(data2, path, key);\n        obj.initialValue = innerValue;\n        return initialize(data2, path, key);\n      };\n    } else {\n      obj.initialValue = initialValue;\n    }\n    return obj;\n  };\n}\nfunction get(obj, path) {\n  return path.split(\".\").reduce((carry, segment) => carry[segment], obj);\n}\nfunction set(obj, path, value) {\n  if (typeof path === \"string\")\n    path = path.split(\".\");\n  if (path.length === 1)\n    obj[path[0]] = value;\n  else if (path.length === 0)\n    throw error;\n  else {\n    if (obj[path[0]])\n      return set(obj[path[0]], path.slice(1), value);\n    else {\n      obj[path[0]] = {};\n      return set(obj[path[0]], path.slice(1), value);\n    }\n  }\n}\n\n// packages/alpinejs/src/magics.js\nvar magics = {};\nfunction magic(name, callback) {\n  magics[name] = callback;\n}\nfunction injectMagics(obj, el) {\n  let memoizedUtilities = getUtilities(el);\n  Object.entries(magics).forEach(([name, callback]) => {\n    Object.defineProperty(obj, `$${name}`, {\n      get() {\n        return callback(el, memoizedUtilities);\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\nfunction getUtilities(el) {\n  let [utilities, cleanup2] = getElementBoundUtilities(el);\n  let utils = { interceptor, ...utilities };\n  onElRemoved(el, cleanup2);\n  return utils;\n}\n\n// packages/alpinejs/src/utils/error.js\nfunction tryCatch(el, expression, callback, ...args) {\n  try {\n    return callback(...args);\n  } catch (e) {\n    handleError(e, el, expression);\n  }\n}\nfunction handleError(error2, el, expression = void 0) {\n  error2 = Object.assign(\n    error2 ?? { message: \"No error message given.\" },\n    { el, expression }\n  );\n  console.warn(`Alpine Expression Error: ${error2.message}\n\n${expression ? 'Expression: \"' + expression + '\"\\n\\n' : \"\"}`, el);\n  setTimeout(() => {\n    throw error2;\n  }, 0);\n}\n\n// packages/alpinejs/src/evaluator.js\nvar shouldAutoEvaluateFunctions = true;\nfunction dontAutoEvaluateFunctions(callback) {\n  let cache = shouldAutoEvaluateFunctions;\n  shouldAutoEvaluateFunctions = false;\n  let result = callback();\n  shouldAutoEvaluateFunctions = cache;\n  return result;\n}\nfunction evaluate(el, expression, extras = {}) {\n  let result;\n  evaluateLater(el, expression)((value) => result = value, extras);\n  return result;\n}\nfunction evaluateLater(...args) {\n  return theEvaluatorFunction(...args);\n}\nvar theEvaluatorFunction = normalEvaluator;\nfunction setEvaluator(newEvaluator) {\n  theEvaluatorFunction = newEvaluator;\n}\nfunction normalEvaluator(el, expression) {\n  let overriddenMagics = {};\n  injectMagics(overriddenMagics, el);\n  let dataStack = [overriddenMagics, ...closestDataStack(el)];\n  let evaluator = typeof expression === \"function\" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);\n  return tryCatch.bind(null, el, expression, evaluator);\n}\nfunction generateEvaluatorFromFunction(dataStack, func) {\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    let result = func.apply(mergeProxies([scope2, ...dataStack]), params);\n    runIfTypeOfFunction(receiver, result);\n  };\n}\nvar evaluatorMemo = {};\nfunction generateFunctionFromString(expression, el) {\n  if (evaluatorMemo[expression]) {\n    return evaluatorMemo[expression];\n  }\n  let AsyncFunction = Object.getPrototypeOf(async function() {\n  }).constructor;\n  let rightSideSafeExpression = /^[\\n\\s]*if.*\\(.*\\)/.test(expression.trim()) || /^(let|const)\\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;\n  const safeAsyncFunction = () => {\n    try {\n      let func2 = new AsyncFunction(\n        [\"__self\", \"scope\"],\n        `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`\n      );\n      Object.defineProperty(func2, \"name\", {\n        value: `[Alpine] ${expression}`\n      });\n      return func2;\n    } catch (error2) {\n      handleError(error2, el, expression);\n      return Promise.resolve();\n    }\n  };\n  let func = safeAsyncFunction();\n  evaluatorMemo[expression] = func;\n  return func;\n}\nfunction generateEvaluatorFromString(dataStack, expression, el) {\n  let func = generateFunctionFromString(expression, el);\n  return (receiver = () => {\n  }, { scope: scope2 = {}, params = [] } = {}) => {\n    func.result = void 0;\n    func.finished = false;\n    let completeScope = mergeProxies([scope2, ...dataStack]);\n    if (typeof func === \"function\") {\n      let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));\n      if (func.finished) {\n        runIfTypeOfFunction(receiver, func.result, completeScope, params, el);\n        func.result = void 0;\n      } else {\n        promise.then((result) => {\n          runIfTypeOfFunction(receiver, result, completeScope, params, el);\n        }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);\n      }\n    }\n  };\n}\nfunction runIfTypeOfFunction(receiver, value, scope2, params, el) {\n  if (shouldAutoEvaluateFunctions && typeof value === \"function\") {\n    let result = value.apply(scope2, params);\n    if (result instanceof Promise) {\n      result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));\n    } else {\n      receiver(result);\n    }\n  } else if (typeof value === \"object\" && value instanceof Promise) {\n    value.then((i) => receiver(i));\n  } else {\n    receiver(value);\n  }\n}\n\n// packages/alpinejs/src/directives.js\nvar prefixAsString = \"x-\";\nfunction prefix(subject = \"\") {\n  return prefixAsString + subject;\n}\nfunction setPrefix(newPrefix) {\n  prefixAsString = newPrefix;\n}\nvar directiveHandlers = {};\nfunction directive(name, callback) {\n  directiveHandlers[name] = callback;\n  return {\n    before(directive2) {\n      if (!directiveHandlers[directive2]) {\n        console.warn(String.raw`Cannot find directive \\`${directive2}\\`. \\`${name}\\` will use the default order of execution`);\n        return;\n      }\n      const pos = directiveOrder.indexOf(directive2);\n      directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf(\"DEFAULT\"), 0, name);\n    }\n  };\n}\nfunction directiveExists(name) {\n  return Object.keys(directiveHandlers).includes(name);\n}\nfunction directives(el, attributes, originalAttributeOverride) {\n  attributes = Array.from(attributes);\n  if (el._x_virtualDirectives) {\n    let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));\n    let staticAttributes = attributesOnly(vAttributes);\n    vAttributes = vAttributes.map((attribute) => {\n      if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n        return {\n          name: `x-bind:${attribute.name}`,\n          value: `\"${attribute.value}\"`\n        };\n      }\n      return attribute;\n    });\n    attributes = attributes.concat(vAttributes);\n  }\n  let transformedAttributeMap = {};\n  let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);\n  return directives2.map((directive2) => {\n    return getDirectiveHandler(el, directive2);\n  });\n}\nfunction attributesOnly(attributes) {\n  return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));\n}\nvar isDeferringHandlers = false;\nvar directiveHandlerStacks = /* @__PURE__ */ new Map();\nvar currentHandlerStackKey = Symbol();\nfunction deferHandlingDirectives(callback) {\n  isDeferringHandlers = true;\n  let key = Symbol();\n  currentHandlerStackKey = key;\n  directiveHandlerStacks.set(key, []);\n  let flushHandlers = () => {\n    while (directiveHandlerStacks.get(key).length)\n      directiveHandlerStacks.get(key).shift()();\n    directiveHandlerStacks.delete(key);\n  };\n  let stopDeferring = () => {\n    isDeferringHandlers = false;\n    flushHandlers();\n  };\n  callback(flushHandlers);\n  stopDeferring();\n}\nfunction getElementBoundUtilities(el) {\n  let cleanups = [];\n  let cleanup2 = (callback) => cleanups.push(callback);\n  let [effect3, cleanupEffect] = elementBoundEffect(el);\n  cleanups.push(cleanupEffect);\n  let utilities = {\n    Alpine: alpine_default,\n    effect: effect3,\n    cleanup: cleanup2,\n    evaluateLater: evaluateLater.bind(evaluateLater, el),\n    evaluate: evaluate.bind(evaluate, el)\n  };\n  let doCleanup = () => cleanups.forEach((i) => i());\n  return [utilities, doCleanup];\n}\nfunction getDirectiveHandler(el, directive2) {\n  let noop = () => {\n  };\n  let handler4 = directiveHandlers[directive2.type] || noop;\n  let [utilities, cleanup2] = getElementBoundUtilities(el);\n  onAttributeRemoved(el, directive2.original, cleanup2);\n  let fullHandler = () => {\n    if (el._x_ignore || el._x_ignoreSelf)\n      return;\n    handler4.inline && handler4.inline(el, directive2, utilities);\n    handler4 = handler4.bind(handler4, el, directive2, utilities);\n    isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();\n  };\n  fullHandler.runCleanups = cleanup2;\n  return fullHandler;\n}\nvar startingWith = (subject, replacement) => ({ name, value }) => {\n  if (name.startsWith(subject))\n    name = name.replace(subject, replacement);\n  return { name, value };\n};\nvar into = (i) => i;\nfunction toTransformedAttributes(callback = () => {\n}) {\n  return ({ name, value }) => {\n    let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {\n      return transform(carry);\n    }, { name, value });\n    if (newName !== name)\n      callback(newName, name);\n    return { name: newName, value: newValue };\n  };\n}\nvar attributeTransformers = [];\nfunction mapAttributes(callback) {\n  attributeTransformers.push(callback);\n}\nfunction outNonAlpineAttributes({ name }) {\n  return alpineAttributeRegex().test(name);\n}\nvar alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\\\b`);\nfunction toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {\n  return ({ name, value }) => {\n    let typeMatch = name.match(alpineAttributeRegex());\n    let valueMatch = name.match(/:([a-zA-Z0-9\\-_:]+)/);\n    let modifiers = name.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    let original = originalAttributeOverride || transformedAttributeMap[name] || name;\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map((i) => i.replace(\".\", \"\")),\n      expression: value,\n      original\n    };\n  };\n}\nvar DEFAULT = \"DEFAULT\";\nvar directiveOrder = [\n  \"ignore\",\n  \"ref\",\n  \"data\",\n  \"id\",\n  \"anchor\",\n  \"bind\",\n  \"init\",\n  \"for\",\n  \"model\",\n  \"modelable\",\n  \"transition\",\n  \"show\",\n  \"if\",\n  DEFAULT,\n  \"teleport\"\n];\nfunction byPriority(a, b) {\n  let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;\n  let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;\n  return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n}\n\n// packages/alpinejs/src/utils/dispatch.js\nfunction dispatch(el, name, detail = {}) {\n  el.dispatchEvent(\n    new CustomEvent(name, {\n      detail,\n      bubbles: true,\n      // Allows events to pass the shadow DOM barrier.\n      composed: true,\n      cancelable: true\n    })\n  );\n}\n\n// packages/alpinejs/src/utils/walk.js\nfunction walk(el, callback) {\n  if (typeof ShadowRoot === \"function\" && el instanceof ShadowRoot) {\n    Array.from(el.children).forEach((el2) => walk(el2, callback));\n    return;\n  }\n  let skip = false;\n  callback(el, () => skip = true);\n  if (skip)\n    return;\n  let node = el.firstElementChild;\n  while (node) {\n    walk(node, callback, false);\n    node = node.nextElementSibling;\n  }\n}\n\n// packages/alpinejs/src/utils/warn.js\nfunction warn(message, ...args) {\n  console.warn(`Alpine Warning: ${message}`, ...args);\n}\n\n// packages/alpinejs/src/lifecycle.js\nvar started = false;\nfunction start() {\n  if (started)\n    warn(\"Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.\");\n  started = true;\n  if (!document.body)\n    warn(\"Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?\");\n  dispatch(document, \"alpine:init\");\n  dispatch(document, \"alpine:initializing\");\n  startObservingMutations();\n  onElAdded((el) => initTree(el, walk));\n  onElRemoved((el) => destroyTree(el));\n  onAttributesAdded((el, attrs) => {\n    directives(el, attrs).forEach((handle) => handle());\n  });\n  let outNestedComponents = (el) => !closestRoot(el.parentElement, true);\n  Array.from(document.querySelectorAll(allSelectors().join(\",\"))).filter(outNestedComponents).forEach((el) => {\n    initTree(el);\n  });\n  dispatch(document, \"alpine:initialized\");\n  setTimeout(() => {\n    warnAboutMissingPlugins();\n  });\n}\nvar rootSelectorCallbacks = [];\nvar initSelectorCallbacks = [];\nfunction rootSelectors() {\n  return rootSelectorCallbacks.map((fn) => fn());\n}\nfunction allSelectors() {\n  return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());\n}\nfunction addRootSelector(selectorCallback) {\n  rootSelectorCallbacks.push(selectorCallback);\n}\nfunction addInitSelector(selectorCallback) {\n  initSelectorCallbacks.push(selectorCallback);\n}\nfunction closestRoot(el, includeInitSelectors = false) {\n  return findClosest(el, (element) => {\n    const selectors = includeInitSelectors ? allSelectors() : rootSelectors();\n    if (selectors.some((selector) => element.matches(selector)))\n      return true;\n  });\n}\nfunction findClosest(el, callback) {\n  if (!el)\n    return;\n  if (callback(el))\n    return el;\n  if (el._x_teleportBack)\n    el = el._x_teleportBack;\n  if (!el.parentElement)\n    return;\n  return findClosest(el.parentElement, callback);\n}\nfunction isRoot(el) {\n  return rootSelectors().some((selector) => el.matches(selector));\n}\nvar initInterceptors2 = [];\nfunction interceptInit(callback) {\n  initInterceptors2.push(callback);\n}\nfunction initTree(el, walker = walk, intercept = () => {\n}) {\n  deferHandlingDirectives(() => {\n    walker(el, (el2, skip) => {\n      intercept(el2, skip);\n      initInterceptors2.forEach((i) => i(el2, skip));\n      directives(el2, el2.attributes).forEach((handle) => handle());\n      el2._x_ignore && skip();\n    });\n  });\n}\nfunction destroyTree(root, walker = walk) {\n  walker(root, (el) => {\n    cleanupElement(el);\n    cleanupAttributes(el);\n  });\n}\nfunction warnAboutMissingPlugins() {\n  let pluginDirectives = [\n    [\"ui\", \"dialog\", [\"[x-dialog], [x-popover]\"]],\n    [\"anchor\", \"anchor\", [\"[x-anchor]\"]],\n    [\"sort\", \"sort\", [\"[x-sort]\"]]\n  ];\n  pluginDirectives.forEach(([plugin2, directive2, selectors]) => {\n    if (directiveExists(directive2))\n      return;\n    selectors.some((selector) => {\n      if (document.querySelector(selector)) {\n        warn(`found \"${selector}\", but missing ${plugin2} plugin`);\n        return true;\n      }\n    });\n  });\n}\n\n// packages/alpinejs/src/nextTick.js\nvar tickStack = [];\nvar isHolding = false;\nfunction nextTick(callback = () => {\n}) {\n  queueMicrotask(() => {\n    isHolding || setTimeout(() => {\n      releaseNextTicks();\n    });\n  });\n  return new Promise((res) => {\n    tickStack.push(() => {\n      callback();\n      res();\n    });\n  });\n}\nfunction releaseNextTicks() {\n  isHolding = false;\n  while (tickStack.length)\n    tickStack.shift()();\n}\nfunction holdNextTicks() {\n  isHolding = true;\n}\n\n// packages/alpinejs/src/utils/classes.js\nfunction setClasses(el, value) {\n  if (Array.isArray(value)) {\n    return setClassesFromString(el, value.join(\" \"));\n  } else if (typeof value === \"object\" && value !== null) {\n    return setClassesFromObject(el, value);\n  } else if (typeof value === \"function\") {\n    return setClasses(el, value());\n  }\n  return setClassesFromString(el, value);\n}\nfunction setClassesFromString(el, classString) {\n  let split = (classString2) => classString2.split(\" \").filter(Boolean);\n  let missingClasses = (classString2) => classString2.split(\" \").filter((i) => !el.classList.contains(i)).filter(Boolean);\n  let addClassesAndReturnUndo = (classes) => {\n    el.classList.add(...classes);\n    return () => {\n      el.classList.remove(...classes);\n    };\n  };\n  classString = classString === true ? classString = \"\" : classString || \"\";\n  return addClassesAndReturnUndo(missingClasses(classString));\n}\nfunction setClassesFromObject(el, classObject) {\n  let split = (classString) => classString.split(\" \").filter(Boolean);\n  let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);\n  let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);\n  let added = [];\n  let removed = [];\n  forRemove.forEach((i) => {\n    if (el.classList.contains(i)) {\n      el.classList.remove(i);\n      removed.push(i);\n    }\n  });\n  forAdd.forEach((i) => {\n    if (!el.classList.contains(i)) {\n      el.classList.add(i);\n      added.push(i);\n    }\n  });\n  return () => {\n    removed.forEach((i) => el.classList.add(i));\n    added.forEach((i) => el.classList.remove(i));\n  };\n}\n\n// packages/alpinejs/src/utils/styles.js\nfunction setStyles(el, value) {\n  if (typeof value === \"object\" && value !== null) {\n    return setStylesFromObject(el, value);\n  }\n  return setStylesFromString(el, value);\n}\nfunction setStylesFromObject(el, value) {\n  let previousStyles = {};\n  Object.entries(value).forEach(([key, value2]) => {\n    previousStyles[key] = el.style[key];\n    if (!key.startsWith(\"--\")) {\n      key = kebabCase(key);\n    }\n    el.style.setProperty(key, value2);\n  });\n  setTimeout(() => {\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  });\n  return () => {\n    setStyles(el, previousStyles);\n  };\n}\nfunction setStylesFromString(el, value) {\n  let cache = el.getAttribute(\"style\", value);\n  el.setAttribute(\"style\", value);\n  return () => {\n    el.setAttribute(\"style\", cache || \"\");\n  };\n}\nfunction kebabCase(subject) {\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\n\n// packages/alpinejs/src/utils/once.js\nfunction once(callback, fallback = () => {\n}) {\n  let called = false;\n  return function() {\n    if (!called) {\n      called = true;\n      callback.apply(this, arguments);\n    } else {\n      fallback.apply(this, arguments);\n    }\n  };\n}\n\n// packages/alpinejs/src/directives/x-transition.js\ndirective(\"transition\", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"function\")\n    expression = evaluate2(expression);\n  if (expression === false)\n    return;\n  if (!expression || typeof expression === \"boolean\") {\n    registerTransitionsFromHelper(el, modifiers, value);\n  } else {\n    registerTransitionsFromClassString(el, expression, value);\n  }\n});\nfunction registerTransitionsFromClassString(el, classString, stage) {\n  registerTransitionObject(el, setClasses, \"\");\n  let directiveStorageMap = {\n    \"enter\": (classes) => {\n      el._x_transition.enter.during = classes;\n    },\n    \"enter-start\": (classes) => {\n      el._x_transition.enter.start = classes;\n    },\n    \"enter-end\": (classes) => {\n      el._x_transition.enter.end = classes;\n    },\n    \"leave\": (classes) => {\n      el._x_transition.leave.during = classes;\n    },\n    \"leave-start\": (classes) => {\n      el._x_transition.leave.start = classes;\n    },\n    \"leave-end\": (classes) => {\n      el._x_transition.leave.end = classes;\n    }\n  };\n  directiveStorageMap[stage](classString);\n}\nfunction registerTransitionsFromHelper(el, modifiers, stage) {\n  registerTransitionObject(el, setStyles);\n  let doesntSpecify = !modifiers.includes(\"in\") && !modifiers.includes(\"out\") && !stage;\n  let transitioningIn = doesntSpecify || modifiers.includes(\"in\") || [\"enter\"].includes(stage);\n  let transitioningOut = doesntSpecify || modifiers.includes(\"out\") || [\"leave\"].includes(stage);\n  if (modifiers.includes(\"in\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index < modifiers.indexOf(\"out\"));\n  }\n  if (modifiers.includes(\"out\") && !doesntSpecify) {\n    modifiers = modifiers.filter((i, index) => index > modifiers.indexOf(\"out\"));\n  }\n  let wantsAll = !modifiers.includes(\"opacity\") && !modifiers.includes(\"scale\");\n  let wantsOpacity = wantsAll || modifiers.includes(\"opacity\");\n  let wantsScale = wantsAll || modifiers.includes(\"scale\");\n  let opacityValue = wantsOpacity ? 0 : 1;\n  let scaleValue = wantsScale ? modifierValue(modifiers, \"scale\", 95) / 100 : 1;\n  let delay = modifierValue(modifiers, \"delay\", 0) / 1e3;\n  let origin = modifierValue(modifiers, \"origin\", \"center\");\n  let property = \"opacity, transform\";\n  let durationIn = modifierValue(modifiers, \"duration\", 150) / 1e3;\n  let durationOut = modifierValue(modifiers, \"duration\", 75) / 1e3;\n  let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n  if (transitioningIn) {\n    el._x_transition.enter.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationIn}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.enter.start = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n    el._x_transition.enter.end = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n  }\n  if (transitioningOut) {\n    el._x_transition.leave.during = {\n      transformOrigin: origin,\n      transitionDelay: `${delay}s`,\n      transitionProperty: property,\n      transitionDuration: `${durationOut}s`,\n      transitionTimingFunction: easing\n    };\n    el._x_transition.leave.start = {\n      opacity: 1,\n      transform: `scale(1)`\n    };\n    el._x_transition.leave.end = {\n      opacity: opacityValue,\n      transform: `scale(${scaleValue})`\n    };\n  }\n}\nfunction registerTransitionObject(el, setFunction, defaultValue = {}) {\n  if (!el._x_transition)\n    el._x_transition = {\n      enter: { during: defaultValue, start: defaultValue, end: defaultValue },\n      leave: { during: defaultValue, start: defaultValue, end: defaultValue },\n      in(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.enter.during,\n          start: this.enter.start,\n          end: this.enter.end\n        }, before, after);\n      },\n      out(before = () => {\n      }, after = () => {\n      }) {\n        transition(el, setFunction, {\n          during: this.leave.during,\n          start: this.leave.start,\n          end: this.leave.end\n        }, before, after);\n      }\n    };\n}\nwindow.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {\n  const nextTick2 = document.visibilityState === \"visible\" ? requestAnimationFrame : setTimeout;\n  let clickAwayCompatibleShow = () => nextTick2(show);\n  if (value) {\n    if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {\n      el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    } else {\n      el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();\n    }\n    return;\n  }\n  el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {\n    el._x_transition.out(() => {\n    }, () => resolve(hide));\n    el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));\n  }) : Promise.resolve(hide);\n  queueMicrotask(() => {\n    let closest = closestHide(el);\n    if (closest) {\n      if (!closest._x_hideChildren)\n        closest._x_hideChildren = [];\n      closest._x_hideChildren.push(el);\n    } else {\n      nextTick2(() => {\n        let hideAfterChildren = (el2) => {\n          let carry = Promise.all([\n            el2._x_hidePromise,\n            ...(el2._x_hideChildren || []).map(hideAfterChildren)\n          ]).then(([i]) => i?.());\n          delete el2._x_hidePromise;\n          delete el2._x_hideChildren;\n          return carry;\n        };\n        hideAfterChildren(el).catch((e) => {\n          if (!e.isFromCancelledTransition)\n            throw e;\n        });\n      });\n    }\n  });\n};\nfunction closestHide(el) {\n  let parent = el.parentNode;\n  if (!parent)\n    return;\n  return parent._x_hidePromise ? parent : closestHide(parent);\n}\nfunction transition(el, setFunction, { during, start: start2, end } = {}, before = () => {\n}, after = () => {\n}) {\n  if (el._x_transitioning)\n    el._x_transitioning.cancel();\n  if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {\n    before();\n    after();\n    return;\n  }\n  let undoStart, undoDuring, undoEnd;\n  performTransition(el, {\n    start() {\n      undoStart = setFunction(el, start2);\n    },\n    during() {\n      undoDuring = setFunction(el, during);\n    },\n    before,\n    end() {\n      undoStart();\n      undoEnd = setFunction(el, end);\n    },\n    after,\n    cleanup() {\n      undoDuring();\n      undoEnd();\n    }\n  });\n}\nfunction performTransition(el, stages) {\n  let interrupted, reachedBefore, reachedEnd;\n  let finish = once(() => {\n    mutateDom(() => {\n      interrupted = true;\n      if (!reachedBefore)\n        stages.before();\n      if (!reachedEnd) {\n        stages.end();\n        releaseNextTicks();\n      }\n      stages.after();\n      if (el.isConnected)\n        stages.cleanup();\n      delete el._x_transitioning;\n    });\n  });\n  el._x_transitioning = {\n    beforeCancels: [],\n    beforeCancel(callback) {\n      this.beforeCancels.push(callback);\n    },\n    cancel: once(function() {\n      while (this.beforeCancels.length) {\n        this.beforeCancels.shift()();\n      }\n      ;\n      finish();\n    }),\n    finish\n  };\n  mutateDom(() => {\n    stages.start();\n    stages.during();\n  });\n  holdNextTicks();\n  requestAnimationFrame(() => {\n    if (interrupted)\n      return;\n    let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, \"\").replace(\"s\", \"\")) * 1e3;\n    if (duration === 0)\n      duration = Number(getComputedStyle(el).animationDuration.replace(\"s\", \"\")) * 1e3;\n    mutateDom(() => {\n      stages.before();\n    });\n    reachedBefore = true;\n    requestAnimationFrame(() => {\n      if (interrupted)\n        return;\n      mutateDom(() => {\n        stages.end();\n      });\n      releaseNextTicks();\n      setTimeout(el._x_transitioning.finish, duration + delay);\n      reachedEnd = true;\n    });\n  });\n}\nfunction modifierValue(modifiers, key, fallback) {\n  if (modifiers.indexOf(key) === -1)\n    return fallback;\n  const rawValue = modifiers[modifiers.indexOf(key) + 1];\n  if (!rawValue)\n    return fallback;\n  if (key === \"scale\") {\n    if (isNaN(rawValue))\n      return fallback;\n  }\n  if (key === \"duration\" || key === \"delay\") {\n    let match = rawValue.match(/([0-9]+)ms/);\n    if (match)\n      return match[1];\n  }\n  if (key === \"origin\") {\n    if ([\"top\", \"right\", \"left\", \"center\", \"bottom\"].includes(modifiers[modifiers.indexOf(key) + 2])) {\n      return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(\" \");\n    }\n  }\n  return rawValue;\n}\n\n// packages/alpinejs/src/clone.js\nvar isCloning = false;\nfunction skipDuringClone(callback, fallback = () => {\n}) {\n  return (...args) => isCloning ? fallback(...args) : callback(...args);\n}\nfunction onlyDuringClone(callback) {\n  return (...args) => isCloning && callback(...args);\n}\nvar interceptors = [];\nfunction interceptClone(callback) {\n  interceptors.push(callback);\n}\nfunction cloneNode(from, to) {\n  interceptors.forEach((i) => i(from, to));\n  isCloning = true;\n  dontRegisterReactiveSideEffects(() => {\n    initTree(to, (el, callback) => {\n      callback(el, () => {\n      });\n    });\n  });\n  isCloning = false;\n}\nvar isCloningLegacy = false;\nfunction clone(oldEl, newEl) {\n  if (!newEl._x_dataStack)\n    newEl._x_dataStack = oldEl._x_dataStack;\n  isCloning = true;\n  isCloningLegacy = true;\n  dontRegisterReactiveSideEffects(() => {\n    cloneTree(newEl);\n  });\n  isCloning = false;\n  isCloningLegacy = false;\n}\nfunction cloneTree(el) {\n  let hasRunThroughFirstEl = false;\n  let shallowWalker = (el2, callback) => {\n    walk(el2, (el3, skip) => {\n      if (hasRunThroughFirstEl && isRoot(el3))\n        return skip();\n      hasRunThroughFirstEl = true;\n      callback(el3, skip);\n    });\n  };\n  initTree(el, shallowWalker);\n}\nfunction dontRegisterReactiveSideEffects(callback) {\n  let cache = effect;\n  overrideEffect((callback2, el) => {\n    let storedEffect = cache(callback2);\n    release(storedEffect);\n    return () => {\n    };\n  });\n  callback();\n  overrideEffect(cache);\n}\n\n// packages/alpinejs/src/utils/bind.js\nfunction bind(el, name, value, modifiers = []) {\n  if (!el._x_bindings)\n    el._x_bindings = reactive({});\n  el._x_bindings[name] = value;\n  name = modifiers.includes(\"camel\") ? camelCase(name) : name;\n  switch (name) {\n    case \"value\":\n      bindInputValue(el, value);\n      break;\n    case \"style\":\n      bindStyles(el, value);\n      break;\n    case \"class\":\n      bindClasses(el, value);\n      break;\n    case \"selected\":\n    case \"checked\":\n      bindAttributeAndProperty(el, name, value);\n      break;\n    default:\n      bindAttribute(el, name, value);\n      break;\n  }\n}\nfunction bindInputValue(el, value) {\n  if (isRadio(el)) {\n    if (el.attributes.value === void 0) {\n      el.value = value;\n    }\n    if (window.fromModel) {\n      if (typeof value === \"boolean\") {\n        el.checked = safeParseBoolean(el.value) === value;\n      } else {\n        el.checked = checkedAttrLooseCompare(el.value, value);\n      }\n    }\n  } else if (isCheckbox(el)) {\n    if (Number.isInteger(value)) {\n      el.value = value;\n    } else if (!Array.isArray(value) && typeof value !== \"boolean\" && ![null, void 0].includes(value)) {\n      el.value = String(value);\n    } else {\n      if (Array.isArray(value)) {\n        el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));\n      } else {\n        el.checked = !!value;\n      }\n    }\n  } else if (el.tagName === \"SELECT\") {\n    updateSelect(el, value);\n  } else {\n    if (el.value === value)\n      return;\n    el.value = value === void 0 ? \"\" : value;\n  }\n}\nfunction bindClasses(el, value) {\n  if (el._x_undoAddedClasses)\n    el._x_undoAddedClasses();\n  el._x_undoAddedClasses = setClasses(el, value);\n}\nfunction bindStyles(el, value) {\n  if (el._x_undoAddedStyles)\n    el._x_undoAddedStyles();\n  el._x_undoAddedStyles = setStyles(el, value);\n}\nfunction bindAttributeAndProperty(el, name, value) {\n  bindAttribute(el, name, value);\n  setPropertyIfChanged(el, name, value);\n}\nfunction bindAttribute(el, name, value) {\n  if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {\n    el.removeAttribute(name);\n  } else {\n    if (isBooleanAttr(name))\n      value = name;\n    setIfChanged(el, name, value);\n  }\n}\nfunction setIfChanged(el, attrName, value) {\n  if (el.getAttribute(attrName) != value) {\n    el.setAttribute(attrName, value);\n  }\n}\nfunction setPropertyIfChanged(el, propName, value) {\n  if (el[propName] !== value) {\n    el[propName] = value;\n  }\n}\nfunction updateSelect(el, value) {\n  const arrayWrappedValue = [].concat(value).map((value2) => {\n    return value2 + \"\";\n  });\n  Array.from(el.options).forEach((option) => {\n    option.selected = arrayWrappedValue.includes(option.value);\n  });\n}\nfunction camelCase(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction checkedAttrLooseCompare(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction safeParseBoolean(rawValue) {\n  if ([1, \"1\", \"true\", \"on\", \"yes\", true].includes(rawValue)) {\n    return true;\n  }\n  if ([0, \"0\", \"false\", \"off\", \"no\", false].includes(rawValue)) {\n    return false;\n  }\n  return rawValue ? Boolean(rawValue) : null;\n}\nvar booleanAttributes = /* @__PURE__ */ new Set([\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"inert\",\n  \"ismap\",\n  \"itemscope\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\",\n  \"shadowrootclonable\",\n  \"shadowrootdelegatesfocus\",\n  \"shadowrootserializable\"\n]);\nfunction isBooleanAttr(attrName) {\n  return booleanAttributes.has(attrName);\n}\nfunction attributeShouldntBePreservedIfFalsy(name) {\n  return ![\"aria-pressed\", \"aria-checked\", \"aria-expanded\", \"aria-selected\"].includes(name);\n}\nfunction getBinding(el, name, fallback) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  return getAttributeBinding(el, name, fallback);\n}\nfunction extractProp(el, name, fallback, extract = true) {\n  if (el._x_bindings && el._x_bindings[name] !== void 0)\n    return el._x_bindings[name];\n  if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {\n    let binding = el._x_inlineBindings[name];\n    binding.extract = extract;\n    return dontAutoEvaluateFunctions(() => {\n      return evaluate(el, binding.expression);\n    });\n  }\n  return getAttributeBinding(el, name, fallback);\n}\nfunction getAttributeBinding(el, name, fallback) {\n  let attr = el.getAttribute(name);\n  if (attr === null)\n    return typeof fallback === \"function\" ? fallback() : fallback;\n  if (attr === \"\")\n    return true;\n  if (isBooleanAttr(name)) {\n    return !![name, \"true\"].includes(attr);\n  }\n  return attr;\n}\nfunction isCheckbox(el) {\n  return el.type === \"checkbox\" || el.localName === \"ui-checkbox\" || el.localName === \"ui-switch\";\n}\nfunction isRadio(el) {\n  return el.type === \"radio\" || el.localName === \"ui-radio\";\n}\n\n// packages/alpinejs/src/utils/debounce.js\nfunction debounce(func, wait) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      func.apply(context, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// packages/alpinejs/src/utils/throttle.js\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    let context = this, args = arguments;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\n// packages/alpinejs/src/entangle.js\nfunction entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {\n  let firstRun = true;\n  let outerHash;\n  let innerHash;\n  let reference = effect(() => {\n    let outer = outerGet();\n    let inner = innerGet();\n    if (firstRun) {\n      innerSet(cloneIfObject(outer));\n      firstRun = false;\n    } else {\n      let outerHashLatest = JSON.stringify(outer);\n      let innerHashLatest = JSON.stringify(inner);\n      if (outerHashLatest !== outerHash) {\n        innerSet(cloneIfObject(outer));\n      } else if (outerHashLatest !== innerHashLatest) {\n        outerSet(cloneIfObject(inner));\n      } else {\n      }\n    }\n    outerHash = JSON.stringify(outerGet());\n    innerHash = JSON.stringify(innerGet());\n  });\n  return () => {\n    release(reference);\n  };\n}\nfunction cloneIfObject(value) {\n  return typeof value === \"object\" ? JSON.parse(JSON.stringify(value)) : value;\n}\n\n// packages/alpinejs/src/plugin.js\nfunction module_esm_plugin(callback) {\n  let callbacks = Array.isArray(callback) ? callback : [callback];\n  callbacks.forEach((i) => i(alpine_default));\n}\n\n// packages/alpinejs/src/store.js\nvar stores = {};\nvar isReactive = false;\nfunction store(name, value) {\n  if (!isReactive) {\n    stores = reactive(stores);\n    isReactive = true;\n  }\n  if (value === void 0) {\n    return stores[name];\n  }\n  stores[name] = value;\n  initInterceptors(stores[name]);\n  if (typeof value === \"object\" && value !== null && value.hasOwnProperty(\"init\") && typeof value.init === \"function\") {\n    stores[name].init();\n  }\n}\nfunction getStores() {\n  return stores;\n}\n\n// packages/alpinejs/src/binds.js\nvar binds = {};\nfunction bind2(name, bindings) {\n  let getBindings = typeof bindings !== \"function\" ? () => bindings : bindings;\n  if (name instanceof Element) {\n    return applyBindingsObject(name, getBindings());\n  } else {\n    binds[name] = getBindings;\n  }\n  return () => {\n  };\n}\nfunction injectBindingProviders(obj) {\n  Object.entries(binds).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback(...args);\n        };\n      }\n    });\n  });\n  return obj;\n}\nfunction applyBindingsObject(el, obj, original) {\n  let cleanupRunners = [];\n  while (cleanupRunners.length)\n    cleanupRunners.pop()();\n  let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));\n  let staticAttributes = attributesOnly(attributes);\n  attributes = attributes.map((attribute) => {\n    if (staticAttributes.find((attr) => attr.name === attribute.name)) {\n      return {\n        name: `x-bind:${attribute.name}`,\n        value: `\"${attribute.value}\"`\n      };\n    }\n    return attribute;\n  });\n  directives(el, attributes, original).map((handle) => {\n    cleanupRunners.push(handle.runCleanups);\n    handle();\n  });\n  return () => {\n    while (cleanupRunners.length)\n      cleanupRunners.pop()();\n  };\n}\n\n// packages/alpinejs/src/datas.js\nvar datas = {};\nfunction data(name, callback) {\n  datas[name] = callback;\n}\nfunction injectDataProviders(obj, context) {\n  Object.entries(datas).forEach(([name, callback]) => {\n    Object.defineProperty(obj, name, {\n      get() {\n        return (...args) => {\n          return callback.bind(context)(...args);\n        };\n      },\n      enumerable: false\n    });\n  });\n  return obj;\n}\n\n// packages/alpinejs/src/alpine.js\nvar Alpine = {\n  get reactive() {\n    return reactive;\n  },\n  get release() {\n    return release;\n  },\n  get effect() {\n    return effect;\n  },\n  get raw() {\n    return raw;\n  },\n  version: \"3.14.3\",\n  flushAndStopDeferringMutations,\n  dontAutoEvaluateFunctions,\n  disableEffectScheduling,\n  startObservingMutations,\n  stopObservingMutations,\n  setReactivityEngine,\n  onAttributeRemoved,\n  onAttributesAdded,\n  closestDataStack,\n  skipDuringClone,\n  onlyDuringClone,\n  addRootSelector,\n  addInitSelector,\n  interceptClone,\n  addScopeToNode,\n  deferMutations,\n  mapAttributes,\n  evaluateLater,\n  interceptInit,\n  setEvaluator,\n  mergeProxies,\n  extractProp,\n  findClosest,\n  onElRemoved,\n  closestRoot,\n  destroyTree,\n  interceptor,\n  // INTERNAL: not public API and is subject to change without major release.\n  transition,\n  // INTERNAL\n  setStyles,\n  // INTERNAL\n  mutateDom,\n  directive,\n  entangle,\n  throttle,\n  debounce,\n  evaluate,\n  initTree,\n  nextTick,\n  prefixed: prefix,\n  prefix: setPrefix,\n  plugin: module_esm_plugin,\n  magic,\n  store,\n  start,\n  clone,\n  // INTERNAL\n  cloneNode,\n  // INTERNAL\n  bound: getBinding,\n  $data: scope,\n  watch,\n  walk,\n  data,\n  bind: bind2\n};\nvar alpine_default = Alpine;\n\n// node_modules/@vue/shared/dist/shared.esm-bundler.js\nfunction makeMap(str, expectsLowerCase) {\n  const map = /* @__PURE__ */ Object.create(null);\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n}\nvar specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nvar isBooleanAttr2 = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);\nvar EMPTY_OBJ =  true ? Object.freeze({}) : 0;\nvar EMPTY_ARR =  true ? Object.freeze([]) : 0;\nvar module_esm_hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hasOwn = (val, key) => module_esm_hasOwnProperty.call(val, key);\nvar isArray = Array.isArray;\nvar isMap = (val) => toTypeString(val) === \"[object Map]\";\nvar isString = (val) => typeof val === \"string\";\nvar isSymbol = (val) => typeof val === \"symbol\";\nvar isObject = (val) => val !== null && typeof val === \"object\";\nvar objectToString = Object.prototype.toString;\nvar toTypeString = (value) => objectToString.call(value);\nvar toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nvar isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nvar cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nvar capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\nvar toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\nvar hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\n\n// node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js\nvar targetMap = /* @__PURE__ */ new WeakMap();\nvar effectStack = [];\nvar activeEffect;\nvar ITERATE_KEY = Symbol( true ? \"iterate\" : 0);\nvar MAP_KEY_ITERATE_KEY = Symbol( true ? \"Map key iterate\" : 0);\nfunction isEffect(fn) {\n  return fn && fn._isEffect === true;\n}\nfunction effect2(fn, options = EMPTY_OBJ) {\n  if (isEffect(fn)) {\n    fn = fn.raw;\n  }\n  const effect3 = createReactiveEffect(fn, options);\n  if (!options.lazy) {\n    effect3();\n  }\n  return effect3;\n}\nfunction stop(effect3) {\n  if (effect3.active) {\n    cleanup(effect3);\n    if (effect3.options.onStop) {\n      effect3.options.onStop();\n    }\n    effect3.active = false;\n  }\n}\nvar uid = 0;\nfunction createReactiveEffect(fn, options) {\n  const effect3 = function reactiveEffect() {\n    if (!effect3.active) {\n      return fn();\n    }\n    if (!effectStack.includes(effect3)) {\n      cleanup(effect3);\n      try {\n        enableTracking();\n        effectStack.push(effect3);\n        activeEffect = effect3;\n        return fn();\n      } finally {\n        effectStack.pop();\n        resetTracking();\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  };\n  effect3.id = uid++;\n  effect3.allowRecurse = !!options.allowRecurse;\n  effect3._isEffect = true;\n  effect3.active = true;\n  effect3.raw = fn;\n  effect3.deps = [];\n  effect3.options = options;\n  return effect3;\n}\nfunction cleanup(effect3) {\n  const { deps } = effect3;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect3);\n    }\n    deps.length = 0;\n  }\n}\nvar shouldTrack = true;\nvar trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (!shouldTrack || activeEffect === void 0) {\n    return;\n  }\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, dep = /* @__PURE__ */ new Set());\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (activeEffect.options.onTrack) {\n      activeEffect.options.onTrack({\n        effect: activeEffect,\n        target,\n        type,\n        key\n      });\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  const effects = /* @__PURE__ */ new Set();\n  const add2 = (effectsToAdd) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach((effect3) => {\n        if (effect3 !== activeEffect || effect3.allowRecurse) {\n          effects.add(effect3);\n        }\n      });\n    }\n  };\n  if (type === \"clear\") {\n    depsMap.forEach(add2);\n  } else if (key === \"length\" && isArray(target)) {\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newValue) {\n        add2(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      add2(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          add2(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            add2(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          add2(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const run = (effect3) => {\n    if (effect3.options.onTrigger) {\n      effect3.options.onTrigger({\n        effect: effect3,\n        target,\n        key,\n        type,\n        newValue,\n        oldValue,\n        oldTarget\n      });\n    }\n    if (effect3.options.scheduler) {\n      effect3.options.scheduler(effect3);\n    } else {\n      effect3();\n    }\n  };\n  effects.forEach(run);\n}\nvar isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nvar builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));\nvar get2 = /* @__PURE__ */ createGetter();\nvar readonlyGet = /* @__PURE__ */ createGetter(true);\nvar arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get3(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n    if (isObject(res)) {\n      return isReadonly ? readonly(res) : reactive2(res);\n    }\n    return res;\n  };\n}\nvar set2 = /* @__PURE__ */ createSetter();\nfunction createSetter(shallow = false) {\n  return function set3(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!shallow) {\n      value = toRaw(value);\n      oldValue = toRaw(oldValue);\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nvar mutableHandlers = {\n  get: get2,\n  set: set2,\n  deleteProperty,\n  has,\n  ownKeys\n};\nvar readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (true) {\n      console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (true) {\n      console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n};\nvar toReactive = (value) => isObject(value) ? reactive2(value) : value;\nvar toReadonly = (value) => isObject(value) ? readonly(value) : value;\nvar toShallow = (value) => value;\nvar getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n  target = target[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"get\", key);\n  }\n  !isReadonly && track(rawTarget, \"get\", rawKey);\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has$1(key, isReadonly = false) {\n  const target = this[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"has\", key);\n  }\n  !isReadonly && track(rawTarget, \"has\", rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\n    \"__v_raw\"\n    /* RAW */\n  ];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set$1(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get3 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get3.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get3 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (true) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get3 ? get3.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget =  true ? isMap(target) ? new Map(target) : new Set(target) : 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\n      \"__v_raw\"\n      /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\n      \"__v_raw\"\n      /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (true) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get$1(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\n      \"add\"\n      /* ADD */\n    ),\n    set: createReadonlyMethod(\n      \"set\"\n      /* SET */\n    ),\n    delete: createReadonlyMethod(\n      \"delete\"\n      /* DELETE */\n    ),\n    clear: createReadonlyMethod(\n      \"clear\"\n      /* CLEAR */\n    ),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n    add: createReadonlyMethod(\n      \"add\"\n      /* ADD */\n    ),\n    set: createReadonlyMethod(\n      \"set\"\n      /* SET */\n    ),\n    delete: createReadonlyMethod(\n      \"delete\"\n      /* DELETE */\n    ),\n    clear: createReadonlyMethod(\n      \"clear\"\n      /* CLEAR */\n    ),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nvar [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nvar mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nvar readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\nvar reactiveMap = /* @__PURE__ */ new WeakMap();\nvar shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nvar readonlyMap = /* @__PURE__ */ new WeakMap();\nvar shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction getTargetType(value) {\n  return value[\n    \"__v_skip\"\n    /* SKIP */\n  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));\n}\nfunction reactive2(target) {\n  if (target && target[\n    \"__v_isReadonly\"\n    /* IS_READONLY */\n  ]) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (true) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\n    \"__v_raw\"\n    /* RAW */\n  ] && !(isReadonly && target[\n    \"__v_isReactive\"\n    /* IS_REACTIVE */\n  ])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction toRaw(observed) {\n  return observed && toRaw(observed[\n    \"__v_raw\"\n    /* RAW */\n  ]) || observed;\n}\nfunction isRef(r) {\n  return Boolean(r && r.__v_isRef === true);\n}\n\n// packages/alpinejs/src/magics/$nextTick.js\nmagic(\"nextTick\", () => nextTick);\n\n// packages/alpinejs/src/magics/$dispatch.js\nmagic(\"dispatch\", (el) => dispatch.bind(dispatch, el));\n\n// packages/alpinejs/src/magics/$watch.js\nmagic(\"watch\", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {\n  let evaluate2 = evaluateLater2(key);\n  let getter = () => {\n    let value;\n    evaluate2((i) => value = i);\n    return value;\n  };\n  let unwatch = watch(getter, callback);\n  cleanup2(unwatch);\n});\n\n// packages/alpinejs/src/magics/$store.js\nmagic(\"store\", getStores);\n\n// packages/alpinejs/src/magics/$data.js\nmagic(\"data\", (el) => scope(el));\n\n// packages/alpinejs/src/magics/$root.js\nmagic(\"root\", (el) => closestRoot(el));\n\n// packages/alpinejs/src/magics/$refs.js\nmagic(\"refs\", (el) => {\n  if (el._x_refs_proxy)\n    return el._x_refs_proxy;\n  el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));\n  return el._x_refs_proxy;\n});\nfunction getArrayOfRefObject(el) {\n  let refObjects = [];\n  findClosest(el, (i) => {\n    if (i._x_refs)\n      refObjects.push(i._x_refs);\n  });\n  return refObjects;\n}\n\n// packages/alpinejs/src/ids.js\nvar globalIdMemo = {};\nfunction findAndIncrementId(name) {\n  if (!globalIdMemo[name])\n    globalIdMemo[name] = 0;\n  return ++globalIdMemo[name];\n}\nfunction closestIdRoot(el, name) {\n  return findClosest(el, (element) => {\n    if (element._x_ids && element._x_ids[name])\n      return true;\n  });\n}\nfunction setIdRoot(el, name) {\n  if (!el._x_ids)\n    el._x_ids = {};\n  if (!el._x_ids[name])\n    el._x_ids[name] = findAndIncrementId(name);\n}\n\n// packages/alpinejs/src/magics/$id.js\nmagic(\"id\", (el, { cleanup: cleanup2 }) => (name, key = null) => {\n  let cacheKey = `${name}${key ? `-${key}` : \"\"}`;\n  return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {\n    let root = closestIdRoot(el, name);\n    let id = root ? root._x_ids[name] : findAndIncrementId(name);\n    return key ? `${name}-${id}-${key}` : `${name}-${id}`;\n  });\n});\ninterceptClone((from, to) => {\n  if (from._x_id) {\n    to._x_id = from._x_id;\n  }\n});\nfunction cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {\n  if (!el._x_id)\n    el._x_id = {};\n  if (el._x_id[cacheKey])\n    return el._x_id[cacheKey];\n  let output = callback();\n  el._x_id[cacheKey] = output;\n  cleanup2(() => {\n    delete el._x_id[cacheKey];\n  });\n  return output;\n}\n\n// packages/alpinejs/src/magics/$el.js\nmagic(\"el\", (el) => el);\n\n// packages/alpinejs/src/magics/index.js\nwarnMissingPluginMagic(\"Focus\", \"focus\", \"focus\");\nwarnMissingPluginMagic(\"Persist\", \"persist\", \"persist\");\nfunction warnMissingPluginMagic(name, magicName, slug) {\n  magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/directives/x-modelable.js\ndirective(\"modelable\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {\n  let func = evaluateLater2(expression);\n  let innerGet = () => {\n    let result;\n    func((i) => result = i);\n    return result;\n  };\n  let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);\n  let innerSet = (val) => evaluateInnerSet(() => {\n  }, { scope: { \"__placeholder\": val } });\n  let initialValue = innerGet();\n  innerSet(initialValue);\n  queueMicrotask(() => {\n    if (!el._x_model)\n      return;\n    el._x_removeModelListeners[\"default\"]();\n    let outerGet = el._x_model.get;\n    let outerSet = el._x_model.set;\n    let releaseEntanglement = entangle(\n      {\n        get() {\n          return outerGet();\n        },\n        set(value) {\n          outerSet(value);\n        }\n      },\n      {\n        get() {\n          return innerGet();\n        },\n        set(value) {\n          innerSet(value);\n        }\n      }\n    );\n    cleanup2(releaseEntanglement);\n  });\n});\n\n// packages/alpinejs/src/directives/x-teleport.js\ndirective(\"teleport\", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-teleport can only be used on a <template> tag\", el);\n  let target = getTarget(expression);\n  let clone2 = el.content.cloneNode(true).firstElementChild;\n  el._x_teleport = clone2;\n  clone2._x_teleportBack = el;\n  el.setAttribute(\"data-teleport-template\", true);\n  clone2.setAttribute(\"data-teleport-target\", true);\n  if (el._x_forwardEvents) {\n    el._x_forwardEvents.forEach((eventName) => {\n      clone2.addEventListener(eventName, (e) => {\n        e.stopPropagation();\n        el.dispatchEvent(new e.constructor(e.type, e));\n      });\n    });\n  }\n  addScopeToNode(clone2, {}, el);\n  let placeInDom = (clone3, target2, modifiers2) => {\n    if (modifiers2.includes(\"prepend\")) {\n      target2.parentNode.insertBefore(clone3, target2);\n    } else if (modifiers2.includes(\"append\")) {\n      target2.parentNode.insertBefore(clone3, target2.nextSibling);\n    } else {\n      target2.appendChild(clone3);\n    }\n  };\n  mutateDom(() => {\n    placeInDom(clone2, target, modifiers);\n    skipDuringClone(() => {\n      initTree(clone2);\n      clone2._x_ignore = true;\n    })();\n  });\n  el._x_teleportPutBack = () => {\n    let target2 = getTarget(expression);\n    mutateDom(() => {\n      placeInDom(el._x_teleport, target2, modifiers);\n    });\n  };\n  cleanup2(\n    () => mutateDom(() => {\n      clone2.remove();\n      destroyTree(clone2);\n    })\n  );\n});\nvar teleportContainerDuringClone = document.createElement(\"div\");\nfunction getTarget(expression) {\n  let target = skipDuringClone(() => {\n    return document.querySelector(expression);\n  }, () => {\n    return teleportContainerDuringClone;\n  })();\n  if (!target)\n    warn(`Cannot find x-teleport element for selector: \"${expression}\"`);\n  return target;\n}\n\n// packages/alpinejs/src/directives/x-ignore.js\nvar handler = () => {\n};\nhandler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {\n  modifiers.includes(\"self\") ? el._x_ignoreSelf = true : el._x_ignore = true;\n  cleanup2(() => {\n    modifiers.includes(\"self\") ? delete el._x_ignoreSelf : delete el._x_ignore;\n  });\n};\ndirective(\"ignore\", handler);\n\n// packages/alpinejs/src/directives/x-effect.js\ndirective(\"effect\", skipDuringClone((el, { expression }, { effect: effect3 }) => {\n  effect3(evaluateLater(el, expression));\n}));\n\n// packages/alpinejs/src/utils/on.js\nfunction on(el, event, modifiers, callback) {\n  let listenerTarget = el;\n  let handler4 = (e) => callback(e);\n  let options = {};\n  let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);\n  if (modifiers.includes(\"dot\"))\n    event = dotSyntax(event);\n  if (modifiers.includes(\"camel\"))\n    event = camelCase2(event);\n  if (modifiers.includes(\"passive\"))\n    options.passive = true;\n  if (modifiers.includes(\"capture\"))\n    options.capture = true;\n  if (modifiers.includes(\"window\"))\n    listenerTarget = window;\n  if (modifiers.includes(\"document\"))\n    listenerTarget = document;\n  if (modifiers.includes(\"debounce\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"debounce\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler4 = debounce(handler4, wait);\n  }\n  if (modifiers.includes(\"throttle\")) {\n    let nextModifier = modifiers[modifiers.indexOf(\"throttle\") + 1] || \"invalid-wait\";\n    let wait = isNumeric(nextModifier.split(\"ms\")[0]) ? Number(nextModifier.split(\"ms\")[0]) : 250;\n    handler4 = throttle(handler4, wait);\n  }\n  if (modifiers.includes(\"prevent\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.preventDefault();\n      next(e);\n    });\n  if (modifiers.includes(\"stop\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.stopPropagation();\n      next(e);\n    });\n  if (modifiers.includes(\"once\")) {\n    handler4 = wrapHandler(handler4, (next, e) => {\n      next(e);\n      listenerTarget.removeEventListener(event, handler4, options);\n    });\n  }\n  if (modifiers.includes(\"away\") || modifiers.includes(\"outside\")) {\n    listenerTarget = document;\n    handler4 = wrapHandler(handler4, (next, e) => {\n      if (el.contains(e.target))\n        return;\n      if (e.target.isConnected === false)\n        return;\n      if (el.offsetWidth < 1 && el.offsetHeight < 1)\n        return;\n      if (el._x_isShown === false)\n        return;\n      next(e);\n    });\n  }\n  if (modifiers.includes(\"self\"))\n    handler4 = wrapHandler(handler4, (next, e) => {\n      e.target === el && next(e);\n    });\n  if (isKeyEvent(event) || isClickEvent(event)) {\n    handler4 = wrapHandler(handler4, (next, e) => {\n      if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n        return;\n      }\n      next(e);\n    });\n  }\n  listenerTarget.addEventListener(event, handler4, options);\n  return () => {\n    listenerTarget.removeEventListener(event, handler4, options);\n  };\n}\nfunction dotSyntax(subject) {\n  return subject.replace(/-/g, \".\");\n}\nfunction camelCase2(subject) {\n  return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n}\nfunction isNumeric(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction kebabCase2(subject) {\n  if ([\" \", \"_\"].includes(\n    subject\n  ))\n    return subject;\n  return subject.replace(/([a-z])([A-Z])/g, \"$1-$2\").replace(/[_\\s]/, \"-\").toLowerCase();\n}\nfunction isKeyEvent(event) {\n  return [\"keydown\", \"keyup\"].includes(event);\n}\nfunction isClickEvent(event) {\n  return [\"contextmenu\", \"click\", \"mouse\"].some((i) => event.includes(i));\n}\nfunction isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n  let keyModifiers = modifiers.filter((i) => {\n    return ![\"window\", \"document\", \"prevent\", \"stop\", \"once\", \"capture\", \"self\", \"away\", \"outside\", \"passive\"].includes(i);\n  });\n  if (keyModifiers.includes(\"debounce\")) {\n    let debounceIndex = keyModifiers.indexOf(\"debounce\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.includes(\"throttle\")) {\n    let debounceIndex = keyModifiers.indexOf(\"throttle\");\n    keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || \"invalid-wait\").split(\"ms\")[0]) ? 2 : 1);\n  }\n  if (keyModifiers.length === 0)\n    return false;\n  if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))\n    return false;\n  const systemKeyModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\", \"cmd\", \"super\"];\n  const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));\n  keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));\n  if (selectedSystemKeyModifiers.length > 0) {\n    const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {\n      if (modifier === \"cmd\" || modifier === \"super\")\n        modifier = \"meta\";\n      return e[`${modifier}Key`];\n    });\n    if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n      if (isClickEvent(e.type))\n        return false;\n      if (keyToModifiers(e.key).includes(keyModifiers[0]))\n        return false;\n    }\n  }\n  return true;\n}\nfunction keyToModifiers(key) {\n  if (!key)\n    return [];\n  key = kebabCase2(key);\n  let modifierToKeyMap = {\n    \"ctrl\": \"control\",\n    \"slash\": \"/\",\n    \"space\": \" \",\n    \"spacebar\": \" \",\n    \"cmd\": \"meta\",\n    \"esc\": \"escape\",\n    \"up\": \"arrow-up\",\n    \"down\": \"arrow-down\",\n    \"left\": \"arrow-left\",\n    \"right\": \"arrow-right\",\n    \"period\": \".\",\n    \"comma\": \",\",\n    \"equal\": \"=\",\n    \"minus\": \"-\",\n    \"underscore\": \"_\"\n  };\n  modifierToKeyMap[key] = key;\n  return Object.keys(modifierToKeyMap).map((modifier) => {\n    if (modifierToKeyMap[modifier] === key)\n      return modifier;\n  }).filter((modifier) => modifier);\n}\n\n// packages/alpinejs/src/directives/x-model.js\ndirective(\"model\", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  let scopeTarget = el;\n  if (modifiers.includes(\"parent\")) {\n    scopeTarget = el.parentNode;\n  }\n  let evaluateGet = evaluateLater(scopeTarget, expression);\n  let evaluateSet;\n  if (typeof expression === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);\n  } else if (typeof expression === \"function\" && typeof expression() === \"string\") {\n    evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);\n  } else {\n    evaluateSet = () => {\n    };\n  }\n  let getValue = () => {\n    let result;\n    evaluateGet((value) => result = value);\n    return isGetterSetter(result) ? result.get() : result;\n  };\n  let setValue = (value) => {\n    let result;\n    evaluateGet((value2) => result = value2);\n    if (isGetterSetter(result)) {\n      result.set(value);\n    } else {\n      evaluateSet(() => {\n      }, {\n        scope: { \"__placeholder\": value }\n      });\n    }\n  };\n  if (typeof expression === \"string\" && el.type === \"radio\") {\n    mutateDom(() => {\n      if (!el.hasAttribute(\"name\"))\n        el.setAttribute(\"name\", expression);\n    });\n  }\n  var event = el.tagName.toLowerCase() === \"select\" || [\"checkbox\", \"radio\"].includes(el.type) || modifiers.includes(\"lazy\") ? \"change\" : \"input\";\n  let removeListener = isCloning ? () => {\n  } : on(el, event, modifiers, (e) => {\n    setValue(getInputValue(el, modifiers, e, getValue()));\n  });\n  if (modifiers.includes(\"fill\")) {\n    if ([void 0, null, \"\"].includes(getValue()) || isCheckbox(el) && Array.isArray(getValue()) || el.tagName.toLowerCase() === \"select\" && el.multiple) {\n      setValue(\n        getInputValue(el, modifiers, { target: el }, getValue())\n      );\n    }\n  }\n  if (!el._x_removeModelListeners)\n    el._x_removeModelListeners = {};\n  el._x_removeModelListeners[\"default\"] = removeListener;\n  cleanup2(() => el._x_removeModelListeners[\"default\"]());\n  if (el.form) {\n    let removeResetListener = on(el.form, \"reset\", [], (e) => {\n      nextTick(() => el._x_model && el._x_model.set(getInputValue(el, modifiers, { target: el }, getValue())));\n    });\n    cleanup2(() => removeResetListener());\n  }\n  el._x_model = {\n    get() {\n      return getValue();\n    },\n    set(value) {\n      setValue(value);\n    }\n  };\n  el._x_forceModelUpdate = (value) => {\n    if (value === void 0 && typeof expression === \"string\" && expression.match(/\\./))\n      value = \"\";\n    window.fromModel = true;\n    mutateDom(() => bind(el, \"value\", value));\n    delete window.fromModel;\n  };\n  effect3(() => {\n    let value = getValue();\n    if (modifiers.includes(\"unintrusive\") && document.activeElement.isSameNode(el))\n      return;\n    el._x_forceModelUpdate(value);\n  });\n});\nfunction getInputValue(el, modifiers, event, currentValue) {\n  return mutateDom(() => {\n    if (event instanceof CustomEvent && event.detail !== void 0)\n      return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;\n    else if (isCheckbox(el)) {\n      if (Array.isArray(currentValue)) {\n        let newValue = null;\n        if (modifiers.includes(\"number\")) {\n          newValue = safeParseNumber(event.target.value);\n        } else if (modifiers.includes(\"boolean\")) {\n          newValue = safeParseBoolean(event.target.value);\n        } else {\n          newValue = event.target.value;\n        }\n        return event.target.checked ? currentValue.includes(newValue) ? currentValue : currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));\n      } else {\n        return event.target.checked;\n      }\n    } else if (el.tagName.toLowerCase() === \"select\" && el.multiple) {\n      if (modifiers.includes(\"number\")) {\n        return Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        });\n      } else if (modifiers.includes(\"boolean\")) {\n        return Array.from(event.target.selectedOptions).map((option) => {\n          let rawValue = option.value || option.text;\n          return safeParseBoolean(rawValue);\n        });\n      }\n      return Array.from(event.target.selectedOptions).map((option) => {\n        return option.value || option.text;\n      });\n    } else {\n      let newValue;\n      if (isRadio(el)) {\n        if (event.target.checked) {\n          newValue = event.target.value;\n        } else {\n          newValue = currentValue;\n        }\n      } else {\n        newValue = event.target.value;\n      }\n      if (modifiers.includes(\"number\")) {\n        return safeParseNumber(newValue);\n      } else if (modifiers.includes(\"boolean\")) {\n        return safeParseBoolean(newValue);\n      } else if (modifiers.includes(\"trim\")) {\n        return newValue.trim();\n      } else {\n        return newValue;\n      }\n    }\n  });\n}\nfunction safeParseNumber(rawValue) {\n  let number = rawValue ? parseFloat(rawValue) : null;\n  return isNumeric2(number) ? number : rawValue;\n}\nfunction checkedAttrLooseCompare2(valueA, valueB) {\n  return valueA == valueB;\n}\nfunction isNumeric2(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\nfunction isGetterSetter(value) {\n  return value !== null && typeof value === \"object\" && typeof value.get === \"function\" && typeof value.set === \"function\";\n}\n\n// packages/alpinejs/src/directives/x-cloak.js\ndirective(\"cloak\", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix(\"cloak\")))));\n\n// packages/alpinejs/src/directives/x-init.js\naddInitSelector(() => `[${prefix(\"init\")}]`);\ndirective(\"init\", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {\n  if (typeof expression === \"string\") {\n    return !!expression.trim() && evaluate2(expression, {}, false);\n  }\n  return evaluate2(expression, {}, false);\n}));\n\n// packages/alpinejs/src/directives/x-text.js\ndirective(\"text\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.textContent = value;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-html.js\ndirective(\"html\", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {\n  let evaluate2 = evaluateLater2(expression);\n  effect3(() => {\n    evaluate2((value) => {\n      mutateDom(() => {\n        el.innerHTML = value;\n        el._x_ignoreSelf = true;\n        initTree(el);\n        delete el._x_ignoreSelf;\n      });\n    });\n  });\n});\n\n// packages/alpinejs/src/directives/x-bind.js\nmapAttributes(startingWith(\":\", into(prefix(\"bind:\"))));\nvar handler2 = (el, { value, modifiers, expression, original }, { effect: effect3, cleanup: cleanup2 }) => {\n  if (!value) {\n    let bindingProviders = {};\n    injectBindingProviders(bindingProviders);\n    let getBindings = evaluateLater(el, expression);\n    getBindings((bindings) => {\n      applyBindingsObject(el, bindings, original);\n    }, { scope: bindingProviders });\n    return;\n  }\n  if (value === \"key\")\n    return storeKeyForXFor(el, expression);\n  if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {\n    return;\n  }\n  let evaluate2 = evaluateLater(el, expression);\n  effect3(() => evaluate2((result) => {\n    if (result === void 0 && typeof expression === \"string\" && expression.match(/\\./)) {\n      result = \"\";\n    }\n    mutateDom(() => bind(el, value, result, modifiers));\n  }));\n  cleanup2(() => {\n    el._x_undoAddedClasses && el._x_undoAddedClasses();\n    el._x_undoAddedStyles && el._x_undoAddedStyles();\n  });\n};\nhandler2.inline = (el, { value, modifiers, expression }) => {\n  if (!value)\n    return;\n  if (!el._x_inlineBindings)\n    el._x_inlineBindings = {};\n  el._x_inlineBindings[value] = { expression, extract: false };\n};\ndirective(\"bind\", handler2);\nfunction storeKeyForXFor(el, expression) {\n  el._x_keyExpression = expression;\n}\n\n// packages/alpinejs/src/directives/x-data.js\naddRootSelector(() => `[${prefix(\"data\")}]`);\ndirective(\"data\", (el, { expression }, { cleanup: cleanup2 }) => {\n  if (shouldSkipRegisteringDataDuringClone(el))\n    return;\n  expression = expression === \"\" ? \"{}\" : expression;\n  let magicContext = {};\n  injectMagics(magicContext, el);\n  let dataProviderContext = {};\n  injectDataProviders(dataProviderContext, magicContext);\n  let data2 = evaluate(el, expression, { scope: dataProviderContext });\n  if (data2 === void 0 || data2 === true)\n    data2 = {};\n  injectMagics(data2, el);\n  let reactiveData = reactive(data2);\n  initInterceptors(reactiveData);\n  let undo = addScopeToNode(el, reactiveData);\n  reactiveData[\"init\"] && evaluate(el, reactiveData[\"init\"]);\n  cleanup2(() => {\n    reactiveData[\"destroy\"] && evaluate(el, reactiveData[\"destroy\"]);\n    undo();\n  });\n});\ninterceptClone((from, to) => {\n  if (from._x_dataStack) {\n    to._x_dataStack = from._x_dataStack;\n    to.setAttribute(\"data-has-alpine-state\", true);\n  }\n});\nfunction shouldSkipRegisteringDataDuringClone(el) {\n  if (!isCloning)\n    return false;\n  if (isCloningLegacy)\n    return true;\n  return el.hasAttribute(\"data-has-alpine-state\");\n}\n\n// packages/alpinejs/src/directives/x-show.js\ndirective(\"show\", (el, { modifiers, expression }, { effect: effect3 }) => {\n  let evaluate2 = evaluateLater(el, expression);\n  if (!el._x_doHide)\n    el._x_doHide = () => {\n      mutateDom(() => {\n        el.style.setProperty(\"display\", \"none\", modifiers.includes(\"important\") ? \"important\" : void 0);\n      });\n    };\n  if (!el._x_doShow)\n    el._x_doShow = () => {\n      mutateDom(() => {\n        if (el.style.length === 1 && el.style.display === \"none\") {\n          el.removeAttribute(\"style\");\n        } else {\n          el.style.removeProperty(\"display\");\n        }\n      });\n    };\n  let hide = () => {\n    el._x_doHide();\n    el._x_isShown = false;\n  };\n  let show = () => {\n    el._x_doShow();\n    el._x_isShown = true;\n  };\n  let clickAwayCompatibleShow = () => setTimeout(show);\n  let toggle = once(\n    (value) => value ? show() : hide(),\n    (value) => {\n      if (typeof el._x_toggleAndCascadeWithTransitions === \"function\") {\n        el._x_toggleAndCascadeWithTransitions(el, value, show, hide);\n      } else {\n        value ? clickAwayCompatibleShow() : hide();\n      }\n    }\n  );\n  let oldValue;\n  let firstTime = true;\n  effect3(() => evaluate2((value) => {\n    if (!firstTime && value === oldValue)\n      return;\n    if (modifiers.includes(\"immediate\"))\n      value ? clickAwayCompatibleShow() : hide();\n    toggle(value);\n    oldValue = value;\n    firstTime = false;\n  }));\n});\n\n// packages/alpinejs/src/directives/x-for.js\ndirective(\"for\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  let iteratorNames = parseForExpression(expression);\n  let evaluateItems = evaluateLater(el, iteratorNames.items);\n  let evaluateKey = evaluateLater(\n    el,\n    // the x-bind:key expression is stored for our use instead of evaluated.\n    el._x_keyExpression || \"index\"\n  );\n  el._x_prevKeys = [];\n  el._x_lookup = {};\n  effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));\n  cleanup2(() => {\n    Object.values(el._x_lookup).forEach((el2) => mutateDom(\n      () => {\n        destroyTree(el2);\n        el2.remove();\n      }\n    ));\n    delete el._x_prevKeys;\n    delete el._x_lookup;\n  });\n});\nfunction loop(el, iteratorNames, evaluateItems, evaluateKey) {\n  let isObject2 = (i) => typeof i === \"object\" && !Array.isArray(i);\n  let templateEl = el;\n  evaluateItems((items) => {\n    if (isNumeric3(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), (i) => i + 1);\n    }\n    if (items === void 0)\n      items = [];\n    let lookup = el._x_lookup;\n    let prevKeys = el._x_prevKeys;\n    let scopes = [];\n    let keys = [];\n    if (isObject2(items)) {\n      items = Object.entries(items).map(([key, value]) => {\n        let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);\n        evaluateKey((value2) => {\n          if (keys.includes(value2))\n            warn(\"Duplicate key on x-for\", el);\n          keys.push(value2);\n        }, { scope: { index: key, ...scope2 } });\n        scopes.push(scope2);\n      });\n    } else {\n      for (let i = 0; i < items.length; i++) {\n        let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);\n        evaluateKey((value) => {\n          if (keys.includes(value))\n            warn(\"Duplicate key on x-for\", el);\n          keys.push(value);\n        }, { scope: { index: i, ...scope2 } });\n        scopes.push(scope2);\n      }\n    }\n    let adds = [];\n    let moves = [];\n    let removes = [];\n    let sames = [];\n    for (let i = 0; i < prevKeys.length; i++) {\n      let key = prevKeys[i];\n      if (keys.indexOf(key) === -1)\n        removes.push(key);\n    }\n    prevKeys = prevKeys.filter((key) => !removes.includes(key));\n    let lastKey = \"template\";\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let prevIndex = prevKeys.indexOf(key);\n      if (prevIndex === -1) {\n        prevKeys.splice(i, 0, key);\n        adds.push([lastKey, i]);\n      } else if (prevIndex !== i) {\n        let keyInSpot = prevKeys.splice(i, 1)[0];\n        let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];\n        prevKeys.splice(i, 0, keyForSpot);\n        prevKeys.splice(prevIndex, 0, keyInSpot);\n        moves.push([keyInSpot, keyForSpot]);\n      } else {\n        sames.push(key);\n      }\n      lastKey = key;\n    }\n    for (let i = 0; i < removes.length; i++) {\n      let key = removes[i];\n      if (!(key in lookup))\n        continue;\n      mutateDom(() => {\n        destroyTree(lookup[key]);\n        lookup[key].remove();\n      });\n      delete lookup[key];\n    }\n    for (let i = 0; i < moves.length; i++) {\n      let [keyInSpot, keyForSpot] = moves[i];\n      let elInSpot = lookup[keyInSpot];\n      let elForSpot = lookup[keyForSpot];\n      let marker = document.createElement(\"div\");\n      mutateDom(() => {\n        if (!elForSpot)\n          warn(`x-for \":key\" is undefined or invalid`, templateEl, keyForSpot, lookup);\n        elForSpot.after(marker);\n        elInSpot.after(elForSpot);\n        elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);\n        marker.before(elInSpot);\n        elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);\n        marker.remove();\n      });\n      elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);\n    }\n    for (let i = 0; i < adds.length; i++) {\n      let [lastKey2, index] = adds[i];\n      let lastEl = lastKey2 === \"template\" ? templateEl : lookup[lastKey2];\n      if (lastEl._x_currentIfEl)\n        lastEl = lastEl._x_currentIfEl;\n      let scope2 = scopes[index];\n      let key = keys[index];\n      let clone2 = document.importNode(templateEl.content, true).firstElementChild;\n      let reactiveScope = reactive(scope2);\n      addScopeToNode(clone2, reactiveScope, templateEl);\n      clone2._x_refreshXForScope = (newScope) => {\n        Object.entries(newScope).forEach(([key2, value]) => {\n          reactiveScope[key2] = value;\n        });\n      };\n      mutateDom(() => {\n        lastEl.after(clone2);\n        skipDuringClone(() => initTree(clone2))();\n      });\n      if (typeof key === \"object\") {\n        warn(\"x-for key cannot be an object, it must be a string or an integer\", templateEl);\n      }\n      lookup[key] = clone2;\n    }\n    for (let i = 0; i < sames.length; i++) {\n      lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);\n    }\n    templateEl._x_prevKeys = keys;\n  });\n}\nfunction parseForExpression(expression) {\n  let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  let stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n  let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  let inMatch = expression.match(forAliasRE);\n  if (!inMatch)\n    return;\n  let res = {};\n  res.items = inMatch[2].trim();\n  let item = inMatch[1].replace(stripParensRE, \"\").trim();\n  let iteratorMatch = item.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.item = item.replace(forIteratorRE, \"\").trim();\n    res.index = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.collection = iteratorMatch[2].trim();\n    }\n  } else {\n    res.item = item;\n  }\n  return res;\n}\nfunction getIterationScopeVariables(iteratorNames, item, index, items) {\n  let scopeVariables = {};\n  if (/^\\[.*\\]$/.test(iteratorNames.item) && Array.isArray(item)) {\n    let names = iteratorNames.item.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name, i) => {\n      scopeVariables[name] = item[i];\n    });\n  } else if (/^\\{.*\\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === \"object\") {\n    let names = iteratorNames.item.replace(\"{\", \"\").replace(\"}\", \"\").split(\",\").map((i) => i.trim());\n    names.forEach((name) => {\n      scopeVariables[name] = item[name];\n    });\n  } else {\n    scopeVariables[iteratorNames.item] = item;\n  }\n  if (iteratorNames.index)\n    scopeVariables[iteratorNames.index] = index;\n  if (iteratorNames.collection)\n    scopeVariables[iteratorNames.collection] = items;\n  return scopeVariables;\n}\nfunction isNumeric3(subject) {\n  return !Array.isArray(subject) && !isNaN(subject);\n}\n\n// packages/alpinejs/src/directives/x-ref.js\nfunction handler3() {\n}\nhandler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {\n  let root = closestRoot(el);\n  if (!root._x_refs)\n    root._x_refs = {};\n  root._x_refs[expression] = el;\n  cleanup2(() => delete root._x_refs[expression]);\n};\ndirective(\"ref\", handler3);\n\n// packages/alpinejs/src/directives/x-if.js\ndirective(\"if\", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {\n  if (el.tagName.toLowerCase() !== \"template\")\n    warn(\"x-if can only be used on a <template> tag\", el);\n  let evaluate2 = evaluateLater(el, expression);\n  let show = () => {\n    if (el._x_currentIfEl)\n      return el._x_currentIfEl;\n    let clone2 = el.content.cloneNode(true).firstElementChild;\n    addScopeToNode(clone2, {}, el);\n    mutateDom(() => {\n      el.after(clone2);\n      skipDuringClone(() => initTree(clone2))();\n    });\n    el._x_currentIfEl = clone2;\n    el._x_undoIf = () => {\n      mutateDom(() => {\n        destroyTree(clone2);\n        clone2.remove();\n      });\n      delete el._x_currentIfEl;\n    };\n    return clone2;\n  };\n  let hide = () => {\n    if (!el._x_undoIf)\n      return;\n    el._x_undoIf();\n    delete el._x_undoIf;\n  };\n  effect3(() => evaluate2((value) => {\n    value ? show() : hide();\n  }));\n  cleanup2(() => el._x_undoIf && el._x_undoIf());\n});\n\n// packages/alpinejs/src/directives/x-id.js\ndirective(\"id\", (el, { expression }, { evaluate: evaluate2 }) => {\n  let names = evaluate2(expression);\n  names.forEach((name) => setIdRoot(el, name));\n});\ninterceptClone((from, to) => {\n  if (from._x_ids) {\n    to._x_ids = from._x_ids;\n  }\n});\n\n// packages/alpinejs/src/directives/x-on.js\nmapAttributes(startingWith(\"@\", into(prefix(\"on:\"))));\ndirective(\"on\", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {\n  let evaluate2 = expression ? evaluateLater(el, expression) : () => {\n  };\n  if (el.tagName.toLowerCase() === \"template\") {\n    if (!el._x_forwardEvents)\n      el._x_forwardEvents = [];\n    if (!el._x_forwardEvents.includes(value))\n      el._x_forwardEvents.push(value);\n  }\n  let removeListener = on(el, value, modifiers, (e) => {\n    evaluate2(() => {\n    }, { scope: { \"$event\": e }, params: [e] });\n  });\n  cleanup2(() => removeListener());\n}));\n\n// packages/alpinejs/src/directives/index.js\nwarnMissingPluginDirective(\"Collapse\", \"collapse\", \"collapse\");\nwarnMissingPluginDirective(\"Intersect\", \"intersect\", \"intersect\");\nwarnMissingPluginDirective(\"Focus\", \"trap\", \"focus\");\nwarnMissingPluginDirective(\"Mask\", \"mask\", \"mask\");\nfunction warnMissingPluginDirective(name, directiveName, slug) {\n  directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the \"${name}\" plugin here: https://alpinejs.dev/plugins/${slug}`, el));\n}\n\n// packages/alpinejs/src/index.js\nalpine_default.setEvaluator(normalEvaluator);\nalpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });\nvar src_default = alpine_default;\n\n// packages/alpinejs/builds/module.js\nvar module_default = src_default;\n\n\n;// ./assets/javascript/alpine.js\n\nwindow.Alpine = module_default;\ndocument.addEventListener('DOMContentLoaded', function () {\n  module_default.start();\n});\n;// ./node_modules/flowbite/lib/esm/dom/events.js\nvar Events = /** @class */ (function () {\n    function Events(eventType, eventFunctions) {\n        if (eventFunctions === void 0) { eventFunctions = []; }\n        this._eventType = eventType;\n        this._eventFunctions = eventFunctions;\n    }\n    Events.prototype.init = function () {\n        var _this = this;\n        this._eventFunctions.forEach(function (eventFunction) {\n            if (typeof window !== 'undefined') {\n                window.addEventListener(_this._eventType, eventFunction);\n            }\n        });\n    };\n    return Events;\n}());\n/* harmony default export */ const events = (Events);\n//# sourceMappingURL=events.js.map\n;// ./node_modules/flowbite/lib/esm/dom/instances.js\nvar Instances = /** @class */ (function () {\n    function Instances() {\n        this._instances = {\n            Accordion: {},\n            Carousel: {},\n            Collapse: {},\n            Dial: {},\n            Dismiss: {},\n            Drawer: {},\n            Dropdown: {},\n            Modal: {},\n            Popover: {},\n            Tabs: {},\n            Tooltip: {},\n            InputCounter: {},\n            CopyClipboard: {},\n            Datepicker: {},\n        };\n    }\n    Instances.prototype.addInstance = function (component, instance, id, override) {\n        if (override === void 0) { override = false; }\n        if (!this._instances[component]) {\n            console.warn(\"Flowbite: Component \".concat(component, \" does not exist.\"));\n            return false;\n        }\n        if (this._instances[component][id] && !override) {\n            console.warn(\"Flowbite: Instance with ID \".concat(id, \" already exists.\"));\n            return;\n        }\n        if (override && this._instances[component][id]) {\n            this._instances[component][id].destroyAndRemoveInstance();\n        }\n        this._instances[component][id ? id : this._generateRandomId()] =\n            instance;\n    };\n    Instances.prototype.getAllInstances = function () {\n        return this._instances;\n    };\n    Instances.prototype.getInstances = function (component) {\n        if (!this._instances[component]) {\n            console.warn(\"Flowbite: Component \".concat(component, \" does not exist.\"));\n            return false;\n        }\n        return this._instances[component];\n    };\n    Instances.prototype.getInstance = function (component, id) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n        if (!this._instances[component][id]) {\n            console.warn(\"Flowbite: Instance with ID \".concat(id, \" does not exist.\"));\n            return;\n        }\n        return this._instances[component][id];\n    };\n    Instances.prototype.destroyAndRemoveInstance = function (component, id) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n        this.destroyInstanceObject(component, id);\n        this.removeInstance(component, id);\n    };\n    Instances.prototype.removeInstance = function (component, id) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n        delete this._instances[component][id];\n    };\n    Instances.prototype.destroyInstanceObject = function (component, id) {\n        if (!this._componentAndInstanceCheck(component, id)) {\n            return;\n        }\n        this._instances[component][id].destroy();\n    };\n    Instances.prototype.instanceExists = function (component, id) {\n        if (!this._instances[component]) {\n            return false;\n        }\n        if (!this._instances[component][id]) {\n            return false;\n        }\n        return true;\n    };\n    Instances.prototype._generateRandomId = function () {\n        return Math.random().toString(36).substr(2, 9);\n    };\n    Instances.prototype._componentAndInstanceCheck = function (component, id) {\n        if (!this._instances[component]) {\n            console.warn(\"Flowbite: Component \".concat(component, \" does not exist.\"));\n            return false;\n        }\n        if (!this._instances[component][id]) {\n            console.warn(\"Flowbite: Instance with ID \".concat(id, \" does not exist.\"));\n            return false;\n        }\n        return true;\n    };\n    return Instances;\n}());\nvar instances = new Instances();\n/* harmony default export */ const dom_instances = (instances);\nif (typeof window !== 'undefined') {\n    window.FlowbiteInstances = instances;\n}\n//# sourceMappingURL=instances.js.map\n;// ./node_modules/flowbite/lib/esm/components/accordion/index.js\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\nvar Default = {\n    alwaysOpen: false,\n    activeClasses: 'bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white',\n    inactiveClasses: 'text-gray-500 dark:text-gray-400',\n    onOpen: function () { },\n    onClose: function () { },\n    onToggle: function () { },\n};\nvar DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Accordion = /** @class */ (function () {\n    function Accordion(accordionEl, items, options, instanceOptions) {\n        if (accordionEl === void 0) { accordionEl = null; }\n        if (items === void 0) { items = []; }\n        if (options === void 0) { options = Default; }\n        if (instanceOptions === void 0) { instanceOptions = DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : accordionEl.id;\n        this._accordionEl = accordionEl;\n        this._items = items;\n        this._options = __assign(__assign({}, Default), options);\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Accordion', this, this._instanceId, instanceOptions.override);\n    }\n    Accordion.prototype.init = function () {\n        var _this = this;\n        if (this._items.length && !this._initialized) {\n            // show accordion item based on click\n            this._items.forEach(function (item) {\n                if (item.active) {\n                    _this.open(item.id);\n                }\n                var clickHandler = function () {\n                    _this.toggle(item.id);\n                };\n                item.triggerEl.addEventListener('click', clickHandler);\n                // Store the clickHandler in a property of the item for removal later\n                item.clickHandler = clickHandler;\n            });\n            this._initialized = true;\n        }\n    };\n    Accordion.prototype.destroy = function () {\n        if (this._items.length && this._initialized) {\n            this._items.forEach(function (item) {\n                item.triggerEl.removeEventListener('click', item.clickHandler);\n                // Clean up by deleting the clickHandler property from the item\n                delete item.clickHandler;\n            });\n            this._initialized = false;\n        }\n    };\n    Accordion.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Accordion', this._instanceId);\n    };\n    Accordion.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Accordion.prototype.getItem = function (id) {\n        return this._items.filter(function (item) { return item.id === id; })[0];\n    };\n    Accordion.prototype.open = function (id) {\n        var _a, _b;\n        var _this = this;\n        var item = this.getItem(id);\n        // don't hide other accordions if always open\n        if (!this._options.alwaysOpen) {\n            this._items.map(function (i) {\n                var _a, _b;\n                if (i !== item) {\n                    (_a = i.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(' '));\n                    (_b = i.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(' '));\n                    i.targetEl.classList.add('hidden');\n                    i.triggerEl.setAttribute('aria-expanded', 'false');\n                    i.active = false;\n                    // rotate icon if set\n                    if (i.iconEl) {\n                        i.iconEl.classList.add('rotate-180');\n                    }\n                }\n            });\n        }\n        // show active item\n        (_a = item.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(' '));\n        (_b = item.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(' '));\n        item.triggerEl.setAttribute('aria-expanded', 'true');\n        item.targetEl.classList.remove('hidden');\n        item.active = true;\n        // rotate icon if set\n        if (item.iconEl) {\n            item.iconEl.classList.remove('rotate-180');\n        }\n        // callback function\n        this._options.onOpen(this, item);\n    };\n    Accordion.prototype.toggle = function (id) {\n        var item = this.getItem(id);\n        if (item.active) {\n            this.close(id);\n        }\n        else {\n            this.open(id);\n        }\n        // callback function\n        this._options.onToggle(this, item);\n    };\n    Accordion.prototype.close = function (id) {\n        var _a, _b;\n        var item = this.getItem(id);\n        (_a = item.triggerEl.classList).remove.apply(_a, this._options.activeClasses.split(' '));\n        (_b = item.triggerEl.classList).add.apply(_b, this._options.inactiveClasses.split(' '));\n        item.targetEl.classList.add('hidden');\n        item.triggerEl.setAttribute('aria-expanded', 'false');\n        item.active = false;\n        // rotate icon if set\n        if (item.iconEl) {\n            item.iconEl.classList.add('rotate-180');\n        }\n        // callback function\n        this._options.onClose(this, item);\n    };\n    Accordion.prototype.updateOnOpen = function (callback) {\n        this._options.onOpen = callback;\n    };\n    Accordion.prototype.updateOnClose = function (callback) {\n        this._options.onClose = callback;\n    };\n    Accordion.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Accordion;\n}());\nfunction initAccordions() {\n    document.querySelectorAll('[data-accordion]').forEach(function ($accordionEl) {\n        var alwaysOpen = $accordionEl.getAttribute('data-accordion');\n        var activeClasses = $accordionEl.getAttribute('data-active-classes');\n        var inactiveClasses = $accordionEl.getAttribute('data-inactive-classes');\n        var items = [];\n        $accordionEl\n            .querySelectorAll('[data-accordion-target]')\n            .forEach(function ($triggerEl) {\n            // Consider only items that directly belong to $accordionEl\n            // (to make nested accordions work).\n            if ($triggerEl.closest('[data-accordion]') === $accordionEl) {\n                var item = {\n                    id: $triggerEl.getAttribute('data-accordion-target'),\n                    triggerEl: $triggerEl,\n                    targetEl: document.querySelector($triggerEl.getAttribute('data-accordion-target')),\n                    iconEl: $triggerEl.querySelector('[data-accordion-icon]'),\n                    active: $triggerEl.getAttribute('aria-expanded') === 'true'\n                        ? true\n                        : false,\n                };\n                items.push(item);\n            }\n        });\n        new Accordion($accordionEl, items, {\n            alwaysOpen: alwaysOpen === 'open' ? true : false,\n            activeClasses: activeClasses\n                ? activeClasses\n                : Default.activeClasses,\n            inactiveClasses: inactiveClasses\n                ? inactiveClasses\n                : Default.inactiveClasses,\n        });\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Accordion = Accordion;\n    window.initAccordions = initAccordions;\n}\n/* harmony default export */ const accordion = ((/* unused pure expression or super */ null && (Accordion)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/collapse/index.js\nvar collapse_assign = (undefined && undefined.__assign) || function () {\n    collapse_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return collapse_assign.apply(this, arguments);\n};\n\nvar collapse_Default = {\n    onCollapse: function () { },\n    onExpand: function () { },\n    onToggle: function () { },\n};\nvar collapse_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Collapse = /** @class */ (function () {\n    function Collapse(targetEl, triggerEl, options, instanceOptions) {\n        if (targetEl === void 0) { targetEl = null; }\n        if (triggerEl === void 0) { triggerEl = null; }\n        if (options === void 0) { options = collapse_Default; }\n        if (instanceOptions === void 0) { instanceOptions = collapse_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._targetEl = targetEl;\n        this._triggerEl = triggerEl;\n        this._options = collapse_assign(collapse_assign({}, collapse_Default), options);\n        this._visible = false;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Collapse', this, this._instanceId, instanceOptions.override);\n    }\n    Collapse.prototype.init = function () {\n        var _this = this;\n        if (this._triggerEl && this._targetEl && !this._initialized) {\n            if (this._triggerEl.hasAttribute('aria-expanded')) {\n                this._visible =\n                    this._triggerEl.getAttribute('aria-expanded') === 'true';\n            }\n            else {\n                // fix until v2 not to break previous single collapses which became dismiss\n                this._visible = !this._targetEl.classList.contains('hidden');\n            }\n            this._clickHandler = function () {\n                _this.toggle();\n            };\n            this._triggerEl.addEventListener('click', this._clickHandler);\n            this._initialized = true;\n        }\n    };\n    Collapse.prototype.destroy = function () {\n        if (this._triggerEl && this._initialized) {\n            this._triggerEl.removeEventListener('click', this._clickHandler);\n            this._initialized = false;\n        }\n    };\n    Collapse.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Collapse', this._instanceId);\n    };\n    Collapse.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Collapse.prototype.collapse = function () {\n        this._targetEl.classList.add('hidden');\n        if (this._triggerEl) {\n            this._triggerEl.setAttribute('aria-expanded', 'false');\n        }\n        this._visible = false;\n        // callback function\n        this._options.onCollapse(this);\n    };\n    Collapse.prototype.expand = function () {\n        this._targetEl.classList.remove('hidden');\n        if (this._triggerEl) {\n            this._triggerEl.setAttribute('aria-expanded', 'true');\n        }\n        this._visible = true;\n        // callback function\n        this._options.onExpand(this);\n    };\n    Collapse.prototype.toggle = function () {\n        if (this._visible) {\n            this.collapse();\n        }\n        else {\n            this.expand();\n        }\n        // callback function\n        this._options.onToggle(this);\n    };\n    Collapse.prototype.updateOnCollapse = function (callback) {\n        this._options.onCollapse = callback;\n    };\n    Collapse.prototype.updateOnExpand = function (callback) {\n        this._options.onExpand = callback;\n    };\n    Collapse.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Collapse;\n}());\nfunction initCollapses() {\n    document\n        .querySelectorAll('[data-collapse-toggle]')\n        .forEach(function ($triggerEl) {\n        var targetId = $triggerEl.getAttribute('data-collapse-toggle');\n        var $targetEl = document.getElementById(targetId);\n        // check if the target element exists\n        if ($targetEl) {\n            if (!dom_instances.instanceExists('Collapse', $targetEl.getAttribute('id'))) {\n                new Collapse($targetEl, $triggerEl);\n            }\n            else {\n                // if instance exists already for the same target element then create a new one with a different trigger element\n                new Collapse($targetEl, $triggerEl, {}, {\n                    id: $targetEl.getAttribute('id') +\n                        '_' +\n                        dom_instances._generateRandomId(),\n                });\n            }\n        }\n        else {\n            console.error(\"The target element with id \\\"\".concat(targetId, \"\\\" does not exist. Please check the data-collapse-toggle attribute.\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Collapse = Collapse;\n    window.initCollapses = initCollapses;\n}\n/* harmony default export */ const collapse = ((/* unused pure expression or super */ null && (Collapse)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/carousel/index.js\nvar carousel_assign = (undefined && undefined.__assign) || function () {\n    carousel_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return carousel_assign.apply(this, arguments);\n};\n\nvar carousel_Default = {\n    defaultPosition: 0,\n    indicators: {\n        items: [],\n        activeClasses: 'bg-white dark:bg-gray-800',\n        inactiveClasses: 'bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800',\n    },\n    interval: 3000,\n    onNext: function () { },\n    onPrev: function () { },\n    onChange: function () { },\n};\nvar carousel_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Carousel = /** @class */ (function () {\n    function Carousel(carouselEl, items, options, instanceOptions) {\n        if (carouselEl === void 0) { carouselEl = null; }\n        if (items === void 0) { items = []; }\n        if (options === void 0) { options = carousel_Default; }\n        if (instanceOptions === void 0) { instanceOptions = carousel_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : carouselEl.id;\n        this._carouselEl = carouselEl;\n        this._items = items;\n        this._options = carousel_assign(carousel_assign(carousel_assign({}, carousel_Default), options), { indicators: carousel_assign(carousel_assign({}, carousel_Default.indicators), options.indicators) });\n        this._activeItem = this.getItem(this._options.defaultPosition);\n        this._indicators = this._options.indicators.items;\n        this._intervalDuration = this._options.interval;\n        this._intervalInstance = null;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Carousel', this, this._instanceId, instanceOptions.override);\n    }\n    /**\n     * initialize carousel and items based on active one\n     */\n    Carousel.prototype.init = function () {\n        var _this = this;\n        if (this._items.length && !this._initialized) {\n            this._items.map(function (item) {\n                item.el.classList.add('absolute', 'inset-0', 'transition-transform', 'transform');\n            });\n            // if no active item is set then first position is default\n            if (this.getActiveItem()) {\n                this.slideTo(this.getActiveItem().position);\n            }\n            else {\n                this.slideTo(0);\n            }\n            this._indicators.map(function (indicator, position) {\n                indicator.el.addEventListener('click', function () {\n                    _this.slideTo(position);\n                });\n            });\n            this._initialized = true;\n        }\n    };\n    Carousel.prototype.destroy = function () {\n        if (this._initialized) {\n            this._initialized = false;\n        }\n    };\n    Carousel.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Carousel', this._instanceId);\n    };\n    Carousel.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Carousel.prototype.getItem = function (position) {\n        return this._items[position];\n    };\n    /**\n     * Slide to the element based on id\n     * @param {*} position\n     */\n    Carousel.prototype.slideTo = function (position) {\n        var nextItem = this._items[position];\n        var rotationItems = {\n            left: nextItem.position === 0\n                ? this._items[this._items.length - 1]\n                : this._items[nextItem.position - 1],\n            middle: nextItem,\n            right: nextItem.position === this._items.length - 1\n                ? this._items[0]\n                : this._items[nextItem.position + 1],\n        };\n        this._rotate(rotationItems);\n        this._setActiveItem(nextItem);\n        if (this._intervalInstance) {\n            this.pause();\n            this.cycle();\n        }\n        this._options.onChange(this);\n    };\n    /**\n     * Based on the currently active item it will go to the next position\n     */\n    Carousel.prototype.next = function () {\n        var activeItem = this.getActiveItem();\n        var nextItem = null;\n        // check if last item\n        if (activeItem.position === this._items.length - 1) {\n            nextItem = this._items[0];\n        }\n        else {\n            nextItem = this._items[activeItem.position + 1];\n        }\n        this.slideTo(nextItem.position);\n        // callback function\n        this._options.onNext(this);\n    };\n    /**\n     * Based on the currently active item it will go to the previous position\n     */\n    Carousel.prototype.prev = function () {\n        var activeItem = this.getActiveItem();\n        var prevItem = null;\n        // check if first item\n        if (activeItem.position === 0) {\n            prevItem = this._items[this._items.length - 1];\n        }\n        else {\n            prevItem = this._items[activeItem.position - 1];\n        }\n        this.slideTo(prevItem.position);\n        // callback function\n        this._options.onPrev(this);\n    };\n    /**\n     * This method applies the transform classes based on the left, middle, and right rotation carousel items\n     * @param {*} rotationItems\n     */\n    Carousel.prototype._rotate = function (rotationItems) {\n        // reset\n        this._items.map(function (item) {\n            item.el.classList.add('hidden');\n        });\n        // Handling the case when there is only one item\n        if (this._items.length === 1) {\n            rotationItems.middle.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-10');\n            rotationItems.middle.el.classList.add('translate-x-0', 'z-20');\n            return;\n        }\n        // left item (previously active)\n        rotationItems.left.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-20');\n        rotationItems.left.el.classList.add('-translate-x-full', 'z-10');\n        // currently active item\n        rotationItems.middle.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-10');\n        rotationItems.middle.el.classList.add('translate-x-0', 'z-30');\n        // right item (upcoming active)\n        rotationItems.right.el.classList.remove('-translate-x-full', 'translate-x-full', 'translate-x-0', 'hidden', 'z-30');\n        rotationItems.right.el.classList.add('translate-x-full', 'z-20');\n    };\n    /**\n     * Set an interval to cycle through the carousel items\n     */\n    Carousel.prototype.cycle = function () {\n        var _this = this;\n        if (typeof window !== 'undefined') {\n            this._intervalInstance = window.setInterval(function () {\n                _this.next();\n            }, this._intervalDuration);\n        }\n    };\n    /**\n     * Clears the cycling interval\n     */\n    Carousel.prototype.pause = function () {\n        clearInterval(this._intervalInstance);\n    };\n    /**\n     * Get the currently active item\n     */\n    Carousel.prototype.getActiveItem = function () {\n        return this._activeItem;\n    };\n    /**\n     * Set the currently active item and data attribute\n     * @param {*} position\n     */\n    Carousel.prototype._setActiveItem = function (item) {\n        var _a, _b;\n        var _this = this;\n        this._activeItem = item;\n        var position = item.position;\n        // update the indicators if available\n        if (this._indicators.length) {\n            this._indicators.map(function (indicator) {\n                var _a, _b;\n                indicator.el.setAttribute('aria-current', 'false');\n                (_a = indicator.el.classList).remove.apply(_a, _this._options.indicators.activeClasses.split(' '));\n                (_b = indicator.el.classList).add.apply(_b, _this._options.indicators.inactiveClasses.split(' '));\n            });\n            (_a = this._indicators[position].el.classList).add.apply(_a, this._options.indicators.activeClasses.split(' '));\n            (_b = this._indicators[position].el.classList).remove.apply(_b, this._options.indicators.inactiveClasses.split(' '));\n            this._indicators[position].el.setAttribute('aria-current', 'true');\n        }\n    };\n    Carousel.prototype.updateOnNext = function (callback) {\n        this._options.onNext = callback;\n    };\n    Carousel.prototype.updateOnPrev = function (callback) {\n        this._options.onPrev = callback;\n    };\n    Carousel.prototype.updateOnChange = function (callback) {\n        this._options.onChange = callback;\n    };\n    return Carousel;\n}());\nfunction initCarousels() {\n    document.querySelectorAll('[data-carousel]').forEach(function ($carouselEl) {\n        var interval = $carouselEl.getAttribute('data-carousel-interval');\n        var slide = $carouselEl.getAttribute('data-carousel') === 'slide'\n            ? true\n            : false;\n        var items = [];\n        var defaultPosition = 0;\n        if ($carouselEl.querySelectorAll('[data-carousel-item]').length) {\n            Array.from($carouselEl.querySelectorAll('[data-carousel-item]')).map(function ($carouselItemEl, position) {\n                items.push({\n                    position: position,\n                    el: $carouselItemEl,\n                });\n                if ($carouselItemEl.getAttribute('data-carousel-item') ===\n                    'active') {\n                    defaultPosition = position;\n                }\n            });\n        }\n        var indicators = [];\n        if ($carouselEl.querySelectorAll('[data-carousel-slide-to]').length) {\n            Array.from($carouselEl.querySelectorAll('[data-carousel-slide-to]')).map(function ($indicatorEl) {\n                indicators.push({\n                    position: parseInt($indicatorEl.getAttribute('data-carousel-slide-to')),\n                    el: $indicatorEl,\n                });\n            });\n        }\n        var carousel = new Carousel($carouselEl, items, {\n            defaultPosition: defaultPosition,\n            indicators: {\n                items: indicators,\n            },\n            interval: interval ? interval : carousel_Default.interval,\n        });\n        if (slide) {\n            carousel.cycle();\n        }\n        // check for controls\n        var carouselNextEl = $carouselEl.querySelector('[data-carousel-next]');\n        var carouselPrevEl = $carouselEl.querySelector('[data-carousel-prev]');\n        if (carouselNextEl) {\n            carouselNextEl.addEventListener('click', function () {\n                carousel.next();\n            });\n        }\n        if (carouselPrevEl) {\n            carouselPrevEl.addEventListener('click', function () {\n                carousel.prev();\n            });\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Carousel = Carousel;\n    window.initCarousels = initCarousels;\n}\n/* harmony default export */ const carousel = ((/* unused pure expression or super */ null && (Carousel)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/dismiss/index.js\nvar dismiss_assign = (undefined && undefined.__assign) || function () {\n    dismiss_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return dismiss_assign.apply(this, arguments);\n};\n\nvar dismiss_Default = {\n    transition: 'transition-opacity',\n    duration: 300,\n    timing: 'ease-out',\n    onHide: function () { },\n};\nvar dismiss_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Dismiss = /** @class */ (function () {\n    function Dismiss(targetEl, triggerEl, options, instanceOptions) {\n        if (targetEl === void 0) { targetEl = null; }\n        if (triggerEl === void 0) { triggerEl = null; }\n        if (options === void 0) { options = dismiss_Default; }\n        if (instanceOptions === void 0) { instanceOptions = dismiss_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._targetEl = targetEl;\n        this._triggerEl = triggerEl;\n        this._options = dismiss_assign(dismiss_assign({}, dismiss_Default), options);\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Dismiss', this, this._instanceId, instanceOptions.override);\n    }\n    Dismiss.prototype.init = function () {\n        var _this = this;\n        if (this._triggerEl && this._targetEl && !this._initialized) {\n            this._clickHandler = function () {\n                _this.hide();\n            };\n            this._triggerEl.addEventListener('click', this._clickHandler);\n            this._initialized = true;\n        }\n    };\n    Dismiss.prototype.destroy = function () {\n        if (this._triggerEl && this._initialized) {\n            this._triggerEl.removeEventListener('click', this._clickHandler);\n            this._initialized = false;\n        }\n    };\n    Dismiss.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Dismiss', this._instanceId);\n    };\n    Dismiss.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Dismiss.prototype.hide = function () {\n        var _this = this;\n        this._targetEl.classList.add(this._options.transition, \"duration-\".concat(this._options.duration), this._options.timing, 'opacity-0');\n        setTimeout(function () {\n            _this._targetEl.classList.add('hidden');\n        }, this._options.duration);\n        // callback function\n        this._options.onHide(this, this._targetEl);\n    };\n    Dismiss.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    return Dismiss;\n}());\nfunction initDismisses() {\n    document.querySelectorAll('[data-dismiss-target]').forEach(function ($triggerEl) {\n        var targetId = $triggerEl.getAttribute('data-dismiss-target');\n        var $dismissEl = document.querySelector(targetId);\n        if ($dismissEl) {\n            new Dismiss($dismissEl, $triggerEl);\n        }\n        else {\n            console.error(\"The dismiss element with id \\\"\".concat(targetId, \"\\\" does not exist. Please check the data-dismiss-target attribute.\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Dismiss = Dismiss;\n    window.initDismisses = initDismisses;\n}\n/* harmony default export */ const dismiss = ((/* unused pure expression or super */ null && (Dismiss)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n\n;// ./node_modules/@popperjs/core/lib/utils/math.js\nvar math_max = Math.max;\nvar math_min = Math.min;\nvar round = Math.round;\n;// ./node_modules/@popperjs/core/lib/utils/userAgent.js\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\n\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\n\n\n\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n\nfunction getComputedStyle_getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle_getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n\n\n\n\n\n\n\n\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n\n\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle_getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle_getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle_getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle_getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle_getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n;// ./node_modules/@popperjs/core/lib/enums.js\nvar enums_top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [enums_top, bottom, right, left];\nvar enums_start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + enums_start, placement + \"-\" + end]);\n}, []);\nvar enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + enums_start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n;// ./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n;// ./node_modules/@popperjs/core/lib/utils/debounce.js\nfunction debounce_debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n;// ./node_modules/@popperjs/core/lib/utils/mergeByName.js\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n;// ./node_modules/@popperjs/core/lib/createPopper.js\n\n\n\n\n\n\n\n\n\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce_debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/(/* unused pure expression or super */ null && (popperGenerator())); // eslint-disable-next-line import/no-unused-modules\n\n\n;// ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction eventListeners_effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const eventListeners = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: eventListeners_effect,\n  data: {}\n});\n;// ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n;// ./node_modules/@popperjs/core/lib/utils/getVariation.js\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n;// ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n;// ./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case enums_top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case enums_start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}\n;// ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_popperOffsets = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});\n;// ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = enums_top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle_getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === enums_top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, getWindow(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_computeStyles = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});\n;// ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction applyStyles_effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_applyStyles = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: applyStyles_effect,\n  requires: ['computeStyles']\n});\n;// ./node_modules/@popperjs/core/lib/modifiers/offset.js\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = enums_placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_offset = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n});\n;// ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n;// ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\nvar getOppositeVariationPlacement_hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return getOppositeVariationPlacement_hash[matched];\n  });\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n\n\n\n\nfunction getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle_getComputedStyle(body || html).direction === 'rtl') {\n    x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/contains.js\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n;// ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n;// ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle_getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = math_max(rect.top, accRect.top);\n    accRect.right = math_min(rect.right, accRect.right);\n    accRect.bottom = math_min(rect.bottom, accRect.bottom);\n    accRect.left = math_max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n;// ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n;// ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\n;// ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n;// ./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n;// ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n;// ./node_modules/@popperjs/core/lib/modifiers/flip.js\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === enums_start;\n    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_flip = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});\n;// ./node_modules/@popperjs/core/lib/utils/getAltAxis.js\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n;// ./node_modules/@popperjs/core/lib/utils/within.js\n\nfunction within(min, value, max) {\n  return math_max(min, math_min(value, max));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}\n;// ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? enums_top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === enums_start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === enums_start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? enums_top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [enums_top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_preventOverflow = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});\n;// ./node_modules/@popperjs/core/lib/modifiers/arrow.js\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? enums_top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction arrow_effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_arrow = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: arrow_effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});\n;// ./node_modules/@popperjs/core/lib/modifiers/hide.js\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [enums_top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ const modifiers_hide = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n});\n;// ./node_modules/@popperjs/core/lib/popper.js\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];\nvar popper_createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n\n;// ./node_modules/flowbite/lib/esm/components/dropdown/index.js\nvar dropdown_assign = (undefined && undefined.__assign) || function () {\n    dropdown_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return dropdown_assign.apply(this, arguments);\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/* eslint-disable @typescript-eslint/no-empty-function */\n\n\nvar dropdown_Default = {\n    placement: 'bottom',\n    triggerType: 'click',\n    offsetSkidding: 0,\n    offsetDistance: 10,\n    delay: 300,\n    ignoreClickOutsideClass: false,\n    onShow: function () { },\n    onHide: function () { },\n    onToggle: function () { },\n};\nvar dropdown_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Dropdown = /** @class */ (function () {\n    function Dropdown(targetElement, triggerElement, options, instanceOptions) {\n        if (targetElement === void 0) { targetElement = null; }\n        if (triggerElement === void 0) { triggerElement = null; }\n        if (options === void 0) { options = dropdown_Default; }\n        if (instanceOptions === void 0) { instanceOptions = dropdown_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetElement.id;\n        this._targetEl = targetElement;\n        this._triggerEl = triggerElement;\n        this._options = dropdown_assign(dropdown_assign({}, dropdown_Default), options);\n        this._popperInstance = null;\n        this._visible = false;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Dropdown', this, this._instanceId, instanceOptions.override);\n    }\n    Dropdown.prototype.init = function () {\n        if (this._triggerEl && this._targetEl && !this._initialized) {\n            this._popperInstance = this._createPopperInstance();\n            this._setupEventListeners();\n            this._initialized = true;\n        }\n    };\n    Dropdown.prototype.destroy = function () {\n        var _this = this;\n        var triggerEvents = this._getTriggerEvents();\n        // Remove click event listeners for trigger element\n        if (this._options.triggerType === 'click') {\n            triggerEvents.showEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._clickHandler);\n            });\n        }\n        // Remove hover event listeners for trigger and target elements\n        if (this._options.triggerType === 'hover') {\n            triggerEvents.showEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);\n                _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);\n            });\n            triggerEvents.hideEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);\n                _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);\n            });\n        }\n        this._popperInstance.destroy();\n        this._initialized = false;\n    };\n    Dropdown.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Dropdown', this._instanceId);\n    };\n    Dropdown.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Dropdown.prototype._setupEventListeners = function () {\n        var _this = this;\n        var triggerEvents = this._getTriggerEvents();\n        this._clickHandler = function () {\n            _this.toggle();\n        };\n        // click event handling for trigger element\n        if (this._options.triggerType === 'click') {\n            triggerEvents.showEvents.forEach(function (ev) {\n                _this._triggerEl.addEventListener(ev, _this._clickHandler);\n            });\n        }\n        this._hoverShowTriggerElHandler = function (ev) {\n            if (ev.type === 'click') {\n                _this.toggle();\n            }\n            else {\n                setTimeout(function () {\n                    _this.show();\n                }, _this._options.delay);\n            }\n        };\n        this._hoverShowTargetElHandler = function () {\n            _this.show();\n        };\n        this._hoverHideHandler = function () {\n            setTimeout(function () {\n                if (!_this._targetEl.matches(':hover')) {\n                    _this.hide();\n                }\n            }, _this._options.delay);\n        };\n        // hover event handling for trigger element\n        if (this._options.triggerType === 'hover') {\n            triggerEvents.showEvents.forEach(function (ev) {\n                _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);\n                _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);\n            });\n            triggerEvents.hideEvents.forEach(function (ev) {\n                _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);\n                _this._targetEl.addEventListener(ev, _this._hoverHideHandler);\n            });\n        }\n    };\n    Dropdown.prototype._createPopperInstance = function () {\n        return popper_createPopper(this._triggerEl, this._targetEl, {\n            placement: this._options.placement,\n            modifiers: [\n                {\n                    name: 'offset',\n                    options: {\n                        offset: [\n                            this._options.offsetSkidding,\n                            this._options.offsetDistance,\n                        ],\n                    },\n                },\n            ],\n        });\n    };\n    Dropdown.prototype._setupClickOutsideListener = function () {\n        var _this = this;\n        this._clickOutsideEventListener = function (ev) {\n            _this._handleClickOutside(ev, _this._targetEl);\n        };\n        document.body.addEventListener('click', this._clickOutsideEventListener, true);\n    };\n    Dropdown.prototype._removeClickOutsideListener = function () {\n        document.body.removeEventListener('click', this._clickOutsideEventListener, true);\n    };\n    Dropdown.prototype._handleClickOutside = function (ev, targetEl) {\n        var clickedEl = ev.target;\n        // Ignore clicks on the trigger element (ie. a datepicker input)\n        var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;\n        var isIgnored = false;\n        if (ignoreClickOutsideClass) {\n            var ignoredClickOutsideEls = document.querySelectorAll(\".\".concat(ignoreClickOutsideClass));\n            ignoredClickOutsideEls.forEach(function (el) {\n                if (el.contains(clickedEl)) {\n                    isIgnored = true;\n                    return;\n                }\n            });\n        }\n        // Ignore clicks on the target element (ie. dropdown itself)\n        if (clickedEl !== targetEl &&\n            !targetEl.contains(clickedEl) &&\n            !this._triggerEl.contains(clickedEl) &&\n            !isIgnored &&\n            this.isVisible()) {\n            this.hide();\n        }\n    };\n    Dropdown.prototype._getTriggerEvents = function () {\n        switch (this._options.triggerType) {\n            case 'hover':\n                return {\n                    showEvents: ['mouseenter', 'click'],\n                    hideEvents: ['mouseleave'],\n                };\n            case 'click':\n                return {\n                    showEvents: ['click'],\n                    hideEvents: [],\n                };\n            case 'none':\n                return {\n                    showEvents: [],\n                    hideEvents: [],\n                };\n            default:\n                return {\n                    showEvents: ['click'],\n                    hideEvents: [],\n                };\n        }\n    };\n    Dropdown.prototype.toggle = function () {\n        if (this.isVisible()) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n        this._options.onToggle(this);\n    };\n    Dropdown.prototype.isVisible = function () {\n        return this._visible;\n    };\n    Dropdown.prototype.show = function () {\n        this._targetEl.classList.remove('hidden');\n        this._targetEl.classList.add('block');\n        this._targetEl.removeAttribute('aria-hidden');\n        // Enable the event listeners\n        this._popperInstance.setOptions(function (options) { return (dropdown_assign(dropdown_assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [\n                { name: 'eventListeners', enabled: true },\n            ], false) })); });\n        this._setupClickOutsideListener();\n        // Update its position\n        this._popperInstance.update();\n        this._visible = true;\n        // callback function\n        this._options.onShow(this);\n    };\n    Dropdown.prototype.hide = function () {\n        this._targetEl.classList.remove('block');\n        this._targetEl.classList.add('hidden');\n        this._targetEl.setAttribute('aria-hidden', 'true');\n        // Disable the event listeners\n        this._popperInstance.setOptions(function (options) { return (dropdown_assign(dropdown_assign({}, options), { modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [\n                { name: 'eventListeners', enabled: false },\n            ], false) })); });\n        this._visible = false;\n        this._removeClickOutsideListener();\n        // callback function\n        this._options.onHide(this);\n    };\n    Dropdown.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    Dropdown.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    Dropdown.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Dropdown;\n}());\nfunction initDropdowns() {\n    document\n        .querySelectorAll('[data-dropdown-toggle]')\n        .forEach(function ($triggerEl) {\n        var dropdownId = $triggerEl.getAttribute('data-dropdown-toggle');\n        var $dropdownEl = document.getElementById(dropdownId);\n        if ($dropdownEl) {\n            var placement = $triggerEl.getAttribute('data-dropdown-placement');\n            var offsetSkidding = $triggerEl.getAttribute('data-dropdown-offset-skidding');\n            var offsetDistance = $triggerEl.getAttribute('data-dropdown-offset-distance');\n            var triggerType = $triggerEl.getAttribute('data-dropdown-trigger');\n            var delay = $triggerEl.getAttribute('data-dropdown-delay');\n            var ignoreClickOutsideClass = $triggerEl.getAttribute('data-dropdown-ignore-click-outside-class');\n            new Dropdown($dropdownEl, $triggerEl, {\n                placement: placement ? placement : dropdown_Default.placement,\n                triggerType: triggerType\n                    ? triggerType\n                    : dropdown_Default.triggerType,\n                offsetSkidding: offsetSkidding\n                    ? parseInt(offsetSkidding)\n                    : dropdown_Default.offsetSkidding,\n                offsetDistance: offsetDistance\n                    ? parseInt(offsetDistance)\n                    : dropdown_Default.offsetDistance,\n                delay: delay ? parseInt(delay) : dropdown_Default.delay,\n                ignoreClickOutsideClass: ignoreClickOutsideClass\n                    ? ignoreClickOutsideClass\n                    : dropdown_Default.ignoreClickOutsideClass,\n            });\n        }\n        else {\n            console.error(\"The dropdown element with id \\\"\".concat(dropdownId, \"\\\" does not exist. Please check the data-dropdown-toggle attribute.\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Dropdown = Dropdown;\n    window.initDropdowns = initDropdowns;\n}\n/* harmony default export */ const dropdown = ((/* unused pure expression or super */ null && (Dropdown)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/modal/index.js\nvar modal_assign = (undefined && undefined.__assign) || function () {\n    modal_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return modal_assign.apply(this, arguments);\n};\n\nvar modal_Default = {\n    placement: 'center',\n    backdropClasses: 'bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40',\n    backdrop: 'dynamic',\n    closable: true,\n    onHide: function () { },\n    onShow: function () { },\n    onToggle: function () { },\n};\nvar modal_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Modal = /** @class */ (function () {\n    function Modal(targetEl, options, instanceOptions) {\n        if (targetEl === void 0) { targetEl = null; }\n        if (options === void 0) { options = modal_Default; }\n        if (instanceOptions === void 0) { instanceOptions = modal_DefaultInstanceOptions; }\n        this._eventListenerInstances = [];\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._targetEl = targetEl;\n        this._options = modal_assign(modal_assign({}, modal_Default), options);\n        this._isHidden = true;\n        this._backdropEl = null;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Modal', this, this._instanceId, instanceOptions.override);\n    }\n    Modal.prototype.init = function () {\n        var _this = this;\n        if (this._targetEl && !this._initialized) {\n            this._getPlacementClasses().map(function (c) {\n                _this._targetEl.classList.add(c);\n            });\n            this._initialized = true;\n        }\n    };\n    Modal.prototype.destroy = function () {\n        if (this._initialized) {\n            this.removeAllEventListenerInstances();\n            this._destroyBackdropEl();\n            this._initialized = false;\n        }\n    };\n    Modal.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Modal', this._instanceId);\n    };\n    Modal.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Modal.prototype._createBackdrop = function () {\n        var _a;\n        if (this._isHidden) {\n            var backdropEl = document.createElement('div');\n            (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(' '));\n            document.querySelector('body').append(backdropEl);\n            this._backdropEl = backdropEl;\n        }\n    };\n    Modal.prototype._destroyBackdropEl = function () {\n        if (!this._isHidden && this._backdropEl) {\n            this._backdropEl.remove();\n            this._backdropEl = null;\n        }\n    };\n    Modal.prototype._setupModalCloseEventListeners = function () {\n        var _this = this;\n        if (this._options.backdrop === 'dynamic') {\n            this._clickOutsideEventListener = function (ev) {\n                _this._handleOutsideClick(ev.target);\n            };\n            this._targetEl.addEventListener('click', this._clickOutsideEventListener, true);\n        }\n        this._keydownEventListener = function (ev) {\n            if (ev.key === 'Escape') {\n                _this.hide();\n            }\n        };\n        document.body.addEventListener('keydown', this._keydownEventListener, true);\n    };\n    Modal.prototype._removeModalCloseEventListeners = function () {\n        if (this._options.backdrop === 'dynamic') {\n            this._targetEl.removeEventListener('click', this._clickOutsideEventListener, true);\n        }\n        document.body.removeEventListener('keydown', this._keydownEventListener, true);\n    };\n    Modal.prototype._handleOutsideClick = function (target) {\n        if (target === this._targetEl ||\n            (target === this._backdropEl && this.isVisible())) {\n            this.hide();\n        }\n    };\n    Modal.prototype._getPlacementClasses = function () {\n        switch (this._options.placement) {\n            // top\n            case 'top-left':\n                return ['justify-start', 'items-start'];\n            case 'top-center':\n                return ['justify-center', 'items-start'];\n            case 'top-right':\n                return ['justify-end', 'items-start'];\n            // center\n            case 'center-left':\n                return ['justify-start', 'items-center'];\n            case 'center':\n                return ['justify-center', 'items-center'];\n            case 'center-right':\n                return ['justify-end', 'items-center'];\n            // bottom\n            case 'bottom-left':\n                return ['justify-start', 'items-end'];\n            case 'bottom-center':\n                return ['justify-center', 'items-end'];\n            case 'bottom-right':\n                return ['justify-end', 'items-end'];\n            default:\n                return ['justify-center', 'items-center'];\n        }\n    };\n    Modal.prototype.toggle = function () {\n        if (this._isHidden) {\n            this.show();\n        }\n        else {\n            this.hide();\n        }\n        // callback function\n        this._options.onToggle(this);\n    };\n    Modal.prototype.show = function () {\n        if (this.isHidden) {\n            this._targetEl.classList.add('flex');\n            this._targetEl.classList.remove('hidden');\n            this._targetEl.setAttribute('aria-modal', 'true');\n            this._targetEl.setAttribute('role', 'dialog');\n            this._targetEl.removeAttribute('aria-hidden');\n            this._createBackdrop();\n            this._isHidden = false;\n            // Add keyboard event listener to the document\n            if (this._options.closable) {\n                this._setupModalCloseEventListeners();\n            }\n            // prevent body scroll\n            document.body.classList.add('overflow-hidden');\n            // callback function\n            this._options.onShow(this);\n        }\n    };\n    Modal.prototype.hide = function () {\n        if (this.isVisible) {\n            this._targetEl.classList.add('hidden');\n            this._targetEl.classList.remove('flex');\n            this._targetEl.setAttribute('aria-hidden', 'true');\n            this._targetEl.removeAttribute('aria-modal');\n            this._targetEl.removeAttribute('role');\n            this._destroyBackdropEl();\n            this._isHidden = true;\n            // re-apply body scroll\n            document.body.classList.remove('overflow-hidden');\n            if (this._options.closable) {\n                this._removeModalCloseEventListeners();\n            }\n            // callback function\n            this._options.onHide(this);\n        }\n    };\n    Modal.prototype.isVisible = function () {\n        return !this._isHidden;\n    };\n    Modal.prototype.isHidden = function () {\n        return this._isHidden;\n    };\n    Modal.prototype.addEventListenerInstance = function (element, type, handler) {\n        this._eventListenerInstances.push({\n            element: element,\n            type: type,\n            handler: handler,\n        });\n    };\n    Modal.prototype.removeAllEventListenerInstances = function () {\n        this._eventListenerInstances.map(function (eventListenerInstance) {\n            eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);\n        });\n        this._eventListenerInstances = [];\n    };\n    Modal.prototype.getAllEventListenerInstances = function () {\n        return this._eventListenerInstances;\n    };\n    Modal.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    Modal.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    Modal.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Modal;\n}());\nfunction initModals() {\n    // initiate modal based on data-modal-target\n    document.querySelectorAll('[data-modal-target]').forEach(function ($triggerEl) {\n        var modalId = $triggerEl.getAttribute('data-modal-target');\n        var $modalEl = document.getElementById(modalId);\n        if ($modalEl) {\n            var placement = $modalEl.getAttribute('data-modal-placement');\n            var backdrop = $modalEl.getAttribute('data-modal-backdrop');\n            new Modal($modalEl, {\n                placement: placement ? placement : modal_Default.placement,\n                backdrop: backdrop ? backdrop : modal_Default.backdrop,\n            });\n        }\n        else {\n            console.error(\"Modal with id \".concat(modalId, \" does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?.\"));\n        }\n    });\n    // toggle modal visibility\n    document.querySelectorAll('[data-modal-toggle]').forEach(function ($triggerEl) {\n        var modalId = $triggerEl.getAttribute('data-modal-toggle');\n        var $modalEl = document.getElementById(modalId);\n        if ($modalEl) {\n            var modal_1 = dom_instances.getInstance('Modal', modalId);\n            if (modal_1) {\n                var toggleModal = function () {\n                    modal_1.toggle();\n                };\n                $triggerEl.addEventListener('click', toggleModal);\n                modal_1.addEventListenerInstance($triggerEl, 'click', toggleModal);\n            }\n            else {\n                console.error(\"Modal with id \".concat(modalId, \" has not been initialized. Please initialize it using the data-modal-target attribute.\"));\n            }\n        }\n        else {\n            console.error(\"Modal with id \".concat(modalId, \" does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?\"));\n        }\n    });\n    // show modal on click if exists based on id\n    document.querySelectorAll('[data-modal-show]').forEach(function ($triggerEl) {\n        var modalId = $triggerEl.getAttribute('data-modal-show');\n        var $modalEl = document.getElementById(modalId);\n        if ($modalEl) {\n            var modal_2 = dom_instances.getInstance('Modal', modalId);\n            if (modal_2) {\n                var showModal = function () {\n                    modal_2.show();\n                };\n                $triggerEl.addEventListener('click', showModal);\n                modal_2.addEventListenerInstance($triggerEl, 'click', showModal);\n            }\n            else {\n                console.error(\"Modal with id \".concat(modalId, \" has not been initialized. Please initialize it using the data-modal-target attribute.\"));\n            }\n        }\n        else {\n            console.error(\"Modal with id \".concat(modalId, \" does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?\"));\n        }\n    });\n    // hide modal on click if exists based on id\n    document.querySelectorAll('[data-modal-hide]').forEach(function ($triggerEl) {\n        var modalId = $triggerEl.getAttribute('data-modal-hide');\n        var $modalEl = document.getElementById(modalId);\n        if ($modalEl) {\n            var modal_3 = dom_instances.getInstance('Modal', modalId);\n            if (modal_3) {\n                var hideModal = function () {\n                    modal_3.hide();\n                };\n                $triggerEl.addEventListener('click', hideModal);\n                modal_3.addEventListenerInstance($triggerEl, 'click', hideModal);\n            }\n            else {\n                console.error(\"Modal with id \".concat(modalId, \" has not been initialized. Please initialize it using the data-modal-target attribute.\"));\n            }\n        }\n        else {\n            console.error(\"Modal with id \".concat(modalId, \" does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Modal = Modal;\n    window.initModals = initModals;\n}\n/* harmony default export */ const modal = ((/* unused pure expression or super */ null && (Modal)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/drawer/index.js\nvar drawer_assign = (undefined && undefined.__assign) || function () {\n    drawer_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return drawer_assign.apply(this, arguments);\n};\n\nvar drawer_Default = {\n    placement: 'left',\n    bodyScrolling: false,\n    backdrop: true,\n    edge: false,\n    edgeOffset: 'bottom-[60px]',\n    backdropClasses: 'bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30',\n    onShow: function () { },\n    onHide: function () { },\n    onToggle: function () { },\n};\nvar drawer_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Drawer = /** @class */ (function () {\n    function Drawer(targetEl, options, instanceOptions) {\n        if (targetEl === void 0) { targetEl = null; }\n        if (options === void 0) { options = drawer_Default; }\n        if (instanceOptions === void 0) { instanceOptions = drawer_DefaultInstanceOptions; }\n        this._eventListenerInstances = [];\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._targetEl = targetEl;\n        this._options = drawer_assign(drawer_assign({}, drawer_Default), options);\n        this._visible = false;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Drawer', this, this._instanceId, instanceOptions.override);\n    }\n    Drawer.prototype.init = function () {\n        var _this = this;\n        // set initial accessibility attributes\n        if (this._targetEl && !this._initialized) {\n            this._targetEl.setAttribute('aria-hidden', 'true');\n            this._targetEl.classList.add('transition-transform');\n            // set base placement classes\n            this._getPlacementClasses(this._options.placement).base.map(function (c) {\n                _this._targetEl.classList.add(c);\n            });\n            this._handleEscapeKey = function (event) {\n                if (event.key === 'Escape') {\n                    // if 'Escape' key is pressed\n                    if (_this.isVisible()) {\n                        // if the Drawer is visible\n                        _this.hide(); // hide the Drawer\n                    }\n                }\n            };\n            // add keyboard event listener to document\n            document.addEventListener('keydown', this._handleEscapeKey);\n            this._initialized = true;\n        }\n    };\n    Drawer.prototype.destroy = function () {\n        if (this._initialized) {\n            this.removeAllEventListenerInstances();\n            this._destroyBackdropEl();\n            // Remove the keyboard event listener\n            document.removeEventListener('keydown', this._handleEscapeKey);\n            this._initialized = false;\n        }\n    };\n    Drawer.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Drawer', this._instanceId);\n    };\n    Drawer.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Drawer.prototype.hide = function () {\n        var _this = this;\n        // based on the edge option show placement classes\n        if (this._options.edge) {\n            this._getPlacementClasses(this._options.placement + '-edge').active.map(function (c) {\n                _this._targetEl.classList.remove(c);\n            });\n            this._getPlacementClasses(this._options.placement + '-edge').inactive.map(function (c) {\n                _this._targetEl.classList.add(c);\n            });\n        }\n        else {\n            this._getPlacementClasses(this._options.placement).active.map(function (c) {\n                _this._targetEl.classList.remove(c);\n            });\n            this._getPlacementClasses(this._options.placement).inactive.map(function (c) {\n                _this._targetEl.classList.add(c);\n            });\n        }\n        // set accessibility attributes\n        this._targetEl.setAttribute('aria-hidden', 'true');\n        this._targetEl.removeAttribute('aria-modal');\n        this._targetEl.removeAttribute('role');\n        // enable body scroll\n        if (!this._options.bodyScrolling) {\n            document.body.classList.remove('overflow-hidden');\n        }\n        // destroy backdrop\n        if (this._options.backdrop) {\n            this._destroyBackdropEl();\n        }\n        this._visible = false;\n        // callback function\n        this._options.onHide(this);\n    };\n    Drawer.prototype.show = function () {\n        var _this = this;\n        if (this._options.edge) {\n            this._getPlacementClasses(this._options.placement + '-edge').active.map(function (c) {\n                _this._targetEl.classList.add(c);\n            });\n            this._getPlacementClasses(this._options.placement + '-edge').inactive.map(function (c) {\n                _this._targetEl.classList.remove(c);\n            });\n        }\n        else {\n            this._getPlacementClasses(this._options.placement).active.map(function (c) {\n                _this._targetEl.classList.add(c);\n            });\n            this._getPlacementClasses(this._options.placement).inactive.map(function (c) {\n                _this._targetEl.classList.remove(c);\n            });\n        }\n        // set accessibility attributes\n        this._targetEl.setAttribute('aria-modal', 'true');\n        this._targetEl.setAttribute('role', 'dialog');\n        this._targetEl.removeAttribute('aria-hidden');\n        // disable body scroll\n        if (!this._options.bodyScrolling) {\n            document.body.classList.add('overflow-hidden');\n        }\n        // show backdrop\n        if (this._options.backdrop) {\n            this._createBackdrop();\n        }\n        this._visible = true;\n        // callback function\n        this._options.onShow(this);\n    };\n    Drawer.prototype.toggle = function () {\n        if (this.isVisible()) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    };\n    Drawer.prototype._createBackdrop = function () {\n        var _a;\n        var _this = this;\n        if (!this._visible) {\n            var backdropEl = document.createElement('div');\n            backdropEl.setAttribute('drawer-backdrop', '');\n            (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(' '));\n            document.querySelector('body').append(backdropEl);\n            backdropEl.addEventListener('click', function () {\n                _this.hide();\n            });\n        }\n    };\n    Drawer.prototype._destroyBackdropEl = function () {\n        if (this._visible &&\n            document.querySelector('[drawer-backdrop]') !== null) {\n            document.querySelector('[drawer-backdrop]').remove();\n        }\n    };\n    Drawer.prototype._getPlacementClasses = function (placement) {\n        switch (placement) {\n            case 'top':\n                return {\n                    base: ['top-0', 'left-0', 'right-0'],\n                    active: ['transform-none'],\n                    inactive: ['-translate-y-full'],\n                };\n            case 'right':\n                return {\n                    base: ['right-0', 'top-0'],\n                    active: ['transform-none'],\n                    inactive: ['translate-x-full'],\n                };\n            case 'bottom':\n                return {\n                    base: ['bottom-0', 'left-0', 'right-0'],\n                    active: ['transform-none'],\n                    inactive: ['translate-y-full'],\n                };\n            case 'left':\n                return {\n                    base: ['left-0', 'top-0'],\n                    active: ['transform-none'],\n                    inactive: ['-translate-x-full'],\n                };\n            case 'bottom-edge':\n                return {\n                    base: ['left-0', 'top-0'],\n                    active: ['transform-none'],\n                    inactive: ['translate-y-full', this._options.edgeOffset],\n                };\n            default:\n                return {\n                    base: ['left-0', 'top-0'],\n                    active: ['transform-none'],\n                    inactive: ['-translate-x-full'],\n                };\n        }\n    };\n    Drawer.prototype.isHidden = function () {\n        return !this._visible;\n    };\n    Drawer.prototype.isVisible = function () {\n        return this._visible;\n    };\n    Drawer.prototype.addEventListenerInstance = function (element, type, handler) {\n        this._eventListenerInstances.push({\n            element: element,\n            type: type,\n            handler: handler,\n        });\n    };\n    Drawer.prototype.removeAllEventListenerInstances = function () {\n        this._eventListenerInstances.map(function (eventListenerInstance) {\n            eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);\n        });\n        this._eventListenerInstances = [];\n    };\n    Drawer.prototype.getAllEventListenerInstances = function () {\n        return this._eventListenerInstances;\n    };\n    Drawer.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    Drawer.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    Drawer.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Drawer;\n}());\nfunction initDrawers() {\n    document.querySelectorAll('[data-drawer-target]').forEach(function ($triggerEl) {\n        // mandatory\n        var drawerId = $triggerEl.getAttribute('data-drawer-target');\n        var $drawerEl = document.getElementById(drawerId);\n        if ($drawerEl) {\n            var placement = $triggerEl.getAttribute('data-drawer-placement');\n            var bodyScrolling = $triggerEl.getAttribute('data-drawer-body-scrolling');\n            var backdrop = $triggerEl.getAttribute('data-drawer-backdrop');\n            var edge = $triggerEl.getAttribute('data-drawer-edge');\n            var edgeOffset = $triggerEl.getAttribute('data-drawer-edge-offset');\n            new Drawer($drawerEl, {\n                placement: placement ? placement : drawer_Default.placement,\n                bodyScrolling: bodyScrolling\n                    ? bodyScrolling === 'true'\n                        ? true\n                        : false\n                    : drawer_Default.bodyScrolling,\n                backdrop: backdrop\n                    ? backdrop === 'true'\n                        ? true\n                        : false\n                    : drawer_Default.backdrop,\n                edge: edge ? (edge === 'true' ? true : false) : drawer_Default.edge,\n                edgeOffset: edgeOffset ? edgeOffset : drawer_Default.edgeOffset,\n            });\n        }\n        else {\n            console.error(\"Drawer with id \".concat(drawerId, \" not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?\"));\n        }\n    });\n    document.querySelectorAll('[data-drawer-toggle]').forEach(function ($triggerEl) {\n        var drawerId = $triggerEl.getAttribute('data-drawer-toggle');\n        var $drawerEl = document.getElementById(drawerId);\n        if ($drawerEl) {\n            var drawer_1 = dom_instances.getInstance('Drawer', drawerId);\n            if (drawer_1) {\n                var toggleDrawer = function () {\n                    drawer_1.toggle();\n                };\n                $triggerEl.addEventListener('click', toggleDrawer);\n                drawer_1.addEventListenerInstance($triggerEl, 'click', toggleDrawer);\n            }\n            else {\n                console.error(\"Drawer with id \".concat(drawerId, \" has not been initialized. Please initialize it using the data-drawer-target attribute.\"));\n            }\n        }\n        else {\n            console.error(\"Drawer with id \".concat(drawerId, \" not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?\"));\n        }\n    });\n    document\n        .querySelectorAll('[data-drawer-dismiss], [data-drawer-hide]')\n        .forEach(function ($triggerEl) {\n        var drawerId = $triggerEl.getAttribute('data-drawer-dismiss')\n            ? $triggerEl.getAttribute('data-drawer-dismiss')\n            : $triggerEl.getAttribute('data-drawer-hide');\n        var $drawerEl = document.getElementById(drawerId);\n        if ($drawerEl) {\n            var drawer_2 = dom_instances.getInstance('Drawer', drawerId);\n            if (drawer_2) {\n                var hideDrawer = function () {\n                    drawer_2.hide();\n                };\n                $triggerEl.addEventListener('click', hideDrawer);\n                drawer_2.addEventListenerInstance($triggerEl, 'click', hideDrawer);\n            }\n            else {\n                console.error(\"Drawer with id \".concat(drawerId, \" has not been initialized. Please initialize it using the data-drawer-target attribute.\"));\n            }\n        }\n        else {\n            console.error(\"Drawer with id \".concat(drawerId, \" not found. Are you sure that the data-drawer-target attribute points to the correct drawer id\"));\n        }\n    });\n    document.querySelectorAll('[data-drawer-show]').forEach(function ($triggerEl) {\n        var drawerId = $triggerEl.getAttribute('data-drawer-show');\n        var $drawerEl = document.getElementById(drawerId);\n        if ($drawerEl) {\n            var drawer_3 = dom_instances.getInstance('Drawer', drawerId);\n            if (drawer_3) {\n                var showDrawer = function () {\n                    drawer_3.show();\n                };\n                $triggerEl.addEventListener('click', showDrawer);\n                drawer_3.addEventListenerInstance($triggerEl, 'click', showDrawer);\n            }\n            else {\n                console.error(\"Drawer with id \".concat(drawerId, \" has not been initialized. Please initialize it using the data-drawer-target attribute.\"));\n            }\n        }\n        else {\n            console.error(\"Drawer with id \".concat(drawerId, \" not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Drawer = Drawer;\n    window.initDrawers = initDrawers;\n}\n/* harmony default export */ const drawer = ((/* unused pure expression or super */ null && (Drawer)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/tabs/index.js\nvar tabs_assign = (undefined && undefined.__assign) || function () {\n    tabs_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return tabs_assign.apply(this, arguments);\n};\n\nvar tabs_Default = {\n    defaultTabId: null,\n    activeClasses: 'text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500',\n    inactiveClasses: 'dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300',\n    onShow: function () { },\n};\nvar tabs_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Tabs = /** @class */ (function () {\n    function Tabs(tabsEl, items, options, instanceOptions) {\n        if (tabsEl === void 0) { tabsEl = null; }\n        if (items === void 0) { items = []; }\n        if (options === void 0) { options = tabs_Default; }\n        if (instanceOptions === void 0) { instanceOptions = tabs_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;\n        this._tabsEl = tabsEl;\n        this._items = items;\n        this._activeTab = options ? this.getTab(options.defaultTabId) : null;\n        this._options = tabs_assign(tabs_assign({}, tabs_Default), options);\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Tabs', this, this._instanceId, instanceOptions.override);\n    }\n    Tabs.prototype.init = function () {\n        var _this = this;\n        if (this._items.length && !this._initialized) {\n            // set the first tab as active if not set by explicitly\n            if (!this._activeTab) {\n                this.setActiveTab(this._items[0]);\n            }\n            // force show the first default tab\n            this.show(this._activeTab.id, true);\n            // show tab content based on click\n            this._items.map(function (tab) {\n                tab.triggerEl.addEventListener('click', function (event) {\n                    event.preventDefault();\n                    _this.show(tab.id);\n                });\n            });\n        }\n    };\n    Tabs.prototype.destroy = function () {\n        if (this._initialized) {\n            this._initialized = false;\n        }\n    };\n    Tabs.prototype.removeInstance = function () {\n        this.destroy();\n        dom_instances.removeInstance('Tabs', this._instanceId);\n    };\n    Tabs.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Tabs.prototype.getActiveTab = function () {\n        return this._activeTab;\n    };\n    Tabs.prototype.setActiveTab = function (tab) {\n        this._activeTab = tab;\n    };\n    Tabs.prototype.getTab = function (id) {\n        return this._items.filter(function (t) { return t.id === id; })[0];\n    };\n    Tabs.prototype.show = function (id, forceShow) {\n        var _a, _b;\n        var _this = this;\n        if (forceShow === void 0) { forceShow = false; }\n        var tab = this.getTab(id);\n        // don't do anything if already active\n        if (tab === this._activeTab && !forceShow) {\n            return;\n        }\n        // hide other tabs\n        this._items.map(function (t) {\n            var _a, _b;\n            if (t !== tab) {\n                (_a = t.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(' '));\n                (_b = t.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(' '));\n                t.targetEl.classList.add('hidden');\n                t.triggerEl.setAttribute('aria-selected', 'false');\n            }\n        });\n        // show active tab\n        (_a = tab.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(' '));\n        (_b = tab.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(' '));\n        tab.triggerEl.setAttribute('aria-selected', 'true');\n        tab.targetEl.classList.remove('hidden');\n        this.setActiveTab(tab);\n        // callback function\n        this._options.onShow(this, tab);\n    };\n    Tabs.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    return Tabs;\n}());\nfunction initTabs() {\n    document.querySelectorAll('[data-tabs-toggle]').forEach(function ($parentEl) {\n        var tabItems = [];\n        var activeClasses = $parentEl.getAttribute('data-tabs-active-classes');\n        var inactiveClasses = $parentEl.getAttribute('data-tabs-inactive-classes');\n        var defaultTabId = null;\n        $parentEl\n            .querySelectorAll('[role=\"tab\"]')\n            .forEach(function ($triggerEl) {\n            var isActive = $triggerEl.getAttribute('aria-selected') === 'true';\n            var tab = {\n                id: $triggerEl.getAttribute('data-tabs-target'),\n                triggerEl: $triggerEl,\n                targetEl: document.querySelector($triggerEl.getAttribute('data-tabs-target')),\n            };\n            tabItems.push(tab);\n            if (isActive) {\n                defaultTabId = tab.id;\n            }\n        });\n        new Tabs($parentEl, tabItems, {\n            defaultTabId: defaultTabId,\n            activeClasses: activeClasses\n                ? activeClasses\n                : tabs_Default.activeClasses,\n            inactiveClasses: inactiveClasses\n                ? inactiveClasses\n                : tabs_Default.inactiveClasses,\n        });\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Tabs = Tabs;\n    window.initTabs = initTabs;\n}\n/* harmony default export */ const tabs = ((/* unused pure expression or super */ null && (Tabs)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/tooltip/index.js\nvar tooltip_assign = (undefined && undefined.__assign) || function () {\n    tooltip_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return tooltip_assign.apply(this, arguments);\n};\nvar tooltip_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/* eslint-disable @typescript-eslint/no-empty-function */\n\n\nvar tooltip_Default = {\n    placement: 'top',\n    triggerType: 'hover',\n    onShow: function () { },\n    onHide: function () { },\n    onToggle: function () { },\n};\nvar tooltip_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Tooltip = /** @class */ (function () {\n    function Tooltip(targetEl, triggerEl, options, instanceOptions) {\n        if (targetEl === void 0) { targetEl = null; }\n        if (triggerEl === void 0) { triggerEl = null; }\n        if (options === void 0) { options = tooltip_Default; }\n        if (instanceOptions === void 0) { instanceOptions = tooltip_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._targetEl = targetEl;\n        this._triggerEl = triggerEl;\n        this._options = tooltip_assign(tooltip_assign({}, tooltip_Default), options);\n        this._popperInstance = null;\n        this._visible = false;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Tooltip', this, this._instanceId, instanceOptions.override);\n    }\n    Tooltip.prototype.init = function () {\n        if (this._triggerEl && this._targetEl && !this._initialized) {\n            this._setupEventListeners();\n            this._popperInstance = this._createPopperInstance();\n            this._initialized = true;\n        }\n    };\n    Tooltip.prototype.destroy = function () {\n        var _this = this;\n        if (this._initialized) {\n            // remove event listeners associated with the trigger element\n            var triggerEvents = this._getTriggerEvents();\n            triggerEvents.showEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._showHandler);\n            });\n            triggerEvents.hideEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._hideHandler);\n            });\n            // remove event listeners for keydown\n            this._removeKeydownListener();\n            // remove event listeners for click outside\n            this._removeClickOutsideListener();\n            // destroy the Popper instance if you have one (assuming this._popperInstance is the Popper instance)\n            if (this._popperInstance) {\n                this._popperInstance.destroy();\n            }\n            this._initialized = false;\n        }\n    };\n    Tooltip.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Tooltip', this._instanceId);\n    };\n    Tooltip.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Tooltip.prototype._setupEventListeners = function () {\n        var _this = this;\n        var triggerEvents = this._getTriggerEvents();\n        this._showHandler = function () {\n            _this.show();\n        };\n        this._hideHandler = function () {\n            _this.hide();\n        };\n        triggerEvents.showEvents.forEach(function (ev) {\n            _this._triggerEl.addEventListener(ev, _this._showHandler);\n        });\n        triggerEvents.hideEvents.forEach(function (ev) {\n            _this._triggerEl.addEventListener(ev, _this._hideHandler);\n        });\n    };\n    Tooltip.prototype._createPopperInstance = function () {\n        return popper_createPopper(this._triggerEl, this._targetEl, {\n            placement: this._options.placement,\n            modifiers: [\n                {\n                    name: 'offset',\n                    options: {\n                        offset: [0, 8],\n                    },\n                },\n            ],\n        });\n    };\n    Tooltip.prototype._getTriggerEvents = function () {\n        switch (this._options.triggerType) {\n            case 'hover':\n                return {\n                    showEvents: ['mouseenter', 'focus'],\n                    hideEvents: ['mouseleave', 'blur'],\n                };\n            case 'click':\n                return {\n                    showEvents: ['click', 'focus'],\n                    hideEvents: ['focusout', 'blur'],\n                };\n            case 'none':\n                return {\n                    showEvents: [],\n                    hideEvents: [],\n                };\n            default:\n                return {\n                    showEvents: ['mouseenter', 'focus'],\n                    hideEvents: ['mouseleave', 'blur'],\n                };\n        }\n    };\n    Tooltip.prototype._setupKeydownListener = function () {\n        var _this = this;\n        this._keydownEventListener = function (ev) {\n            if (ev.key === 'Escape') {\n                _this.hide();\n            }\n        };\n        document.body.addEventListener('keydown', this._keydownEventListener, true);\n    };\n    Tooltip.prototype._removeKeydownListener = function () {\n        document.body.removeEventListener('keydown', this._keydownEventListener, true);\n    };\n    Tooltip.prototype._setupClickOutsideListener = function () {\n        var _this = this;\n        this._clickOutsideEventListener = function (ev) {\n            _this._handleClickOutside(ev, _this._targetEl);\n        };\n        document.body.addEventListener('click', this._clickOutsideEventListener, true);\n    };\n    Tooltip.prototype._removeClickOutsideListener = function () {\n        document.body.removeEventListener('click', this._clickOutsideEventListener, true);\n    };\n    Tooltip.prototype._handleClickOutside = function (ev, targetEl) {\n        var clickedEl = ev.target;\n        if (clickedEl !== targetEl &&\n            !targetEl.contains(clickedEl) &&\n            !this._triggerEl.contains(clickedEl) &&\n            this.isVisible()) {\n            this.hide();\n        }\n    };\n    Tooltip.prototype.isVisible = function () {\n        return this._visible;\n    };\n    Tooltip.prototype.toggle = function () {\n        if (this.isVisible()) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    };\n    Tooltip.prototype.show = function () {\n        this._targetEl.classList.remove('opacity-0', 'invisible');\n        this._targetEl.classList.add('opacity-100', 'visible');\n        // Enable the event listeners\n        this._popperInstance.setOptions(function (options) { return (tooltip_assign(tooltip_assign({}, options), { modifiers: tooltip_spreadArray(tooltip_spreadArray([], options.modifiers, true), [\n                { name: 'eventListeners', enabled: true },\n            ], false) })); });\n        // handle click outside\n        this._setupClickOutsideListener();\n        // handle esc keydown\n        this._setupKeydownListener();\n        // Update its position\n        this._popperInstance.update();\n        // set visibility\n        this._visible = true;\n        // callback function\n        this._options.onShow(this);\n    };\n    Tooltip.prototype.hide = function () {\n        this._targetEl.classList.remove('opacity-100', 'visible');\n        this._targetEl.classList.add('opacity-0', 'invisible');\n        // Disable the event listeners\n        this._popperInstance.setOptions(function (options) { return (tooltip_assign(tooltip_assign({}, options), { modifiers: tooltip_spreadArray(tooltip_spreadArray([], options.modifiers, true), [\n                { name: 'eventListeners', enabled: false },\n            ], false) })); });\n        // handle click outside\n        this._removeClickOutsideListener();\n        // handle esc keydown\n        this._removeKeydownListener();\n        // set visibility\n        this._visible = false;\n        // callback function\n        this._options.onHide(this);\n    };\n    Tooltip.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    Tooltip.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    Tooltip.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Tooltip;\n}());\nfunction initTooltips() {\n    document.querySelectorAll('[data-tooltip-target]').forEach(function ($triggerEl) {\n        var tooltipId = $triggerEl.getAttribute('data-tooltip-target');\n        var $tooltipEl = document.getElementById(tooltipId);\n        if ($tooltipEl) {\n            var triggerType = $triggerEl.getAttribute('data-tooltip-trigger');\n            var placement = $triggerEl.getAttribute('data-tooltip-placement');\n            new Tooltip($tooltipEl, $triggerEl, {\n                placement: placement ? placement : tooltip_Default.placement,\n                triggerType: triggerType\n                    ? triggerType\n                    : tooltip_Default.triggerType,\n            });\n        }\n        else {\n            console.error(\"The tooltip element with id \\\"\".concat(tooltipId, \"\\\" does not exist. Please check the data-tooltip-target attribute.\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Tooltip = Tooltip;\n    window.initTooltips = initTooltips;\n}\n/* harmony default export */ const tooltip = ((/* unused pure expression or super */ null && (Tooltip)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/popover/index.js\nvar popover_assign = (undefined && undefined.__assign) || function () {\n    popover_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return popover_assign.apply(this, arguments);\n};\nvar popover_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/* eslint-disable @typescript-eslint/no-empty-function */\n\n\nvar popover_Default = {\n    placement: 'top',\n    offset: 10,\n    triggerType: 'hover',\n    onShow: function () { },\n    onHide: function () { },\n    onToggle: function () { },\n};\nvar popover_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Popover = /** @class */ (function () {\n    function Popover(targetEl, triggerEl, options, instanceOptions) {\n        if (targetEl === void 0) { targetEl = null; }\n        if (triggerEl === void 0) { triggerEl = null; }\n        if (options === void 0) { options = popover_Default; }\n        if (instanceOptions === void 0) { instanceOptions = popover_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._targetEl = targetEl;\n        this._triggerEl = triggerEl;\n        this._options = popover_assign(popover_assign({}, popover_Default), options);\n        this._popperInstance = null;\n        this._visible = false;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Popover', this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);\n    }\n    Popover.prototype.init = function () {\n        if (this._triggerEl && this._targetEl && !this._initialized) {\n            this._setupEventListeners();\n            this._popperInstance = this._createPopperInstance();\n            this._initialized = true;\n        }\n    };\n    Popover.prototype.destroy = function () {\n        var _this = this;\n        if (this._initialized) {\n            // remove event listeners associated with the trigger element and target element\n            var triggerEvents = this._getTriggerEvents();\n            triggerEvents.showEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._showHandler);\n                _this._targetEl.removeEventListener(ev, _this._showHandler);\n            });\n            triggerEvents.hideEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._hideHandler);\n                _this._targetEl.removeEventListener(ev, _this._hideHandler);\n            });\n            // remove event listeners for keydown\n            this._removeKeydownListener();\n            // remove event listeners for click outside\n            this._removeClickOutsideListener();\n            // destroy the Popper instance if you have one (assuming this._popperInstance is the Popper instance)\n            if (this._popperInstance) {\n                this._popperInstance.destroy();\n            }\n            this._initialized = false;\n        }\n    };\n    Popover.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Popover', this._instanceId);\n    };\n    Popover.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Popover.prototype._setupEventListeners = function () {\n        var _this = this;\n        var triggerEvents = this._getTriggerEvents();\n        this._showHandler = function () {\n            _this.show();\n        };\n        this._hideHandler = function () {\n            setTimeout(function () {\n                if (!_this._targetEl.matches(':hover')) {\n                    _this.hide();\n                }\n            }, 100);\n        };\n        triggerEvents.showEvents.forEach(function (ev) {\n            _this._triggerEl.addEventListener(ev, _this._showHandler);\n            _this._targetEl.addEventListener(ev, _this._showHandler);\n        });\n        triggerEvents.hideEvents.forEach(function (ev) {\n            _this._triggerEl.addEventListener(ev, _this._hideHandler);\n            _this._targetEl.addEventListener(ev, _this._hideHandler);\n        });\n    };\n    Popover.prototype._createPopperInstance = function () {\n        return popper_createPopper(this._triggerEl, this._targetEl, {\n            placement: this._options.placement,\n            modifiers: [\n                {\n                    name: 'offset',\n                    options: {\n                        offset: [0, this._options.offset],\n                    },\n                },\n            ],\n        });\n    };\n    Popover.prototype._getTriggerEvents = function () {\n        switch (this._options.triggerType) {\n            case 'hover':\n                return {\n                    showEvents: ['mouseenter', 'focus'],\n                    hideEvents: ['mouseleave', 'blur'],\n                };\n            case 'click':\n                return {\n                    showEvents: ['click', 'focus'],\n                    hideEvents: ['focusout', 'blur'],\n                };\n            case 'none':\n                return {\n                    showEvents: [],\n                    hideEvents: [],\n                };\n            default:\n                return {\n                    showEvents: ['mouseenter', 'focus'],\n                    hideEvents: ['mouseleave', 'blur'],\n                };\n        }\n    };\n    Popover.prototype._setupKeydownListener = function () {\n        var _this = this;\n        this._keydownEventListener = function (ev) {\n            if (ev.key === 'Escape') {\n                _this.hide();\n            }\n        };\n        document.body.addEventListener('keydown', this._keydownEventListener, true);\n    };\n    Popover.prototype._removeKeydownListener = function () {\n        document.body.removeEventListener('keydown', this._keydownEventListener, true);\n    };\n    Popover.prototype._setupClickOutsideListener = function () {\n        var _this = this;\n        this._clickOutsideEventListener = function (ev) {\n            _this._handleClickOutside(ev, _this._targetEl);\n        };\n        document.body.addEventListener('click', this._clickOutsideEventListener, true);\n    };\n    Popover.prototype._removeClickOutsideListener = function () {\n        document.body.removeEventListener('click', this._clickOutsideEventListener, true);\n    };\n    Popover.prototype._handleClickOutside = function (ev, targetEl) {\n        var clickedEl = ev.target;\n        if (clickedEl !== targetEl &&\n            !targetEl.contains(clickedEl) &&\n            !this._triggerEl.contains(clickedEl) &&\n            this.isVisible()) {\n            this.hide();\n        }\n    };\n    Popover.prototype.isVisible = function () {\n        return this._visible;\n    };\n    Popover.prototype.toggle = function () {\n        if (this.isVisible()) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n        this._options.onToggle(this);\n    };\n    Popover.prototype.show = function () {\n        this._targetEl.classList.remove('opacity-0', 'invisible');\n        this._targetEl.classList.add('opacity-100', 'visible');\n        // Enable the event listeners\n        this._popperInstance.setOptions(function (options) { return (popover_assign(popover_assign({}, options), { modifiers: popover_spreadArray(popover_spreadArray([], options.modifiers, true), [\n                { name: 'eventListeners', enabled: true },\n            ], false) })); });\n        // handle click outside\n        this._setupClickOutsideListener();\n        // handle esc keydown\n        this._setupKeydownListener();\n        // Update its position\n        this._popperInstance.update();\n        // set visibility to true\n        this._visible = true;\n        // callback function\n        this._options.onShow(this);\n    };\n    Popover.prototype.hide = function () {\n        this._targetEl.classList.remove('opacity-100', 'visible');\n        this._targetEl.classList.add('opacity-0', 'invisible');\n        // Disable the event listeners\n        this._popperInstance.setOptions(function (options) { return (popover_assign(popover_assign({}, options), { modifiers: popover_spreadArray(popover_spreadArray([], options.modifiers, true), [\n                { name: 'eventListeners', enabled: false },\n            ], false) })); });\n        // handle click outside\n        this._removeClickOutsideListener();\n        // handle esc keydown\n        this._removeKeydownListener();\n        // set visibility to false\n        this._visible = false;\n        // callback function\n        this._options.onHide(this);\n    };\n    Popover.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    Popover.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    Popover.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Popover;\n}());\nfunction initPopovers() {\n    document.querySelectorAll('[data-popover-target]').forEach(function ($triggerEl) {\n        var popoverID = $triggerEl.getAttribute('data-popover-target');\n        var $popoverEl = document.getElementById(popoverID);\n        if ($popoverEl) {\n            var triggerType = $triggerEl.getAttribute('data-popover-trigger');\n            var placement = $triggerEl.getAttribute('data-popover-placement');\n            var offset = $triggerEl.getAttribute('data-popover-offset');\n            new Popover($popoverEl, $triggerEl, {\n                placement: placement ? placement : popover_Default.placement,\n                offset: offset ? parseInt(offset) : popover_Default.offset,\n                triggerType: triggerType\n                    ? triggerType\n                    : popover_Default.triggerType,\n            });\n        }\n        else {\n            console.error(\"The popover element with id \\\"\".concat(popoverID, \"\\\" does not exist. Please check the data-popover-target attribute.\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Popover = Popover;\n    window.initPopovers = initPopovers;\n}\n/* harmony default export */ const popover = ((/* unused pure expression or super */ null && (Popover)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/dial/index.js\nvar dial_assign = (undefined && undefined.__assign) || function () {\n    dial_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return dial_assign.apply(this, arguments);\n};\n\nvar dial_Default = {\n    triggerType: 'hover',\n    onShow: function () { },\n    onHide: function () { },\n    onToggle: function () { },\n};\nvar dial_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Dial = /** @class */ (function () {\n    function Dial(parentEl, triggerEl, targetEl, options, instanceOptions) {\n        if (parentEl === void 0) { parentEl = null; }\n        if (triggerEl === void 0) { triggerEl = null; }\n        if (targetEl === void 0) { targetEl = null; }\n        if (options === void 0) { options = dial_Default; }\n        if (instanceOptions === void 0) { instanceOptions = dial_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._parentEl = parentEl;\n        this._triggerEl = triggerEl;\n        this._targetEl = targetEl;\n        this._options = dial_assign(dial_assign({}, dial_Default), options);\n        this._visible = false;\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Dial', this, this._instanceId, instanceOptions.override);\n    }\n    Dial.prototype.init = function () {\n        var _this = this;\n        if (this._triggerEl && this._targetEl && !this._initialized) {\n            var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);\n            this._showEventHandler = function () {\n                _this.show();\n            };\n            triggerEventTypes.showEvents.forEach(function (ev) {\n                _this._triggerEl.addEventListener(ev, _this._showEventHandler);\n                _this._targetEl.addEventListener(ev, _this._showEventHandler);\n            });\n            this._hideEventHandler = function () {\n                if (!_this._parentEl.matches(':hover')) {\n                    _this.hide();\n                }\n            };\n            triggerEventTypes.hideEvents.forEach(function (ev) {\n                _this._parentEl.addEventListener(ev, _this._hideEventHandler);\n            });\n            this._initialized = true;\n        }\n    };\n    Dial.prototype.destroy = function () {\n        var _this = this;\n        if (this._initialized) {\n            var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);\n            triggerEventTypes.showEvents.forEach(function (ev) {\n                _this._triggerEl.removeEventListener(ev, _this._showEventHandler);\n                _this._targetEl.removeEventListener(ev, _this._showEventHandler);\n            });\n            triggerEventTypes.hideEvents.forEach(function (ev) {\n                _this._parentEl.removeEventListener(ev, _this._hideEventHandler);\n            });\n            this._initialized = false;\n        }\n    };\n    Dial.prototype.removeInstance = function () {\n        dom_instances.removeInstance('Dial', this._instanceId);\n    };\n    Dial.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Dial.prototype.hide = function () {\n        this._targetEl.classList.add('hidden');\n        if (this._triggerEl) {\n            this._triggerEl.setAttribute('aria-expanded', 'false');\n        }\n        this._visible = false;\n        // callback function\n        this._options.onHide(this);\n    };\n    Dial.prototype.show = function () {\n        this._targetEl.classList.remove('hidden');\n        if (this._triggerEl) {\n            this._triggerEl.setAttribute('aria-expanded', 'true');\n        }\n        this._visible = true;\n        // callback function\n        this._options.onShow(this);\n    };\n    Dial.prototype.toggle = function () {\n        if (this._visible) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    };\n    Dial.prototype.isHidden = function () {\n        return !this._visible;\n    };\n    Dial.prototype.isVisible = function () {\n        return this._visible;\n    };\n    Dial.prototype._getTriggerEventTypes = function (triggerType) {\n        switch (triggerType) {\n            case 'hover':\n                return {\n                    showEvents: ['mouseenter', 'focus'],\n                    hideEvents: ['mouseleave', 'blur'],\n                };\n            case 'click':\n                return {\n                    showEvents: ['click', 'focus'],\n                    hideEvents: ['focusout', 'blur'],\n                };\n            case 'none':\n                return {\n                    showEvents: [],\n                    hideEvents: [],\n                };\n            default:\n                return {\n                    showEvents: ['mouseenter', 'focus'],\n                    hideEvents: ['mouseleave', 'blur'],\n                };\n        }\n    };\n    Dial.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    Dial.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    Dial.prototype.updateOnToggle = function (callback) {\n        this._options.onToggle = callback;\n    };\n    return Dial;\n}());\nfunction initDials() {\n    document.querySelectorAll('[data-dial-init]').forEach(function ($parentEl) {\n        var $triggerEl = $parentEl.querySelector('[data-dial-toggle]');\n        if ($triggerEl) {\n            var dialId = $triggerEl.getAttribute('data-dial-toggle');\n            var $dialEl = document.getElementById(dialId);\n            if ($dialEl) {\n                var triggerType = $triggerEl.getAttribute('data-dial-trigger');\n                new Dial($parentEl, $triggerEl, $dialEl, {\n                    triggerType: triggerType\n                        ? triggerType\n                        : dial_Default.triggerType,\n                });\n            }\n            else {\n                console.error(\"Dial with id \".concat(dialId, \" does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?\"));\n            }\n        }\n        else {\n            console.error(\"Dial with id \".concat($parentEl.id, \" does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Dial = Dial;\n    window.initDials = initDials;\n}\n/* harmony default export */ const dial = ((/* unused pure expression or super */ null && (Dial)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/input-counter/index.js\nvar input_counter_assign = (undefined && undefined.__assign) || function () {\n    input_counter_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return input_counter_assign.apply(this, arguments);\n};\n\nvar input_counter_Default = {\n    minValue: null,\n    maxValue: null,\n    onIncrement: function () { },\n    onDecrement: function () { },\n};\nvar input_counter_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar InputCounter = /** @class */ (function () {\n    function InputCounter(targetEl, incrementEl, decrementEl, options, instanceOptions) {\n        if (targetEl === void 0) { targetEl = null; }\n        if (incrementEl === void 0) { incrementEl = null; }\n        if (decrementEl === void 0) { decrementEl = null; }\n        if (options === void 0) { options = input_counter_Default; }\n        if (instanceOptions === void 0) { instanceOptions = input_counter_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._targetEl = targetEl;\n        this._incrementEl = incrementEl;\n        this._decrementEl = decrementEl;\n        this._options = input_counter_assign(input_counter_assign({}, input_counter_Default), options);\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('InputCounter', this, this._instanceId, instanceOptions.override);\n    }\n    InputCounter.prototype.init = function () {\n        var _this = this;\n        if (this._targetEl && !this._initialized) {\n            this._inputHandler = function (event) {\n                {\n                    var target = event.target;\n                    // check if the value is numeric\n                    if (!/^\\d*$/.test(target.value)) {\n                        // Regex to check if the value is numeric\n                        target.value = target.value.replace(/[^\\d]/g, ''); // Remove non-numeric characters\n                    }\n                    // check for max value\n                    if (_this._options.maxValue !== null &&\n                        parseInt(target.value) > _this._options.maxValue) {\n                        target.value = _this._options.maxValue.toString();\n                    }\n                    // check for min value\n                    if (_this._options.minValue !== null &&\n                        parseInt(target.value) < _this._options.minValue) {\n                        target.value = _this._options.minValue.toString();\n                    }\n                }\n            };\n            this._incrementClickHandler = function () {\n                _this.increment();\n            };\n            this._decrementClickHandler = function () {\n                _this.decrement();\n            };\n            // Add event listener to restrict input to numeric values only\n            this._targetEl.addEventListener('input', this._inputHandler);\n            if (this._incrementEl) {\n                this._incrementEl.addEventListener('click', this._incrementClickHandler);\n            }\n            if (this._decrementEl) {\n                this._decrementEl.addEventListener('click', this._decrementClickHandler);\n            }\n            this._initialized = true;\n        }\n    };\n    InputCounter.prototype.destroy = function () {\n        if (this._targetEl && this._initialized) {\n            this._targetEl.removeEventListener('input', this._inputHandler);\n            if (this._incrementEl) {\n                this._incrementEl.removeEventListener('click', this._incrementClickHandler);\n            }\n            if (this._decrementEl) {\n                this._decrementEl.removeEventListener('click', this._decrementClickHandler);\n            }\n            this._initialized = false;\n        }\n    };\n    InputCounter.prototype.removeInstance = function () {\n        dom_instances.removeInstance('InputCounter', this._instanceId);\n    };\n    InputCounter.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    InputCounter.prototype.getCurrentValue = function () {\n        return parseInt(this._targetEl.value) || 0;\n    };\n    InputCounter.prototype.increment = function () {\n        // don't increment if the value is already at the maximum value\n        if (this._options.maxValue !== null &&\n            this.getCurrentValue() >= this._options.maxValue) {\n            return;\n        }\n        this._targetEl.value = (this.getCurrentValue() + 1).toString();\n        this._options.onIncrement(this);\n    };\n    InputCounter.prototype.decrement = function () {\n        // don't decrement if the value is already at the minimum value\n        if (this._options.minValue !== null &&\n            this.getCurrentValue() <= this._options.minValue) {\n            return;\n        }\n        this._targetEl.value = (this.getCurrentValue() - 1).toString();\n        this._options.onDecrement(this);\n    };\n    InputCounter.prototype.updateOnIncrement = function (callback) {\n        this._options.onIncrement = callback;\n    };\n    InputCounter.prototype.updateOnDecrement = function (callback) {\n        this._options.onDecrement = callback;\n    };\n    return InputCounter;\n}());\nfunction initInputCounters() {\n    document.querySelectorAll('[data-input-counter]').forEach(function ($targetEl) {\n        var targetId = $targetEl.id;\n        var $incrementEl = document.querySelector('[data-input-counter-increment=\"' + targetId + '\"]');\n        var $decrementEl = document.querySelector('[data-input-counter-decrement=\"' + targetId + '\"]');\n        var minValue = $targetEl.getAttribute('data-input-counter-min');\n        var maxValue = $targetEl.getAttribute('data-input-counter-max');\n        // check if the target element exists\n        if ($targetEl) {\n            if (!dom_instances.instanceExists('InputCounter', $targetEl.getAttribute('id'))) {\n                new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {\n                    minValue: minValue ? parseInt(minValue) : null,\n                    maxValue: maxValue ? parseInt(maxValue) : null,\n                });\n            }\n        }\n        else {\n            console.error(\"The target element with id \\\"\".concat(targetId, \"\\\" does not exist. Please check the data-input-counter attribute.\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.InputCounter = InputCounter;\n    window.initInputCounters = initInputCounters;\n}\n/* harmony default export */ const input_counter = ((/* unused pure expression or super */ null && (InputCounter)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/clipboard/index.js\nvar clipboard_assign = (undefined && undefined.__assign) || function () {\n    clipboard_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return clipboard_assign.apply(this, arguments);\n};\n\nvar clipboard_Default = {\n    htmlEntities: false,\n    contentType: 'input',\n    onCopy: function () { },\n};\nvar clipboard_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar CopyClipboard = /** @class */ (function () {\n    function CopyClipboard(triggerEl, targetEl, options, instanceOptions) {\n        if (triggerEl === void 0) { triggerEl = null; }\n        if (targetEl === void 0) { targetEl = null; }\n        if (options === void 0) { options = clipboard_Default; }\n        if (instanceOptions === void 0) { instanceOptions = clipboard_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : targetEl.id;\n        this._triggerEl = triggerEl;\n        this._targetEl = targetEl;\n        this._options = clipboard_assign(clipboard_assign({}, clipboard_Default), options);\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('CopyClipboard', this, this._instanceId, instanceOptions.override);\n    }\n    CopyClipboard.prototype.init = function () {\n        var _this = this;\n        if (this._targetEl && this._triggerEl && !this._initialized) {\n            this._triggerElClickHandler = function () {\n                _this.copy();\n            };\n            // clicking on the trigger element should copy the value of the target element\n            if (this._triggerEl) {\n                this._triggerEl.addEventListener('click', this._triggerElClickHandler);\n            }\n            this._initialized = true;\n        }\n    };\n    CopyClipboard.prototype.destroy = function () {\n        if (this._triggerEl && this._targetEl && this._initialized) {\n            if (this._triggerEl) {\n                this._triggerEl.removeEventListener('click', this._triggerElClickHandler);\n            }\n            this._initialized = false;\n        }\n    };\n    CopyClipboard.prototype.removeInstance = function () {\n        dom_instances.removeInstance('CopyClipboard', this._instanceId);\n    };\n    CopyClipboard.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    CopyClipboard.prototype.getTargetValue = function () {\n        if (this._options.contentType === 'input') {\n            return this._targetEl.value;\n        }\n        if (this._options.contentType === 'innerHTML') {\n            return this._targetEl.innerHTML;\n        }\n        if (this._options.contentType === 'textContent') {\n            return this._targetEl.textContent.replace(/\\s+/g, ' ').trim();\n        }\n    };\n    CopyClipboard.prototype.copy = function () {\n        var textToCopy = this.getTargetValue();\n        // Check if HTMLEntities option is enabled\n        if (this._options.htmlEntities) {\n            // Encode the text using HTML entities\n            textToCopy = this.decodeHTML(textToCopy);\n        }\n        // Create a temporary textarea element\n        var tempTextArea = document.createElement('textarea');\n        tempTextArea.value = textToCopy;\n        document.body.appendChild(tempTextArea);\n        // Select the text inside the textarea and copy it to the clipboard\n        tempTextArea.select();\n        document.execCommand('copy');\n        // Remove the temporary textarea\n        document.body.removeChild(tempTextArea);\n        // Callback function\n        this._options.onCopy(this);\n        return textToCopy;\n    };\n    // Function to encode text into HTML entities\n    CopyClipboard.prototype.decodeHTML = function (html) {\n        var textarea = document.createElement('textarea');\n        textarea.innerHTML = html;\n        return textarea.textContent;\n    };\n    CopyClipboard.prototype.updateOnCopyCallback = function (callback) {\n        this._options.onCopy = callback;\n    };\n    return CopyClipboard;\n}());\nfunction initCopyClipboards() {\n    document\n        .querySelectorAll('[data-copy-to-clipboard-target]')\n        .forEach(function ($triggerEl) {\n        var targetId = $triggerEl.getAttribute('data-copy-to-clipboard-target');\n        var $targetEl = document.getElementById(targetId);\n        var contentType = $triggerEl.getAttribute('data-copy-to-clipboard-content-type');\n        var htmlEntities = $triggerEl.getAttribute('data-copy-to-clipboard-html-entities');\n        // check if the target element exists\n        if ($targetEl) {\n            if (!dom_instances.instanceExists('CopyClipboard', $targetEl.getAttribute('id'))) {\n                new CopyClipboard($triggerEl, $targetEl, {\n                    htmlEntities: htmlEntities && htmlEntities === 'true'\n                        ? true\n                        : clipboard_Default.htmlEntities,\n                    contentType: contentType\n                        ? contentType\n                        : clipboard_Default.contentType,\n                });\n            }\n        }\n        else {\n            console.error(\"The target element with id \\\"\".concat(targetId, \"\\\" does not exist. Please check the data-copy-to-clipboard-target attribute.\"));\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.CopyClipboard = CopyClipboard;\n    window.initClipboards = initCopyClipboards;\n}\n/* harmony default export */ const clipboard = ((/* unused pure expression or super */ null && (CopyClipboard)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite-datepicker/dist/main.esm.js\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _get() {\n  return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {\n    var p = _superPropBase(e, t);\n    if (p) {\n      var n = Object.getOwnPropertyDescriptor(p, t);\n      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;\n    }\n  }, _get.apply(null, arguments);\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _superPropBase(t, o) {\n  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););\n  return t;\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nfunction hasProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction lastItemOf(arr) {\n  return arr[arr.length - 1];\n}\n\n// push only the items not included in the array\nfunction pushUnique(arr) {\n  for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    items[_key - 1] = arguments[_key];\n  }\n  items.forEach(function (item) {\n    if (arr.includes(item)) {\n      return;\n    }\n    arr.push(item);\n  });\n  return arr;\n}\nfunction stringToArray(str, separator) {\n  // convert empty string to an empty array\n  return str ? str.split(separator) : [];\n}\nfunction isInRange(testVal, min, max) {\n  var minOK = min === undefined || testVal >= min;\n  var maxOK = max === undefined || testVal <= max;\n  return minOK && maxOK;\n}\nfunction limitToRange(val, min, max) {\n  if (val < min) {\n    return min;\n  }\n  if (val > max) {\n    return max;\n  }\n  return val;\n}\nfunction createTagRepeat(tagName, repeat) {\n  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var html = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';\n  var openTagSrc = Object.keys(attributes).reduce(function (src, attr) {\n    var val = attributes[attr];\n    if (typeof val === 'function') {\n      val = val(index);\n    }\n    return \"\".concat(src, \" \").concat(attr, \"=\\\"\").concat(val, \"\\\"\");\n  }, tagName);\n  html += \"<\".concat(openTagSrc, \"></\").concat(tagName, \">\");\n  var next = index + 1;\n  return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;\n}\n\n// Remove the spacing surrounding tags for HTML parser not to create text nodes\n// before/after elements\nfunction optimizeTemplateHTML(html) {\n  return html.replace(/>\\s+/g, '>').replace(/\\s+</, '<');\n}\n\nfunction stripTime(timeValue) {\n  return new Date(timeValue).setHours(0, 0, 0, 0);\n}\nfunction today() {\n  return new Date().setHours(0, 0, 0, 0);\n}\n\n// Get the time value of the start of given date or year, month and day\nfunction dateValue() {\n  switch (arguments.length) {\n    case 0:\n      return today();\n    case 1:\n      return stripTime(arguments.length <= 0 ? undefined : arguments[0]);\n  }\n\n  // use setFullYear() to keep 2-digit year from being mapped to 1900-1999\n  var newDate = new Date(0);\n  newDate.setFullYear.apply(newDate, arguments);\n  return newDate.setHours(0, 0, 0, 0);\n}\nfunction addDays(date, amount) {\n  var newDate = new Date(date);\n  return newDate.setDate(newDate.getDate() + amount);\n}\nfunction addWeeks(date, amount) {\n  return addDays(date, amount * 7);\n}\nfunction addMonths(date, amount) {\n  // If the day of the date is not in the new month, the last day of the new\n  // month will be returned. e.g. Jan 31 + 1 month  Feb 28 (not Mar 03)\n  var newDate = new Date(date);\n  var monthsToSet = newDate.getMonth() + amount;\n  var expectedMonth = monthsToSet % 12;\n  if (expectedMonth < 0) {\n    expectedMonth += 12;\n  }\n  var time = newDate.setMonth(monthsToSet);\n  return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;\n}\nfunction addYears(date, amount) {\n  // If the date is Feb 29 and the new year is not a leap year, Feb 28 of the\n  // new year will be returned.\n  var newDate = new Date(date);\n  var expectedMonth = newDate.getMonth();\n  var time = newDate.setFullYear(newDate.getFullYear() + amount);\n  return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;\n}\n\n// Calculate the distance bettwen 2 days of the week\nfunction dayDiff(day, from) {\n  return (day - from + 7) % 7;\n}\n\n// Get the date of the specified day of the week of given base date\nfunction dayOfTheWeekOf(baseDate, dayOfWeek) {\n  var weekStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var baseDay = new Date(baseDate).getDay();\n  return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));\n}\n\n// Get the ISO week of a date\nfunction getWeek(date) {\n  // start of ISO week is Monday\n  var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);\n  // 1st week == the week where the 4th of January is in\n  var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);\n  return Math.round((thuOfTheWeek - firstThu) / 604800000) + 1;\n}\n\n// Get the start year of the period of years that includes given date\n// years: length of the year period\nfunction startOfYearPeriod(date, years) {\n  /* @see https://en.wikipedia.org/wiki/Year_zero#ISO_8601 */\n  var year = new Date(date).getFullYear();\n  return Math.floor(year / years) * years;\n}\n\n// pattern for format parts\nvar reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;\n// pattern for non date parts\nvar reNonDateParts = /[\\s!-/:-@[-`{-~]+/;\n// cache for persed formats\nvar knownFormats = {};\n// parse funtions for date parts\nvar parseFns = {\n  y: function y(date, year) {\n    return new Date(date).setFullYear(parseInt(year, 10));\n  },\n  m: function m(date, month, locale) {\n    var newDate = new Date(date);\n    var monthIndex = parseInt(month, 10) - 1;\n    if (isNaN(monthIndex)) {\n      if (!month) {\n        return NaN;\n      }\n      var monthName = month.toLowerCase();\n      var compareNames = function compareNames(name) {\n        return name.toLowerCase().startsWith(monthName);\n      };\n      // compare with both short and full names because some locales have periods\n      // in the short names (not equal to the first X letters of the full names)\n      monthIndex = locale.monthsShort.findIndex(compareNames);\n      if (monthIndex < 0) {\n        monthIndex = locale.months.findIndex(compareNames);\n      }\n      if (monthIndex < 0) {\n        return NaN;\n      }\n    }\n    newDate.setMonth(monthIndex);\n    return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();\n  },\n  d: function d(date, day) {\n    return new Date(date).setDate(parseInt(day, 10));\n  }\n};\n// format functions for date parts\nvar formatFns = {\n  d: function d(date) {\n    return date.getDate();\n  },\n  dd: function dd(date) {\n    return padZero(date.getDate(), 2);\n  },\n  D: function D(date, locale) {\n    return locale.daysShort[date.getDay()];\n  },\n  DD: function DD(date, locale) {\n    return locale.days[date.getDay()];\n  },\n  m: function m(date) {\n    return date.getMonth() + 1;\n  },\n  mm: function mm(date) {\n    return padZero(date.getMonth() + 1, 2);\n  },\n  M: function M(date, locale) {\n    return locale.monthsShort[date.getMonth()];\n  },\n  MM: function MM(date, locale) {\n    return locale.months[date.getMonth()];\n  },\n  y: function y(date) {\n    return date.getFullYear();\n  },\n  yy: function yy(date) {\n    return padZero(date.getFullYear(), 2).slice(-2);\n  },\n  yyyy: function yyyy(date) {\n    return padZero(date.getFullYear(), 4);\n  }\n};\n\n// get month index in normal range (0 - 11) from any number\nfunction normalizeMonth(monthIndex) {\n  return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);\n}\nfunction padZero(num, length) {\n  return num.toString().padStart(length, '0');\n}\nfunction parseFormatString(format) {\n  if (typeof format !== 'string') {\n    throw new Error(\"Invalid date format.\");\n  }\n  if (format in knownFormats) {\n    return knownFormats[format];\n  }\n\n  // sprit the format string into parts and seprators\n  var separators = format.split(reFormatTokens);\n  var parts = format.match(new RegExp(reFormatTokens, 'g'));\n  if (separators.length === 0 || !parts) {\n    throw new Error(\"Invalid date format.\");\n  }\n\n  // collect format functions used in the format\n  var partFormatters = parts.map(function (token) {\n    return formatFns[token];\n  });\n\n  // collect parse function keys used in the format\n  // iterate over parseFns' keys in order to keep the order of the keys.\n  var partParserKeys = Object.keys(parseFns).reduce(function (keys, key) {\n    var token = parts.find(function (part) {\n      return part[0] !== 'D' && part[0].toLowerCase() === key;\n    });\n    if (token) {\n      keys.push(key);\n    }\n    return keys;\n  }, []);\n  return knownFormats[format] = {\n    parser: function parser(dateStr, locale) {\n      var dateParts = dateStr.split(reNonDateParts).reduce(function (dtParts, part, index) {\n        if (part.length > 0 && parts[index]) {\n          var token = parts[index][0];\n          if (token === 'M') {\n            dtParts.m = part;\n          } else if (token !== 'D') {\n            dtParts[token] = part;\n          }\n        }\n        return dtParts;\n      }, {});\n\n      // iterate over partParserkeys so that the parsing is made in the oder\n      // of year, month and day to prevent the day parser from correcting last\n      // day of month wrongly\n      return partParserKeys.reduce(function (origDate, key) {\n        var newDate = parseFns[key](origDate, dateParts[key], locale);\n        // ingnore the part failed to parse\n        return isNaN(newDate) ? origDate : newDate;\n      }, today());\n    },\n    formatter: function formatter(date, locale) {\n      var dateStr = partFormatters.reduce(function (str, fn, index) {\n        return str += \"\".concat(separators[index]).concat(fn(date, locale));\n      }, '');\n      // separators' length is always parts' length + 1,\n      return dateStr += lastItemOf(separators);\n    }\n  };\n}\nfunction parseDate(dateStr, format, locale) {\n  if (dateStr instanceof Date || typeof dateStr === 'number') {\n    var date = stripTime(dateStr);\n    return isNaN(date) ? undefined : date;\n  }\n  if (!dateStr) {\n    return undefined;\n  }\n  if (dateStr === 'today') {\n    return today();\n  }\n  if (format && format.toValue) {\n    var _date = format.toValue(dateStr, format, locale);\n    return isNaN(_date) ? undefined : stripTime(_date);\n  }\n  return parseFormatString(format).parser(dateStr, locale);\n}\nfunction formatDate(date, format, locale) {\n  if (isNaN(date) || !date && date !== 0) {\n    return '';\n  }\n  var dateObj = typeof date === 'number' ? new Date(date) : date;\n  if (format.toDisplay) {\n    return format.toDisplay(dateObj, format, locale);\n  }\n  return parseFormatString(format).formatter(dateObj, locale);\n}\n\nvar listenerRegistry = new WeakMap();\nvar _EventTarget$prototyp = EventTarget.prototype,\n  addEventListener = _EventTarget$prototyp.addEventListener,\n  removeEventListener = _EventTarget$prototyp.removeEventListener;\n\n// Register event listeners to a key object\n// listeners: array of listener definitions;\n//   - each definition must be a flat array of event target and the arguments\n//     used to call addEventListener() on the target\nfunction registerListeners(keyObj, listeners) {\n  var registered = listenerRegistry.get(keyObj);\n  if (!registered) {\n    registered = [];\n    listenerRegistry.set(keyObj, registered);\n  }\n  listeners.forEach(function (listener) {\n    addEventListener.call.apply(addEventListener, _toConsumableArray(listener));\n    registered.push(listener);\n  });\n}\nfunction unregisterListeners(keyObj) {\n  var listeners = listenerRegistry.get(keyObj);\n  if (!listeners) {\n    return;\n  }\n  listeners.forEach(function (listener) {\n    removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));\n  });\n  listenerRegistry[\"delete\"](keyObj);\n}\n\n// Event.composedPath() polyfill for Edge\n// based on https://gist.github.com/kleinfreund/e9787d73776c0e3750dcfcdc89f100ec\nif (!Event.prototype.composedPath) {\n  var getComposedPath = function getComposedPath(node) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    path.push(node);\n    var parent;\n    if (node.parentNode) {\n      parent = node.parentNode;\n    } else if (node.host) {\n      // ShadowRoot\n      parent = node.host;\n    } else if (node.defaultView) {\n      // Document\n      parent = node.defaultView;\n    }\n    return parent ? getComposedPath(parent, path) : path;\n  };\n  Event.prototype.composedPath = function () {\n    return getComposedPath(this.target);\n  };\n}\nfunction findFromPath(path, criteria, currentTarget) {\n  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var el = path[index];\n  if (criteria(el)) {\n    return el;\n  } else if (el === currentTarget || !el.parentElement) {\n    // stop when reaching currentTarget or <html>\n    return;\n  }\n  return findFromPath(path, criteria, currentTarget, index + 1);\n}\n\n// Search for the actual target of a delegated event\nfunction findElementInEventPath(ev, selector) {\n  var criteria = typeof selector === 'function' ? selector : function (el) {\n    return el.matches(selector);\n  };\n  return findFromPath(ev.composedPath(), criteria, ev.currentTarget);\n}\n\n// default locales\nvar locales = {\n  en: {\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    daysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    daysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    today: \"Today\",\n    clear: \"Clear\",\n    titleFormat: \"MM y\"\n  }\n};\n\n// config options updatable by setOptions() and their default values\nvar defaultOptions = {\n  autohide: false,\n  beforeShowDay: null,\n  beforeShowDecade: null,\n  beforeShowMonth: null,\n  beforeShowYear: null,\n  calendarWeeks: false,\n  clearBtn: false,\n  dateDelimiter: ',',\n  datesDisabled: [],\n  daysOfWeekDisabled: [],\n  daysOfWeekHighlighted: [],\n  defaultViewDate: undefined,\n  // placeholder, defaults to today() by the program\n  disableTouchKeyboard: false,\n  format: 'mm/dd/yyyy',\n  language: 'en',\n  maxDate: null,\n  maxNumberOfDates: 1,\n  maxView: 3,\n  minDate: null,\n  nextArrow: '<svg class=\"w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white\" aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 14 10\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M1 5h12m0 0L9 1m4 4L9 9\"/></svg>',\n  orientation: 'auto',\n  pickLevel: 0,\n  prevArrow: '<svg class=\"w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white\" aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 14 10\"><path stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 5H1m0 0 4 4M1 5l4-4\"/></svg>',\n  showDaysOfWeek: true,\n  showOnClick: true,\n  showOnFocus: true,\n  startView: 0,\n  title: '',\n  todayBtn: false,\n  todayBtnMode: 0,\n  todayHighlight: false,\n  updateOnBlur: true,\n  weekStart: 0\n};\n\nvar range = document.createRange();\nfunction parseHTML(html) {\n  return range.createContextualFragment(html);\n}\nfunction hideElement(el) {\n  if (el.style.display === 'none') {\n    return;\n  }\n  // back up the existing display setting in data-style-display\n  if (el.style.display) {\n    el.dataset.styleDisplay = el.style.display;\n  }\n  el.style.display = 'none';\n}\nfunction showElement(el) {\n  if (el.style.display !== 'none') {\n    return;\n  }\n  if (el.dataset.styleDisplay) {\n    // restore backed-up dispay property\n    el.style.display = el.dataset.styleDisplay;\n    delete el.dataset.styleDisplay;\n  } else {\n    el.style.display = '';\n  }\n}\nfunction emptyChildNodes(el) {\n  if (el.firstChild) {\n    el.removeChild(el.firstChild);\n    emptyChildNodes(el);\n  }\n}\nfunction replaceChildNodes(el, newChildNodes) {\n  emptyChildNodes(el);\n  if (newChildNodes instanceof DocumentFragment) {\n    el.appendChild(newChildNodes);\n  } else if (typeof newChildNodes === 'string') {\n    el.appendChild(parseHTML(newChildNodes));\n  } else if (typeof newChildNodes.forEach === 'function') {\n    newChildNodes.forEach(function (node) {\n      el.appendChild(node);\n    });\n  }\n}\n\nvar defaultLang = defaultOptions.language,\n  defaultFormat = defaultOptions.format,\n  defaultWeekStart = defaultOptions.weekStart;\n\n// Reducer function to filter out invalid day-of-week from the input\nfunction sanitizeDOW(dow, day) {\n  return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;\n}\nfunction calcEndOfWeek(startOfWeek) {\n  return (startOfWeek + 6) % 7;\n}\n\n// validate input date. if invalid, fallback to the original value\nfunction validateDate(value, format, locale, origValue) {\n  var date = parseDate(value, format, locale);\n  return date !== undefined ? date : origValue;\n}\n\n// Validate viewId. if invalid, fallback to the original value\nfunction validateViewId(value, origValue) {\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n  var viewId = parseInt(value, 10);\n  return viewId >= 0 && viewId <= max ? viewId : origValue;\n}\n\n// Create Datepicker configuration to set\nfunction processOptions(options, datepicker) {\n  var inOpts = Object.assign({}, options);\n  var config = {};\n  var locales = datepicker.constructor.locales;\n  var _ref = datepicker.config || {},\n    format = _ref.format,\n    language = _ref.language,\n    locale = _ref.locale,\n    maxDate = _ref.maxDate,\n    maxView = _ref.maxView,\n    minDate = _ref.minDate,\n    pickLevel = _ref.pickLevel,\n    startView = _ref.startView,\n    weekStart = _ref.weekStart;\n  if (inOpts.language) {\n    var lang;\n    if (inOpts.language !== language) {\n      if (locales[inOpts.language]) {\n        lang = inOpts.language;\n      } else {\n        // Check if langauge + region tag can fallback to the one without\n        // region (e.g. fr-CA  fr)\n        lang = inOpts.language.split('-')[0];\n        if (locales[lang] === undefined) {\n          lang = false;\n        }\n      }\n    }\n    delete inOpts.language;\n    if (lang) {\n      language = config.language = lang;\n\n      // update locale as well when updating language\n      var origLocale = locale || locales[defaultLang];\n      // use default language's properties for the fallback\n      locale = Object.assign({\n        format: defaultFormat,\n        weekStart: defaultWeekStart\n      }, locales[defaultLang]);\n      if (language !== defaultLang) {\n        Object.assign(locale, locales[language]);\n      }\n      config.locale = locale;\n      // if format and/or weekStart are the same as old locale's defaults,\n      // update them to new locale's defaults\n      if (format === origLocale.format) {\n        format = config.format = locale.format;\n      }\n      if (weekStart === origLocale.weekStart) {\n        weekStart = config.weekStart = locale.weekStart;\n        config.weekEnd = calcEndOfWeek(locale.weekStart);\n      }\n    }\n  }\n  if (inOpts.format) {\n    var hasToDisplay = typeof inOpts.format.toDisplay === 'function';\n    var hasToValue = typeof inOpts.format.toValue === 'function';\n    var validFormatString = reFormatTokens.test(inOpts.format);\n    if (hasToDisplay && hasToValue || validFormatString) {\n      format = config.format = inOpts.format;\n    }\n    delete inOpts.format;\n  }\n\n  //*** dates ***//\n  // while min and maxDate for \"no limit\" in the options are better to be null\n  // (especially when updating), the ones in the config have to be undefined\n  // because null is treated as 0 (= unix epoch) when comparing with time value\n  var minDt = minDate;\n  var maxDt = maxDate;\n  if (inOpts.minDate !== undefined) {\n    minDt = inOpts.minDate === null ? dateValue(0, 0, 1) // set 0000-01-01 to prevent negative values for year\n    : validateDate(inOpts.minDate, format, locale, minDt);\n    delete inOpts.minDate;\n  }\n  if (inOpts.maxDate !== undefined) {\n    maxDt = inOpts.maxDate === null ? undefined : validateDate(inOpts.maxDate, format, locale, maxDt);\n    delete inOpts.maxDate;\n  }\n  if (maxDt < minDt) {\n    minDate = config.minDate = maxDt;\n    maxDate = config.maxDate = minDt;\n  } else {\n    if (minDate !== minDt) {\n      minDate = config.minDate = minDt;\n    }\n    if (maxDate !== maxDt) {\n      maxDate = config.maxDate = maxDt;\n    }\n  }\n  if (inOpts.datesDisabled) {\n    config.datesDisabled = inOpts.datesDisabled.reduce(function (dates, dt) {\n      var date = parseDate(dt, format, locale);\n      return date !== undefined ? pushUnique(dates, date) : dates;\n    }, []);\n    delete inOpts.datesDisabled;\n  }\n  if (inOpts.defaultViewDate !== undefined) {\n    var viewDate = parseDate(inOpts.defaultViewDate, format, locale);\n    if (viewDate !== undefined) {\n      config.defaultViewDate = viewDate;\n    }\n    delete inOpts.defaultViewDate;\n  }\n\n  //*** days of week ***//\n  if (inOpts.weekStart !== undefined) {\n    var wkStart = Number(inOpts.weekStart) % 7;\n    if (!isNaN(wkStart)) {\n      weekStart = config.weekStart = wkStart;\n      config.weekEnd = calcEndOfWeek(wkStart);\n    }\n    delete inOpts.weekStart;\n  }\n  if (inOpts.daysOfWeekDisabled) {\n    config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);\n    delete inOpts.daysOfWeekDisabled;\n  }\n  if (inOpts.daysOfWeekHighlighted) {\n    config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);\n    delete inOpts.daysOfWeekHighlighted;\n  }\n\n  //*** multi date ***//\n  if (inOpts.maxNumberOfDates !== undefined) {\n    var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);\n    if (maxNumberOfDates >= 0) {\n      config.maxNumberOfDates = maxNumberOfDates;\n      config.multidate = maxNumberOfDates !== 1;\n    }\n    delete inOpts.maxNumberOfDates;\n  }\n  if (inOpts.dateDelimiter) {\n    config.dateDelimiter = String(inOpts.dateDelimiter);\n    delete inOpts.dateDelimiter;\n  }\n\n  //*** pick level & view ***//\n  var newPickLevel = pickLevel;\n  if (inOpts.pickLevel !== undefined) {\n    newPickLevel = validateViewId(inOpts.pickLevel, 2);\n    delete inOpts.pickLevel;\n  }\n  if (newPickLevel !== pickLevel) {\n    pickLevel = config.pickLevel = newPickLevel;\n  }\n  var newMaxView = maxView;\n  if (inOpts.maxView !== undefined) {\n    newMaxView = validateViewId(inOpts.maxView, maxView);\n    delete inOpts.maxView;\n  }\n  // ensure max view >= pick level\n  newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;\n  if (newMaxView !== maxView) {\n    maxView = config.maxView = newMaxView;\n  }\n  var newStartView = startView;\n  if (inOpts.startView !== undefined) {\n    newStartView = validateViewId(inOpts.startView, newStartView);\n    delete inOpts.startView;\n  }\n  // ensure pick level <= start view <= max view\n  if (newStartView < pickLevel) {\n    newStartView = pickLevel;\n  } else if (newStartView > maxView) {\n    newStartView = maxView;\n  }\n  if (newStartView !== startView) {\n    config.startView = newStartView;\n  }\n\n  //*** template ***//\n  if (inOpts.prevArrow) {\n    var prevArrow = parseHTML(inOpts.prevArrow);\n    if (prevArrow.childNodes.length > 0) {\n      config.prevArrow = prevArrow.childNodes;\n    }\n    delete inOpts.prevArrow;\n  }\n  if (inOpts.nextArrow) {\n    var nextArrow = parseHTML(inOpts.nextArrow);\n    if (nextArrow.childNodes.length > 0) {\n      config.nextArrow = nextArrow.childNodes;\n    }\n    delete inOpts.nextArrow;\n  }\n\n  //*** misc ***//\n  if (inOpts.disableTouchKeyboard !== undefined) {\n    config.disableTouchKeyboard = 'ontouchstart' in document && !!inOpts.disableTouchKeyboard;\n    delete inOpts.disableTouchKeyboard;\n  }\n  if (inOpts.orientation) {\n    var orientation = inOpts.orientation.toLowerCase().split(/\\s+/g);\n    config.orientation = {\n      x: orientation.find(function (x) {\n        return x === 'left' || x === 'right';\n      }) || 'auto',\n      y: orientation.find(function (y) {\n        return y === 'top' || y === 'bottom';\n      }) || 'auto'\n    };\n    delete inOpts.orientation;\n  }\n  if (inOpts.todayBtnMode !== undefined) {\n    switch (inOpts.todayBtnMode) {\n      case 0:\n      case 1:\n        config.todayBtnMode = inOpts.todayBtnMode;\n    }\n    delete inOpts.todayBtnMode;\n  }\n\n  //*** copy the rest ***//\n  Object.keys(inOpts).forEach(function (key) {\n    if (inOpts[key] !== undefined && hasProperty(defaultOptions, key)) {\n      config[key] = inOpts[key];\n    }\n  });\n  return config;\n}\n\nvar pickerTemplate = optimizeTemplateHTML(\"<div class=\\\"datepicker hidden\\\">\\n  <div class=\\\"datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4\\\">\\n    <div class=\\\"datepicker-header\\\">\\n      <div class=\\\"datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold\\\"></div>\\n      <div class=\\\"datepicker-controls flex justify-between mb-2\\\">\\n        <button type=\\\"button\\\" class=\\\"bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn\\\"></button>\\n      </div>\\n    </div>\\n    <div class=\\\"datepicker-main p-1\\\"></div>\\n    <div class=\\\"datepicker-footer\\\">\\n      <div class=\\\"datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2\\\">\\n        <button type=\\\"button\\\" class=\\\"%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2\\\"></button>\\n        <button type=\\\"button\\\" class=\\\"%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2\\\"></button>\\n      </div>\\n    </div>\\n  </div>\\n</div>\");\n\nvar daysTemplate = optimizeTemplateHTML(\"<div class=\\\"days\\\">\\n  <div class=\\\"days-of-week grid grid-cols-7 mb-1\\\">\".concat(createTagRepeat('span', 7, {\n  \"class\": 'dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'\n}), \"</div>\\n  <div class=\\\"datepicker-grid w-64 grid grid-cols-7\\\">\").concat(createTagRepeat('span', 42, {\n  \"class\": 'block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400'\n}), \"</div>\\n</div>\"));\n\nvar calendarWeeksTemplate = optimizeTemplateHTML(\"<div class=\\\"calendar-weeks\\\">\\n  <div class=\\\"days-of-week flex\\\"><span class=\\\"dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400\\\"></span></div>\\n  <div class=\\\"weeks\\\">\".concat(createTagRepeat('span', 6, {\n  \"class\": 'week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm'\n}), \"</div>\\n</div>\"));\n\n// Base class of the view classes\nvar View = /*#__PURE__*/function () {\n  function View(picker, config) {\n    _classCallCheck(this, View);\n    Object.assign(this, config, {\n      picker: picker,\n      element: parseHTML(\"<div class=\\\"datepicker-view flex\\\"></div>\").firstChild,\n      selected: []\n    });\n    this.init(this.picker.datepicker.config);\n  }\n  return _createClass(View, [{\n    key: \"init\",\n    value: function init(options) {\n      if (options.pickLevel !== undefined) {\n        this.isMinView = this.id === options.pickLevel;\n      }\n      this.setOptions(options);\n      this.updateFocus();\n      this.updateSelection();\n    }\n\n    // Execute beforeShow() callback and apply the result to the element\n    // args:\n    // - current - current value on the iteration on view rendering\n    // - timeValue - time value of the date to pass to beforeShow()\n  }, {\n    key: \"performBeforeHook\",\n    value: function performBeforeHook(el, current, timeValue) {\n      var result = this.beforeShow(new Date(timeValue));\n      switch (_typeof(result)) {\n        case 'boolean':\n          result = {\n            enabled: result\n          };\n          break;\n        case 'string':\n          result = {\n            classes: result\n          };\n      }\n      if (result) {\n        if (result.enabled === false) {\n          el.classList.add('disabled');\n          pushUnique(this.disabled, current);\n        }\n        if (result.classes) {\n          var _el$classList;\n          var extraClasses = result.classes.split(/\\s+/);\n          (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));\n          if (extraClasses.includes('disabled')) {\n            pushUnique(this.disabled, current);\n          }\n        }\n        if (result.content) {\n          replaceChildNodes(el, result.content);\n        }\n      }\n    }\n  }]);\n}();\n\nvar DaysView = /*#__PURE__*/function (_View) {\n  function DaysView(picker) {\n    _classCallCheck(this, DaysView);\n    return _callSuper(this, DaysView, [picker, {\n      id: 0,\n      name: 'days',\n      cellClass: 'day'\n    }]);\n  }\n  _inherits(DaysView, _View);\n  return _createClass(DaysView, [{\n    key: \"init\",\n    value: function init(options) {\n      var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (onConstruction) {\n        var inner = parseHTML(daysTemplate).firstChild;\n        this.dow = inner.firstChild;\n        this.grid = inner.lastChild;\n        this.element.appendChild(inner);\n      }\n      _get(_getPrototypeOf(DaysView.prototype), \"init\", this).call(this, options);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this = this;\n      var updateDOW;\n      if (hasProperty(options, 'minDate')) {\n        this.minDate = options.minDate;\n      }\n      if (hasProperty(options, 'maxDate')) {\n        this.maxDate = options.maxDate;\n      }\n      if (options.datesDisabled) {\n        this.datesDisabled = options.datesDisabled;\n      }\n      if (options.daysOfWeekDisabled) {\n        this.daysOfWeekDisabled = options.daysOfWeekDisabled;\n        updateDOW = true;\n      }\n      if (options.daysOfWeekHighlighted) {\n        this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;\n      }\n      if (options.todayHighlight !== undefined) {\n        this.todayHighlight = options.todayHighlight;\n      }\n      if (options.weekStart !== undefined) {\n        this.weekStart = options.weekStart;\n        this.weekEnd = options.weekEnd;\n        updateDOW = true;\n      }\n      if (options.locale) {\n        var locale = this.locale = options.locale;\n        this.dayNames = locale.daysMin;\n        this.switchLabelFormat = locale.titleFormat;\n        updateDOW = true;\n      }\n      if (options.beforeShowDay !== undefined) {\n        this.beforeShow = typeof options.beforeShowDay === 'function' ? options.beforeShowDay : undefined;\n      }\n      if (options.calendarWeeks !== undefined) {\n        if (options.calendarWeeks && !this.calendarWeeks) {\n          var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;\n          this.calendarWeeks = {\n            element: weeksElem,\n            dow: weeksElem.firstChild,\n            weeks: weeksElem.lastChild\n          };\n          this.element.insertBefore(weeksElem, this.element.firstChild);\n        } else if (this.calendarWeeks && !options.calendarWeeks) {\n          this.element.removeChild(this.calendarWeeks.element);\n          this.calendarWeeks = null;\n        }\n      }\n      if (options.showDaysOfWeek !== undefined) {\n        if (options.showDaysOfWeek) {\n          showElement(this.dow);\n          if (this.calendarWeeks) {\n            showElement(this.calendarWeeks.dow);\n          }\n        } else {\n          hideElement(this.dow);\n          if (this.calendarWeeks) {\n            hideElement(this.calendarWeeks.dow);\n          }\n        }\n      }\n\n      // update days-of-week when locale, daysOfweekDisabled or weekStart is changed\n      if (updateDOW) {\n        Array.from(this.dow.children).forEach(function (el, index) {\n          var dow = (_this.weekStart + index) % 7;\n          el.textContent = _this.dayNames[dow];\n          el.className = _this.daysOfWeekDisabled.includes(dow) ? 'dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed' : 'dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400';\n        });\n      }\n    }\n\n    // Apply update on the focused date to view's settings\n  }, {\n    key: \"updateFocus\",\n    value: function updateFocus() {\n      var viewDate = new Date(this.picker.viewDate);\n      var viewYear = viewDate.getFullYear();\n      var viewMonth = viewDate.getMonth();\n      var firstOfMonth = dateValue(viewYear, viewMonth, 1);\n      var start = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);\n      this.first = firstOfMonth;\n      this.last = dateValue(viewYear, viewMonth + 1, 0);\n      this.start = start;\n      this.focused = this.picker.viewDate;\n    }\n\n    // Apply update on the selected dates to view's settings\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      var _this$picker$datepick = this.picker.datepicker,\n        dates = _this$picker$datepick.dates,\n        rangepicker = _this$picker$datepick.rangepicker;\n      this.selected = dates;\n      if (rangepicker) {\n        this.range = rangepicker.dates;\n      }\n    }\n\n    // Update the entire view UI\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      // update today marker on ever render\n      this.today = this.todayHighlight ? today() : undefined;\n      // refresh disabled dates on every render in order to clear the ones added\n      // by beforeShow hook at previous render\n      this.disabled = _toConsumableArray(this.datesDisabled);\n      var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);\n      this.picker.setViewSwitchLabel(switchLabel);\n      this.picker.setPrevBtnDisabled(this.first <= this.minDate);\n      this.picker.setNextBtnDisabled(this.last >= this.maxDate);\n      if (this.calendarWeeks) {\n        // start of the UTC week (Monday) of the 1st of the month\n        var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);\n        Array.from(this.calendarWeeks.weeks.children).forEach(function (el, index) {\n          el.textContent = getWeek(addWeeks(startOfWeek, index));\n        });\n      }\n      Array.from(this.grid.children).forEach(function (el, index) {\n        var classList = el.classList;\n        var current = addDays(_this2.start, index);\n        var date = new Date(current);\n        var day = date.getDay();\n        el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this2.cellClass);\n        el.dataset.date = current;\n        el.textContent = date.getDate();\n        if (current < _this2.first) {\n          classList.add('prev', 'text-gray-500', 'dark:text-white');\n        } else if (current > _this2.last) {\n          classList.add('next', 'text-gray-500', 'dark:text-white');\n        }\n        if (_this2.today === current) {\n          classList.add('today', 'bg-gray-100', 'dark:bg-gray-600');\n        }\n        if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {\n          classList.add('disabled', 'cursor-not-allowed', 'text-gray-400', 'dark:text-gray-500');\n          classList.remove('hover:bg-gray-100', 'dark:hover:bg-gray-600', 'text-gray-900', 'dark:text-white', 'cursor-pointer');\n        }\n        if (_this2.daysOfWeekDisabled.includes(day)) {\n          classList.add('disabled', 'cursor-not-allowed', 'text-gray-400', 'dark:text-gray-500');\n          classList.remove('hover:bg-gray-100', 'dark:hover:bg-gray-600', 'text-gray-900', 'dark:text-white', 'cursor-pointer');\n          pushUnique(_this2.disabled, current);\n        }\n        if (_this2.daysOfWeekHighlighted.includes(day)) {\n          classList.add('highlighted');\n        }\n        if (_this2.range) {\n          var _this2$range = _slicedToArray(_this2.range, 2),\n            rangeStart = _this2$range[0],\n            rangeEnd = _this2$range[1];\n          if (current > rangeStart && current < rangeEnd) {\n            classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');\n            classList.remove('rounded-lg', 'rounded-l-lg', 'rounded-r-lg');\n          }\n          if (current === rangeStart) {\n            classList.add('range-start', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-l-lg');\n            classList.remove('rounded-lg', 'rounded-r-lg');\n          }\n          if (current === rangeEnd) {\n            classList.add('range-end', 'bg-gray-100', 'dark:bg-gray-600', 'rounded-r-lg');\n            classList.remove('rounded-lg', 'rounded-l-lg');\n          }\n        }\n        if (_this2.selected.includes(current)) {\n          classList.add('selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark:!bg-primary-600', 'dark:text-white');\n          classList.remove('text-gray-900', 'text-gray-500', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600', 'dark:bg-gray-600', 'bg-gray-100', 'bg-gray-200');\n        }\n        if (current === _this2.focused) {\n          classList.add('focused');\n        }\n        if (_this2.beforeShow) {\n          _this2.performBeforeHook(el, current, current);\n        }\n      });\n    }\n\n    // Update the view UI by applying the changes of selected and focused items\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n      var _ref = this.range || [],\n        _ref2 = _slicedToArray(_ref, 2),\n        rangeStart = _ref2[0],\n        rangeEnd = _ref2[1];\n      this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark:!bg-primary-600', 'dark:text-white', 'focused');\n        el.classList.add('text-gray-900', 'rounded-lg', 'dark:text-white');\n      });\n      Array.from(this.grid.children).forEach(function (el) {\n        var current = Number(el.dataset.date);\n        var classList = el.classList;\n        classList.remove('bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg', 'rounded-r-lg');\n        if (current > rangeStart && current < rangeEnd) {\n          classList.add('range', 'bg-gray-200', 'dark:bg-gray-600');\n          classList.remove('rounded-lg');\n        }\n        if (current === rangeStart) {\n          classList.add('range-start', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-l-lg');\n          classList.remove('rounded-lg');\n        }\n        if (current === rangeEnd) {\n          classList.add('range-end', 'bg-gray-200', 'dark:bg-gray-600', 'rounded-r-lg');\n          classList.remove('rounded-lg');\n        }\n        if (_this3.selected.includes(current)) {\n          classList.add('selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark:!bg-primary-600', 'dark:text-white');\n          classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600', 'bg-gray-100', 'bg-gray-200', 'dark:bg-gray-600');\n        }\n        if (current === _this3.focused) {\n          classList.add('focused');\n        }\n      });\n    }\n\n    // Update the view UI by applying the change of focused item\n  }, {\n    key: \"refreshFocus\",\n    value: function refreshFocus() {\n      var index = Math.round((this.focused - this.start) / 86400000);\n      this.grid.querySelectorAll('.focused').forEach(function (el) {\n        el.classList.remove('focused');\n      });\n      this.grid.children[index].classList.add('focused');\n    }\n  }]);\n}(View);\n\nfunction computeMonthRange(range, thisYear) {\n  if (!range || !range[0] || !range[1]) {\n    return;\n  }\n  var _range = _slicedToArray(range, 2),\n    _range$ = _slicedToArray(_range[0], 2),\n    startY = _range$[0],\n    startM = _range$[1],\n    _range$2 = _slicedToArray(_range[1], 2),\n    endY = _range$2[0],\n    endM = _range$2[1];\n  if (startY > thisYear || endY < thisYear) {\n    return;\n  }\n  return [startY === thisYear ? startM : -1, endY === thisYear ? endM : 12];\n}\nvar MonthsView = /*#__PURE__*/function (_View) {\n  function MonthsView(picker) {\n    _classCallCheck(this, MonthsView);\n    return _callSuper(this, MonthsView, [picker, {\n      id: 1,\n      name: 'months',\n      cellClass: 'month'\n    }]);\n  }\n  _inherits(MonthsView, _View);\n  return _createClass(MonthsView, [{\n    key: \"init\",\n    value: function init(options) {\n      var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (onConstruction) {\n        this.grid = this.element;\n        this.element.classList.add('months', 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');\n        this.grid.appendChild(parseHTML(createTagRepeat('span', 12, {\n          'data-month': function dataMonth(ix) {\n            return ix;\n          }\n        })));\n      }\n      _get(_getPrototypeOf(MonthsView.prototype), \"init\", this).call(this, options);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options.locale) {\n        this.monthNames = options.locale.monthsShort;\n      }\n      if (hasProperty(options, 'minDate')) {\n        if (options.minDate === undefined) {\n          this.minYear = this.minMonth = this.minDate = undefined;\n        } else {\n          var minDateObj = new Date(options.minDate);\n          this.minYear = minDateObj.getFullYear();\n          this.minMonth = minDateObj.getMonth();\n          this.minDate = minDateObj.setDate(1);\n        }\n      }\n      if (hasProperty(options, 'maxDate')) {\n        if (options.maxDate === undefined) {\n          this.maxYear = this.maxMonth = this.maxDate = undefined;\n        } else {\n          var maxDateObj = new Date(options.maxDate);\n          this.maxYear = maxDateObj.getFullYear();\n          this.maxMonth = maxDateObj.getMonth();\n          this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);\n        }\n      }\n      if (options.beforeShowMonth !== undefined) {\n        this.beforeShow = typeof options.beforeShowMonth === 'function' ? options.beforeShowMonth : undefined;\n      }\n    }\n\n    // Update view's settings to reflect the viewDate set on the picker\n  }, {\n    key: \"updateFocus\",\n    value: function updateFocus() {\n      var viewDate = new Date(this.picker.viewDate);\n      this.year = viewDate.getFullYear();\n      this.focused = viewDate.getMonth();\n    }\n\n    // Update view's settings to reflect the selected dates\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      var _this$picker$datepick = this.picker.datepicker,\n        dates = _this$picker$datepick.dates,\n        rangepicker = _this$picker$datepick.rangepicker;\n      this.selected = dates.reduce(function (selected, timeValue) {\n        var date = new Date(timeValue);\n        var year = date.getFullYear();\n        var month = date.getMonth();\n        if (selected[year] === undefined) {\n          selected[year] = [month];\n        } else {\n          pushUnique(selected[year], month);\n        }\n        return selected;\n      }, {});\n      if (rangepicker && rangepicker.dates) {\n        this.range = rangepicker.dates.map(function (timeValue) {\n          var date = new Date(timeValue);\n          return isNaN(date) ? undefined : [date.getFullYear(), date.getMonth()];\n        });\n      }\n    }\n\n    // Update the entire view UI\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n      // refresh disabled months on every render in order to clear the ones added\n      // by beforeShow hook at previous render\n      this.disabled = [];\n      this.picker.setViewSwitchLabel(this.year);\n      this.picker.setPrevBtnDisabled(this.year <= this.minYear);\n      this.picker.setNextBtnDisabled(this.year >= this.maxYear);\n      var selected = this.selected[this.year] || [];\n      var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;\n      var isMinYear = this.year === this.minYear;\n      var isMaxYear = this.year === this.maxYear;\n      var range = computeMonthRange(this.range, this.year);\n      Array.from(this.grid.children).forEach(function (el, index) {\n        var classList = el.classList;\n        var date = dateValue(_this.year, index, 1);\n        el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this.cellClass);\n        if (_this.isMinView) {\n          el.dataset.date = date;\n        }\n        // reset text on every render to clear the custom content set\n        // by beforeShow hook at previous render\n        el.textContent = _this.monthNames[index];\n        if (yrOutOfRange || isMinYear && index < _this.minMonth || isMaxYear && index > _this.maxMonth) {\n          classList.add('disabled');\n        }\n        if (range) {\n          var _range2 = _slicedToArray(range, 2),\n            rangeStart = _range2[0],\n            rangeEnd = _range2[1];\n          if (index > rangeStart && index < rangeEnd) {\n            classList.add('range');\n          }\n          if (index === rangeStart) {\n            classList.add('range-start');\n          }\n          if (index === rangeEnd) {\n            classList.add('range-end');\n          }\n        }\n        if (selected.includes(index)) {\n          classList.add('selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark:!bg-primary-600', 'dark:text-white');\n          classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n        }\n        if (index === _this.focused) {\n          classList.add('focused');\n        }\n        if (_this.beforeShow) {\n          _this.performBeforeHook(el, index, date);\n        }\n      });\n    }\n\n    // Update the view UI by applying the changes of selected and focused items\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this2 = this;\n      var selected = this.selected[this.year] || [];\n      var _ref = computeMonthRange(this.range, this.year) || [],\n        _ref2 = _slicedToArray(_ref, 2),\n        rangeStart = _ref2[0],\n        rangeEnd = _ref2[1];\n      this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', '!bg-primary-700', 'dark:bg-blue-600', 'dark:!bg-primary-700', 'dark:text-white', 'text-white', 'focused');\n        el.classList.add('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n      });\n      Array.from(this.grid.children).forEach(function (el, index) {\n        var classList = el.classList;\n        if (index > rangeStart && index < rangeEnd) {\n          classList.add('range');\n        }\n        if (index === rangeStart) {\n          classList.add('range-start');\n        }\n        if (index === rangeEnd) {\n          classList.add('range-end');\n        }\n        if (selected.includes(index)) {\n          classList.add('selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark:!bg-primary-600', 'dark:text-white');\n          classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n        }\n        if (index === _this2.focused) {\n          classList.add('focused');\n        }\n      });\n    }\n\n    // Update the view UI by applying the change of focused item\n  }, {\n    key: \"refreshFocus\",\n    value: function refreshFocus() {\n      this.grid.querySelectorAll('.focused').forEach(function (el) {\n        el.classList.remove('focused');\n      });\n      this.grid.children[this.focused].classList.add('focused');\n    }\n  }]);\n}(View);\n\nfunction toTitleCase(word) {\n  return _toConsumableArray(word).reduce(function (str, ch, ix) {\n    return str += ix ? ch : ch.toUpperCase();\n  }, '');\n}\n\n// Class representing the years and decades view elements\nvar YearsView = /*#__PURE__*/function (_View) {\n  function YearsView(picker, config) {\n    _classCallCheck(this, YearsView);\n    return _callSuper(this, YearsView, [picker, config]);\n  }\n  _inherits(YearsView, _View);\n  return _createClass(YearsView, [{\n    key: \"init\",\n    value: function init(options) {\n      var onConstruction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (onConstruction) {\n        this.navStep = this.step * 10;\n        this.beforeShowOption = \"beforeShow\".concat(toTitleCase(this.cellClass));\n        this.grid = this.element;\n        this.element.classList.add(this.name, 'datepicker-grid', 'w-64', 'grid', 'grid-cols-4');\n        this.grid.appendChild(parseHTML(createTagRepeat('span', 12)));\n      }\n      _get(_getPrototypeOf(YearsView.prototype), \"init\", this).call(this, options);\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (hasProperty(options, 'minDate')) {\n        if (options.minDate === undefined) {\n          this.minYear = this.minDate = undefined;\n        } else {\n          this.minYear = startOfYearPeriod(options.minDate, this.step);\n          this.minDate = dateValue(this.minYear, 0, 1);\n        }\n      }\n      if (hasProperty(options, 'maxDate')) {\n        if (options.maxDate === undefined) {\n          this.maxYear = this.maxDate = undefined;\n        } else {\n          this.maxYear = startOfYearPeriod(options.maxDate, this.step);\n          this.maxDate = dateValue(this.maxYear, 11, 31);\n        }\n      }\n      if (options[this.beforeShowOption] !== undefined) {\n        var beforeShow = options[this.beforeShowOption];\n        this.beforeShow = typeof beforeShow === 'function' ? beforeShow : undefined;\n      }\n    }\n\n    // Update view's settings to reflect the viewDate set on the picker\n  }, {\n    key: \"updateFocus\",\n    value: function updateFocus() {\n      var viewDate = new Date(this.picker.viewDate);\n      var first = startOfYearPeriod(viewDate, this.navStep);\n      var last = first + 9 * this.step;\n      this.first = first;\n      this.last = last;\n      this.start = first - this.step;\n      this.focused = startOfYearPeriod(viewDate, this.step);\n    }\n\n    // Update view's settings to reflect the selected dates\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      var _this = this;\n      var _this$picker$datepick = this.picker.datepicker,\n        dates = _this$picker$datepick.dates,\n        rangepicker = _this$picker$datepick.rangepicker;\n      this.selected = dates.reduce(function (years, timeValue) {\n        return pushUnique(years, startOfYearPeriod(timeValue, _this.step));\n      }, []);\n      if (rangepicker && rangepicker.dates) {\n        this.range = rangepicker.dates.map(function (timeValue) {\n          if (timeValue !== undefined) {\n            return startOfYearPeriod(timeValue, _this.step);\n          }\n        });\n      }\n    }\n\n    // Update the entire view UI\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      // refresh disabled years on every render in order to clear the ones added\n      // by beforeShow hook at previous render\n      this.disabled = [];\n      this.picker.setViewSwitchLabel(\"\".concat(this.first, \"-\").concat(this.last));\n      this.picker.setPrevBtnDisabled(this.first <= this.minYear);\n      this.picker.setNextBtnDisabled(this.last >= this.maxYear);\n      Array.from(this.grid.children).forEach(function (el, index) {\n        var classList = el.classList;\n        var current = _this2.start + index * _this2.step;\n        var date = dateValue(current, 0, 1);\n        el.className = \"datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm \".concat(_this2.cellClass);\n        if (_this2.isMinView) {\n          el.dataset.date = date;\n        }\n        el.textContent = el.dataset.year = current;\n        if (index === 0) {\n          classList.add('prev');\n        } else if (index === 11) {\n          classList.add('next');\n        }\n        if (current < _this2.minYear || current > _this2.maxYear) {\n          classList.add('disabled');\n        }\n        if (_this2.range) {\n          var _this2$range = _slicedToArray(_this2.range, 2),\n            rangeStart = _this2$range[0],\n            rangeEnd = _this2$range[1];\n          if (current > rangeStart && current < rangeEnd) {\n            classList.add('range');\n          }\n          if (current === rangeStart) {\n            classList.add('range-start');\n          }\n          if (current === rangeEnd) {\n            classList.add('range-end');\n          }\n        }\n        if (_this2.selected.includes(current)) {\n          classList.add('selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark:!bg-primary-600', 'dark:text-white');\n          classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n        }\n        if (current === _this2.focused) {\n          classList.add('focused');\n        }\n        if (_this2.beforeShow) {\n          _this2.performBeforeHook(el, current, date);\n        }\n      });\n    }\n\n    // Update the view UI by applying the changes of selected and focused items\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n      var _ref = this.range || [],\n        _ref2 = _slicedToArray(_ref, 2),\n        rangeStart = _ref2[0],\n        rangeEnd = _ref2[1];\n      this.grid.querySelectorAll('.range, .range-start, .range-end, .selected, .focused').forEach(function (el) {\n        el.classList.remove('range', 'range-start', 'range-end', 'selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark!bg-primary-600', 'dark:text-white', 'focused');\n      });\n      Array.from(this.grid.children).forEach(function (el) {\n        var current = Number(el.textContent);\n        var classList = el.classList;\n        if (current > rangeStart && current < rangeEnd) {\n          classList.add('range');\n        }\n        if (current === rangeStart) {\n          classList.add('range-start');\n        }\n        if (current === rangeEnd) {\n          classList.add('range-end');\n        }\n        if (_this3.selected.includes(current)) {\n          classList.add('selected', 'bg-blue-700', '!bg-primary-700', 'text-white', 'dark:bg-blue-600', 'dark:!bg-primary-600', 'dark:text-white');\n          classList.remove('text-gray-900', 'hover:bg-gray-100', 'dark:text-white', 'dark:hover:bg-gray-600');\n        }\n        if (current === _this3.focused) {\n          classList.add('focused');\n        }\n      });\n    }\n\n    // Update the view UI by applying the change of focused item\n  }, {\n    key: \"refreshFocus\",\n    value: function refreshFocus() {\n      var index = Math.round((this.focused - this.start) / this.step);\n      this.grid.querySelectorAll('.focused').forEach(function (el) {\n        el.classList.remove('focused');\n      });\n      this.grid.children[index].classList.add('focused');\n    }\n  }]);\n}(View);\n\nfunction triggerDatepickerEvent(datepicker, type) {\n  var detail = {\n    date: datepicker.getDate(),\n    viewDate: new Date(datepicker.picker.viewDate),\n    viewId: datepicker.picker.currentView.id,\n    datepicker: datepicker\n  };\n  datepicker.element.dispatchEvent(new CustomEvent(type, {\n    detail: detail\n  }));\n}\n\n// direction: -1 (to previous), 1 (to next)\nfunction goToPrevOrNext(datepicker, direction) {\n  var _datepicker$config = datepicker.config,\n    minDate = _datepicker$config.minDate,\n    maxDate = _datepicker$config.maxDate;\n  var _datepicker$picker = datepicker.picker,\n    currentView = _datepicker$picker.currentView,\n    viewDate = _datepicker$picker.viewDate;\n  var newViewDate;\n  switch (currentView.id) {\n    case 0:\n      newViewDate = addMonths(viewDate, direction);\n      break;\n    case 1:\n      newViewDate = addYears(viewDate, direction);\n      break;\n    default:\n      newViewDate = addYears(viewDate, direction * currentView.navStep);\n  }\n  newViewDate = limitToRange(newViewDate, minDate, maxDate);\n  datepicker.picker.changeFocus(newViewDate).render();\n}\nfunction switchView(datepicker) {\n  var viewId = datepicker.picker.currentView.id;\n  if (viewId === datepicker.config.maxView) {\n    return;\n  }\n  datepicker.picker.changeView(viewId + 1).render();\n}\nfunction unfocus(datepicker) {\n  if (datepicker.config.updateOnBlur) {\n    datepicker.update({\n      autohide: true\n    });\n  } else {\n    datepicker.refresh('input');\n    datepicker.hide();\n  }\n}\n\nfunction goToSelectedMonthOrYear(datepicker, selection) {\n  var picker = datepicker.picker;\n  var viewDate = new Date(picker.viewDate);\n  var viewId = picker.currentView.id;\n  var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());\n  picker.changeFocus(newDate).changeView(viewId - 1).render();\n}\nfunction onClickTodayBtn(datepicker) {\n  var picker = datepicker.picker;\n  var currentDate = today();\n  if (datepicker.config.todayBtnMode === 1) {\n    if (datepicker.config.autohide) {\n      datepicker.setDate(currentDate);\n      return;\n    }\n    datepicker.setDate(currentDate, {\n      render: false\n    });\n    picker.update();\n  }\n  if (picker.viewDate !== currentDate) {\n    picker.changeFocus(currentDate);\n  }\n  picker.changeView(0).render();\n}\nfunction onClickClearBtn(datepicker) {\n  datepicker.setDate({\n    clear: true\n  });\n}\nfunction onClickViewSwitch(datepicker) {\n  switchView(datepicker);\n}\nfunction onClickPrevBtn(datepicker) {\n  goToPrevOrNext(datepicker, -1);\n}\nfunction onClickNextBtn(datepicker) {\n  goToPrevOrNext(datepicker, 1);\n}\n\n// For the picker's main block to delegete the events from `datepicker-cell`s\nfunction onClickView(datepicker, ev) {\n  var target = findElementInEventPath(ev, '.datepicker-cell');\n  if (!target || target.classList.contains('disabled')) {\n    return;\n  }\n  var _datepicker$picker$cu = datepicker.picker.currentView,\n    id = _datepicker$picker$cu.id,\n    isMinView = _datepicker$picker$cu.isMinView;\n  if (isMinView) {\n    datepicker.setDate(Number(target.dataset.date));\n  } else if (id === 1) {\n    goToSelectedMonthOrYear(datepicker, Number(target.dataset.month));\n  } else {\n    goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));\n  }\n}\nfunction onClickPicker(datepicker) {\n  if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) {\n    datepicker.inputField.focus();\n  }\n}\n\nfunction processPickerOptions(picker, options) {\n  if (options.title !== undefined) {\n    if (options.title) {\n      picker.controls.title.textContent = options.title;\n      showElement(picker.controls.title);\n    } else {\n      picker.controls.title.textContent = '';\n      hideElement(picker.controls.title);\n    }\n  }\n  if (options.prevArrow) {\n    var prevBtn = picker.controls.prevBtn;\n    emptyChildNodes(prevBtn);\n    options.prevArrow.forEach(function (node) {\n      prevBtn.appendChild(node.cloneNode(true));\n    });\n  }\n  if (options.nextArrow) {\n    var nextBtn = picker.controls.nextBtn;\n    emptyChildNodes(nextBtn);\n    options.nextArrow.forEach(function (node) {\n      nextBtn.appendChild(node.cloneNode(true));\n    });\n  }\n  if (options.locale) {\n    picker.controls.todayBtn.textContent = options.locale.today;\n    picker.controls.clearBtn.textContent = options.locale.clear;\n  }\n  if (options.todayBtn !== undefined) {\n    if (options.todayBtn) {\n      showElement(picker.controls.todayBtn);\n    } else {\n      hideElement(picker.controls.todayBtn);\n    }\n  }\n  if (hasProperty(options, 'minDate') || hasProperty(options, 'maxDate')) {\n    var _picker$datepicker$co = picker.datepicker.config,\n      minDate = _picker$datepicker$co.minDate,\n      maxDate = _picker$datepicker$co.maxDate;\n    picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);\n  }\n  if (options.clearBtn !== undefined) {\n    if (options.clearBtn) {\n      showElement(picker.controls.clearBtn);\n    } else {\n      hideElement(picker.controls.clearBtn);\n    }\n  }\n}\n\n// Compute view date to reset, which will be...\n// - the last item of the selected dates or defaultViewDate if no selection\n// - limitted to minDate or maxDate if it exceeds the range\nfunction computeResetViewDate(datepicker) {\n  var dates = datepicker.dates,\n    config = datepicker.config;\n  var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;\n  return limitToRange(viewDate, config.minDate, config.maxDate);\n}\n\n// Change current view's view date\nfunction setViewDate(picker, newDate) {\n  var oldViewDate = new Date(picker.viewDate);\n  var newViewDate = new Date(newDate);\n  var _picker$currentView = picker.currentView,\n    id = _picker$currentView.id,\n    year = _picker$currentView.year,\n    first = _picker$currentView.first,\n    last = _picker$currentView.last;\n  var viewYear = newViewDate.getFullYear();\n  picker.viewDate = newDate;\n  if (viewYear !== oldViewDate.getFullYear()) {\n    triggerDatepickerEvent(picker.datepicker, 'changeYear');\n  }\n  if (newViewDate.getMonth() !== oldViewDate.getMonth()) {\n    triggerDatepickerEvent(picker.datepicker, 'changeMonth');\n  }\n\n  // return whether the new date is in different period on time from the one\n  // displayed in the current view\n  // when true, the view needs to be re-rendered on the next UI refresh.\n  switch (id) {\n    case 0:\n      return newDate < first || newDate > last;\n    case 1:\n      return viewYear !== year;\n    default:\n      return viewYear < first || viewYear > last;\n  }\n}\nfunction getTextDirection(el) {\n  return window.getComputedStyle(el).direction;\n}\n\n// Class representing the picker UI\nvar Picker = /*#__PURE__*/function () {\n  function Picker(datepicker) {\n    _classCallCheck(this, Picker);\n    this.datepicker = datepicker;\n    var template = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);\n    var element = this.element = parseHTML(template).firstChild;\n    var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3),\n      header = _element$firstChild$c[0],\n      main = _element$firstChild$c[1],\n      footer = _element$firstChild$c[2];\n    var title = header.firstElementChild;\n    var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3),\n      prevBtn = _header$lastElementCh[0],\n      viewSwitch = _header$lastElementCh[1],\n      nextBtn = _header$lastElementCh[2];\n    var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2),\n      todayBtn = _footer$firstChild$ch[0],\n      clearBtn = _footer$firstChild$ch[1];\n    var controls = {\n      title: title,\n      prevBtn: prevBtn,\n      viewSwitch: viewSwitch,\n      nextBtn: nextBtn,\n      todayBtn: todayBtn,\n      clearBtn: clearBtn\n    };\n    this.main = main;\n    this.controls = controls;\n    var elementClass = datepicker.inline ? 'inline' : 'dropdown';\n    element.classList.add(\"datepicker-\".concat(elementClass));\n    elementClass === 'dropdown' ? element.classList.add('dropdown', 'absolute', 'top-0', 'left-0', 'z-50', 'pt-2') : null;\n    processPickerOptions(this, datepicker.config);\n    this.viewDate = computeResetViewDate(datepicker);\n\n    // set up event listeners\n    registerListeners(datepicker, [[element, 'click', onClickPicker.bind(null, datepicker), {\n      capture: true\n    }], [main, 'click', onClickView.bind(null, datepicker)], [controls.viewSwitch, 'click', onClickViewSwitch.bind(null, datepicker)], [controls.prevBtn, 'click', onClickPrevBtn.bind(null, datepicker)], [controls.nextBtn, 'click', onClickNextBtn.bind(null, datepicker)], [controls.todayBtn, 'click', onClickTodayBtn.bind(null, datepicker)], [controls.clearBtn, 'click', onClickClearBtn.bind(null, datepicker)]]);\n\n    // set up views\n    this.views = [new DaysView(this), new MonthsView(this), new YearsView(this, {\n      id: 2,\n      name: 'years',\n      cellClass: 'year',\n      step: 1\n    }), new YearsView(this, {\n      id: 3,\n      name: 'decades',\n      cellClass: 'decade',\n      step: 10\n    })];\n    this.currentView = this.views[datepicker.config.startView];\n    this.currentView.render();\n    this.main.appendChild(this.currentView.element);\n    datepicker.config.container.appendChild(this.element);\n  }\n  return _createClass(Picker, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      processPickerOptions(this, options);\n      this.views.forEach(function (view) {\n        view.init(options, false);\n      });\n      this.currentView.render();\n    }\n  }, {\n    key: \"detach\",\n    value: function detach() {\n      this.datepicker.config.container.removeChild(this.element);\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.active) {\n        return;\n      }\n      this.element.classList.add('active', 'block');\n      this.element.classList.remove('hidden');\n      this.active = true;\n      var datepicker = this.datepicker;\n      if (!datepicker.inline) {\n        // ensure picker's direction matches input's\n        var inputDirection = getTextDirection(datepicker.inputField);\n        if (inputDirection !== getTextDirection(datepicker.config.container)) {\n          this.element.dir = inputDirection;\n        } else if (this.element.dir) {\n          this.element.removeAttribute('dir');\n        }\n        this.place();\n        if (datepicker.config.disableTouchKeyboard) {\n          datepicker.inputField.blur();\n        }\n      }\n      triggerDatepickerEvent(datepicker, 'show');\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (!this.active) {\n        return;\n      }\n      this.datepicker.exitEditMode();\n      this.element.classList.remove('active', 'block');\n      this.element.classList.add('active', 'block', 'hidden');\n      this.active = false;\n      triggerDatepickerEvent(this.datepicker, 'hide');\n    }\n  }, {\n    key: \"place\",\n    value: function place() {\n      var _this$element = this.element,\n        classList = _this$element.classList,\n        style = _this$element.style;\n      var _this$datepicker = this.datepicker,\n        config = _this$datepicker.config,\n        inputField = _this$datepicker.inputField;\n      var container = config.container;\n      var _this$element$getBoun = this.element.getBoundingClientRect(),\n        calendarWidth = _this$element$getBoun.width,\n        calendarHeight = _this$element$getBoun.height;\n      var _container$getBoundin = container.getBoundingClientRect(),\n        containerLeft = _container$getBoundin.left,\n        containerTop = _container$getBoundin.top,\n        containerWidth = _container$getBoundin.width;\n      var _inputField$getBoundi = inputField.getBoundingClientRect(),\n        inputLeft = _inputField$getBoundi.left,\n        inputTop = _inputField$getBoundi.top,\n        inputWidth = _inputField$getBoundi.width,\n        inputHeight = _inputField$getBoundi.height;\n      var _config$orientation = config.orientation,\n        orientX = _config$orientation.x,\n        orientY = _config$orientation.y;\n      var scrollTop;\n      var left;\n      var top;\n      if (container === document.body) {\n        scrollTop = window.scrollY;\n        left = inputLeft + window.scrollX;\n        top = inputTop + scrollTop;\n      } else {\n        scrollTop = container.scrollTop;\n        left = inputLeft - containerLeft;\n        top = inputTop - containerTop + scrollTop;\n      }\n      if (orientX === 'auto') {\n        if (left < 0) {\n          // align to the left and move into visible area if input's left edge < window's\n          orientX = 'left';\n          left = 10;\n        } else if (left + calendarWidth > containerWidth) {\n          // align to the right if canlendar's right edge > container's\n          orientX = 'right';\n        } else {\n          orientX = getTextDirection(inputField) === 'rtl' ? 'right' : 'left';\n        }\n      }\n      if (orientX === 'right') {\n        left -= calendarWidth - inputWidth;\n      }\n      if (orientY === 'auto') {\n        orientY = top - calendarHeight < scrollTop ? 'bottom' : 'top';\n      }\n      if (orientY === 'top') {\n        top -= calendarHeight;\n      } else {\n        top += inputHeight;\n      }\n      classList.remove('datepicker-orient-top', 'datepicker-orient-bottom', 'datepicker-orient-right', 'datepicker-orient-left');\n      classList.add(\"datepicker-orient-\".concat(orientY), \"datepicker-orient-\".concat(orientX));\n      style.top = top ? \"\".concat(top, \"px\") : top;\n      style.left = left ? \"\".concat(left, \"px\") : left;\n    }\n  }, {\n    key: \"setViewSwitchLabel\",\n    value: function setViewSwitchLabel(labelText) {\n      this.controls.viewSwitch.textContent = labelText;\n    }\n  }, {\n    key: \"setPrevBtnDisabled\",\n    value: function setPrevBtnDisabled(disabled) {\n      this.controls.prevBtn.disabled = disabled;\n    }\n  }, {\n    key: \"setNextBtnDisabled\",\n    value: function setNextBtnDisabled(disabled) {\n      this.controls.nextBtn.disabled = disabled;\n    }\n  }, {\n    key: \"changeView\",\n    value: function changeView(viewId) {\n      var oldView = this.currentView;\n      var newView = this.views[viewId];\n      if (newView.id !== oldView.id) {\n        this.currentView = newView;\n        this._renderMethod = 'render';\n        triggerDatepickerEvent(this.datepicker, 'changeView');\n        this.main.replaceChild(newView.element, oldView.element);\n      }\n      return this;\n    }\n\n    // Change the focused date (view date)\n  }, {\n    key: \"changeFocus\",\n    value: function changeFocus(newViewDate) {\n      this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refreshFocus';\n      this.views.forEach(function (view) {\n        view.updateFocus();\n      });\n      return this;\n    }\n\n    // Apply the change of the selected dates\n  }, {\n    key: \"update\",\n    value: function update() {\n      var newViewDate = computeResetViewDate(this.datepicker);\n      this._renderMethod = setViewDate(this, newViewDate) ? 'render' : 'refresh';\n      this.views.forEach(function (view) {\n        view.updateFocus();\n        view.updateSelection();\n      });\n      return this;\n    }\n\n    // Refresh the picker UI\n  }, {\n    key: \"render\",\n    value: function render() {\n      var quickRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var renderMethod = quickRender && this._renderMethod || 'render';\n      delete this._renderMethod;\n      this.currentView[renderMethod]();\n    }\n  }]);\n}();\n\n// Find the closest date that doesn't meet the condition for unavailable date\n// Returns undefined if no available date is found\n// addFn: function to calculate the next date\n//   - args: time value, amount\n// increase: amount to pass to addFn\n// testFn: function to test the unavailablity of the date\n//   - args: time value; retun: true if unavailable\nfunction findNextAvailableOne(date, addFn, increase, testFn, min, max) {\n  if (!isInRange(date, min, max)) {\n    return;\n  }\n  if (testFn(date)) {\n    var newDate = addFn(date, increase);\n    return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);\n  }\n  return date;\n}\n\n// direction: -1 (left/up), 1 (right/down)\n// vertical: true for up/down, false for left/right\nfunction moveByArrowKey(datepicker, ev, direction, vertical) {\n  var picker = datepicker.picker;\n  var currentView = picker.currentView;\n  var step = currentView.step || 1;\n  var viewDate = picker.viewDate;\n  var addFn;\n  var testFn;\n  switch (currentView.id) {\n    case 0:\n      if (vertical) {\n        viewDate = addDays(viewDate, direction * 7);\n      } else if (ev.ctrlKey || ev.metaKey) {\n        viewDate = addYears(viewDate, direction);\n      } else {\n        viewDate = addDays(viewDate, direction);\n      }\n      addFn = addDays;\n      testFn = function testFn(date) {\n        return currentView.disabled.includes(date);\n      };\n      break;\n    case 1:\n      viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);\n      addFn = addMonths;\n      testFn = function testFn(date) {\n        var dt = new Date(date);\n        var year = currentView.year,\n          disabled = currentView.disabled;\n        return dt.getFullYear() === year && disabled.includes(dt.getMonth());\n      };\n      break;\n    default:\n      viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);\n      addFn = addYears;\n      testFn = function testFn(date) {\n        return currentView.disabled.includes(startOfYearPeriod(date, step));\n      };\n  }\n  viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);\n  if (viewDate !== undefined) {\n    picker.changeFocus(viewDate).render();\n  }\n}\nfunction onKeydown(datepicker, ev) {\n  if (ev.key === 'Tab') {\n    unfocus(datepicker);\n    return;\n  }\n  var picker = datepicker.picker;\n  var _picker$currentView = picker.currentView,\n    id = _picker$currentView.id,\n    isMinView = _picker$currentView.isMinView;\n  if (!picker.active) {\n    switch (ev.key) {\n      case 'ArrowDown':\n      case 'Escape':\n        picker.show();\n        break;\n      case 'Enter':\n        datepicker.update();\n        break;\n      default:\n        return;\n    }\n  } else if (datepicker.editMode) {\n    switch (ev.key) {\n      case 'Escape':\n        picker.hide();\n        break;\n      case 'Enter':\n        datepicker.exitEditMode({\n          update: true,\n          autohide: datepicker.config.autohide\n        });\n        break;\n      default:\n        return;\n    }\n  } else {\n    switch (ev.key) {\n      case 'Escape':\n        picker.hide();\n        break;\n      case 'ArrowLeft':\n        if (ev.ctrlKey || ev.metaKey) {\n          goToPrevOrNext(datepicker, -1);\n        } else if (ev.shiftKey) {\n          datepicker.enterEditMode();\n          return;\n        } else {\n          moveByArrowKey(datepicker, ev, -1, false);\n        }\n        break;\n      case 'ArrowRight':\n        if (ev.ctrlKey || ev.metaKey) {\n          goToPrevOrNext(datepicker, 1);\n        } else if (ev.shiftKey) {\n          datepicker.enterEditMode();\n          return;\n        } else {\n          moveByArrowKey(datepicker, ev, 1, false);\n        }\n        break;\n      case 'ArrowUp':\n        if (ev.ctrlKey || ev.metaKey) {\n          switchView(datepicker);\n        } else if (ev.shiftKey) {\n          datepicker.enterEditMode();\n          return;\n        } else {\n          moveByArrowKey(datepicker, ev, -1, true);\n        }\n        break;\n      case 'ArrowDown':\n        if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {\n          datepicker.enterEditMode();\n          return;\n        }\n        moveByArrowKey(datepicker, ev, 1, true);\n        break;\n      case 'Enter':\n        if (isMinView) {\n          datepicker.setDate(picker.viewDate);\n        } else {\n          picker.changeView(id - 1).render();\n        }\n        break;\n      case 'Backspace':\n      case 'Delete':\n        datepicker.enterEditMode();\n        return;\n      default:\n        if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) {\n          datepicker.enterEditMode();\n        }\n        return;\n    }\n  }\n  ev.preventDefault();\n  ev.stopPropagation();\n}\nfunction onFocus(datepicker) {\n  if (datepicker.config.showOnFocus && !datepicker._showing) {\n    datepicker.show();\n  }\n}\n\n// for the prevention for entering edit mode while getting focus on click\nfunction onMousedown(datepicker, ev) {\n  var el = ev.target;\n  if (datepicker.picker.active || datepicker.config.showOnClick) {\n    el._active = el === document.activeElement;\n    el._clicking = setTimeout(function () {\n      delete el._active;\n      delete el._clicking;\n    }, 2000);\n  }\n}\nfunction onClickInput(datepicker, ev) {\n  var el = ev.target;\n  if (!el._clicking) {\n    return;\n  }\n  clearTimeout(el._clicking);\n  delete el._clicking;\n  if (el._active) {\n    datepicker.enterEditMode();\n  }\n  delete el._active;\n  if (datepicker.config.showOnClick) {\n    datepicker.show();\n  }\n}\nfunction onPaste(datepicker, ev) {\n  if (ev.clipboardData.types.includes('text/plain')) {\n    datepicker.enterEditMode();\n  }\n}\n\n// for the `document` to delegate the events from outside the picker/input field\nfunction onClickOutside(datepicker, ev) {\n  var element = datepicker.element;\n  if (element !== document.activeElement) {\n    return;\n  }\n  var pickerElem = datepicker.picker.element;\n  if (findElementInEventPath(ev, function (el) {\n    return el === element || el === pickerElem;\n  })) {\n    return;\n  }\n  unfocus(datepicker);\n}\n\nfunction stringifyDates(dates, config) {\n  return dates.map(function (dt) {\n    return formatDate(dt, config.format, config.locale);\n  }).join(config.dateDelimiter);\n}\n\n// parse input dates and create an array of time values for selection\n// returns undefined if there are no valid dates in inputDates\n// when origDates (current selection) is passed, the function works to mix\n// the input dates into the current selection\nfunction processInputDates(datepicker, inputDates) {\n  var clear = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var config = datepicker.config,\n    origDates = datepicker.dates,\n    rangepicker = datepicker.rangepicker;\n  if (inputDates.length === 0) {\n    // empty input is considered valid unless origiDates is passed\n    return clear ? [] : undefined;\n  }\n  var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];\n  var newDates = inputDates.reduce(function (dates, dt) {\n    var date = parseDate(dt, config.format, config.locale);\n    if (date === undefined) {\n      return dates;\n    }\n    if (config.pickLevel > 0) {\n      // adjust to 1st of the month/Jan 1st of the year\n      // or to the last day of the monh/Dec 31st of the year if the datepicker\n      // is the range-end picker of a rangepicker\n      var _dt = new Date(date);\n      if (config.pickLevel === 1) {\n        date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1);\n      } else {\n        date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);\n      }\n    }\n    if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) {\n      dates.push(date);\n    }\n    return dates;\n  }, []);\n  if (newDates.length === 0) {\n    return;\n  }\n  if (config.multidate && !clear) {\n    // get the synmetric difference between origDates and newDates\n    newDates = newDates.reduce(function (dates, date) {\n      if (!origDates.includes(date)) {\n        dates.push(date);\n      }\n      return dates;\n    }, origDates.filter(function (date) {\n      return !newDates.includes(date);\n    }));\n  }\n  // do length check always because user can input multiple dates regardless of the mode\n  return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;\n}\n\n// refresh the UI elements\n// modes: 1: input only, 2, picker only, 3 both\nfunction refreshUI(datepicker) {\n  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  var quickRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var config = datepicker.config,\n    picker = datepicker.picker,\n    inputField = datepicker.inputField;\n  if (mode & 2) {\n    var newView = picker.active ? config.pickLevel : config.startView;\n    picker.update().changeView(newView).render(quickRender);\n  }\n  if (mode & 1 && inputField) {\n    inputField.value = stringifyDates(datepicker.dates, config);\n  }\n}\nfunction _setDate(datepicker, inputDates, options) {\n  var clear = options.clear,\n    render = options.render,\n    autohide = options.autohide;\n  if (render === undefined) {\n    render = true;\n  }\n  if (!render) {\n    autohide = false;\n  } else if (autohide === undefined) {\n    autohide = datepicker.config.autohide;\n  }\n  var newDates = processInputDates(datepicker, inputDates, clear);\n  if (!newDates) {\n    return;\n  }\n  if (newDates.toString() !== datepicker.dates.toString()) {\n    datepicker.dates = newDates;\n    refreshUI(datepicker, render ? 3 : 1);\n    triggerDatepickerEvent(datepicker, 'changeDate');\n  } else {\n    refreshUI(datepicker, 1);\n  }\n  if (autohide) {\n    datepicker.hide();\n  }\n}\n\n/**\n * Class representing a date picker\n */\nvar main_esm_Datepicker = /*#__PURE__*/function () {\n  /**\n   * Create a date picker\n   * @param  {Element} element - element to bind a date picker\n   * @param  {Object} [options] - config options\n   * @param  {DateRangePicker} [rangepicker] - DateRangePicker instance the\n   * date picker belongs to. Use this only when creating date picker as a part\n   * of date range picker\n   */\n  function Datepicker(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var rangepicker = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    _classCallCheck(this, Datepicker);\n    element.datepicker = this;\n    this.element = element;\n\n    // set up config\n    var config = this.config = Object.assign({\n      buttonClass: options.buttonClass && String(options.buttonClass) || 'button',\n      container: document.body,\n      defaultViewDate: today(),\n      maxDate: undefined,\n      minDate: undefined\n    }, processOptions(defaultOptions, this));\n    this._options = options;\n    Object.assign(config, processOptions(options, this));\n\n    // configure by type\n    var inline = this.inline = element.tagName !== 'INPUT';\n    var inputField;\n    var initialDates;\n    if (inline) {\n      config.container = element;\n      initialDates = stringToArray(element.dataset.date, config.dateDelimiter);\n      delete element.dataset.date;\n    } else {\n      var container = options.container ? document.querySelector(options.container) : null;\n      if (container) {\n        config.container = container;\n      }\n      inputField = this.inputField = element;\n      inputField.classList.add('datepicker-input');\n      initialDates = stringToArray(inputField.value, config.dateDelimiter);\n    }\n    if (rangepicker) {\n      // check validiry\n      var index = rangepicker.inputs.indexOf(inputField);\n      var datepickers = rangepicker.datepickers;\n      if (index < 0 || index > 1 || !Array.isArray(datepickers)) {\n        throw Error('Invalid rangepicker object.');\n      }\n      // attach itaelf to the rangepicker here so that processInputDates() can\n      // determine if this is the range-end picker of the rangepicker while\n      // setting inital values when pickLevel > 0\n      datepickers[index] = this;\n      // add getter for rangepicker\n      Object.defineProperty(this, 'rangepicker', {\n        get: function get() {\n          return rangepicker;\n        }\n      });\n    }\n\n    // set initial dates\n    this.dates = [];\n    // process initial value\n    var inputDateValues = processInputDates(this, initialDates);\n    if (inputDateValues && inputDateValues.length > 0) {\n      this.dates = inputDateValues;\n    }\n    if (inputField) {\n      inputField.value = stringifyDates(this.dates, config);\n    }\n    var picker = this.picker = new Picker(this);\n    if (inline) {\n      this.show();\n    } else {\n      // set up event listeners in other modes\n      var onMousedownDocument = onClickOutside.bind(null, this);\n      var listeners = [[inputField, 'keydown', onKeydown.bind(null, this)], [inputField, 'focus', onFocus.bind(null, this)], [inputField, 'mousedown', onMousedown.bind(null, this)], [inputField, 'click', onClickInput.bind(null, this)], [inputField, 'paste', onPaste.bind(null, this)], [document, 'mousedown', onMousedownDocument], [document, 'touchstart', onMousedownDocument], [window, 'resize', picker.place.bind(picker)]];\n      registerListeners(this, listeners);\n    }\n  }\n\n  /**\n   * Format Date object or time value in given format and language\n   * @param  {Date|Number} date - date or time value to format\n   * @param  {String|Object} format - format string or object that contains\n   * toDisplay() custom formatter, whose signature is\n   * - args:\n   *   - date: {Date} - Date instance of the date passed to the method\n   *   - format: {Object} - the format object passed to the method\n   *   - locale: {Object} - locale for the language specified by `lang`\n   * - return:\n   *     {String} formatted date\n   * @param  {String} [lang=en] - language code for the locale to use\n   * @return {String} formatted date\n   */\n  return _createClass(Datepicker, [{\n    key: \"active\",\n    get:\n    /**\n     * @type {Boolean} - Whether the picker element is shown. `true` whne shown\n     */\n    function get() {\n      return !!(this.picker && this.picker.active);\n    }\n\n    /**\n     * @type {HTMLDivElement} - DOM object of picker element\n     */\n  }, {\n    key: \"pickerElement\",\n    get: function get() {\n      return this.picker ? this.picker.element : undefined;\n    }\n\n    /**\n     * Set new values to the config options\n     * @param {Object} options - config options to update\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var picker = this.picker;\n      var newOptions = processOptions(options, this);\n      Object.assign(this._options, options);\n      Object.assign(this.config, newOptions);\n      picker.setOptions(newOptions);\n      refreshUI(this, 3);\n    }\n\n    /**\n     * Show the picker element\n     */\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.inputField) {\n        if (this.inputField.disabled) {\n          return;\n        }\n        if (this.inputField !== document.activeElement) {\n          this._showing = true;\n          this.inputField.focus();\n          delete this._showing;\n        }\n      }\n      this.picker.show();\n    }\n\n    /**\n     * Hide the picker element\n     * Not available on inline picker\n     */\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (this.inline) {\n        return;\n      }\n      this.picker.hide();\n      this.picker.update().changeView(this.config.startView).render();\n    }\n\n    /**\n     * Destroy the Datepicker instance\n     * @return {Detepicker} - the instance destroyed\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.hide();\n      unregisterListeners(this);\n      this.picker.detach();\n      if (!this.inline) {\n        this.inputField.classList.remove('datepicker-input');\n      }\n      delete this.element.datepicker;\n      return this;\n    }\n\n    /**\n     * Get the selected date(s)\n     *\n     * The method returns a Date object of selected date by default, and returns\n     * an array of selected dates in multidate mode. If format string is passed,\n     * it returns date string(s) formatted in given format.\n     *\n     * @param  {String} [format] - Format string to stringify the date(s)\n     * @return {Date|String|Date[]|String[]} - selected date(s), or if none is\n     * selected, empty array in multidate mode and untitled in sigledate mode\n     */\n  }, {\n    key: \"getDate\",\n    value: function getDate() {\n      var _this = this;\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var callback = format ? function (date) {\n        return formatDate(date, format, _this.config.locale);\n      } : function (date) {\n        return new Date(date);\n      };\n      if (this.config.multidate) {\n        return this.dates.map(callback);\n      }\n      if (this.dates.length > 0) {\n        return callback(this.dates[0]);\n      }\n    }\n\n    /**\n     * Set selected date(s)\n     *\n     * In multidate mode, you can pass multiple dates as a series of arguments\n     * or an array. (Since each date is parsed individually, the type of the\n     * dates doesn't have to be the same.)\n     * The given dates are used to toggle the select status of each date. The\n     * number of selected dates is kept from exceeding the length set to\n     * maxNumberOfDates.\n     *\n     * With clear: true option, the method can be used to clear the selection\n     * and to replace the selection instead of toggling in multidate mode.\n     * If the option is passed with no date arguments or an empty dates array,\n     * it works as \"clear\" (clear the selection then set nothing), and if the\n     * option is passed with new dates to select, it works as \"replace\" (clear\n     * the selection then set the given dates)\n     *\n     * When render: false option is used, the method omits re-rendering the\n     * picker element. In this case, you need to call refresh() method later in\n     * order for the picker element to reflect the changes. The input field is\n     * refreshed always regardless of this option.\n     *\n     * When invalid (unparsable, repeated, disabled or out-of-range) dates are\n     * passed, the method ignores them and applies only valid ones. In the case\n     * that all the given dates are invalid, which is distinguished from passing\n     * no dates, the method considers it as an error and leaves the selection\n     * untouched.\n     *\n     * @param {...(Date|Number|String)|Array} [dates] - Date strings, Date\n     * objects, time values or mix of those for new selection\n     * @param {Object} [options] - function options\n     * - clear: {boolean} - Whether to clear the existing selection\n     *     defualt: false\n     * - render: {boolean} - Whether to re-render the picker element\n     *     default: true\n     * - autohide: {boolean} - Whether to hide the picker element after re-render\n     *     Ignored when used with render: false\n     *     default: config.autohide\n     */\n  }, {\n    key: \"setDate\",\n    value: function setDate() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var dates = [].concat(args);\n      var opts = {};\n      var lastArg = lastItemOf(args);\n      if (_typeof(lastArg) === 'object' && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) {\n        Object.assign(opts, dates.pop());\n      }\n      var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;\n      _setDate(this, inputDates, opts);\n    }\n\n    /**\n     * Update the selected date(s) with input field's value\n     * Not available on inline picker\n     *\n     * The input field will be refreshed with properly formatted date string.\n     *\n     * @param  {Object} [options] - function options\n     * - autohide: {boolean} - whether to hide the picker element after refresh\n     *     default: false\n     */\n  }, {\n    key: \"update\",\n    value: function update() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      if (this.inline) {\n        return;\n      }\n      var opts = {\n        clear: true,\n        autohide: !!(options && options.autohide)\n      };\n      var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);\n      _setDate(this, inputDates, opts);\n    }\n\n    /**\n     * Refresh the picker element and the associated input field\n     * @param {String} [target] - target item when refreshing one item only\n     * 'picker' or 'input'\n     * @param {Boolean} [forceRender] - whether to re-render the picker element\n     * regardless of its state instead of optimized refresh\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (target && typeof target !== 'string') {\n        forceRender = target;\n        target = undefined;\n      }\n      var mode;\n      if (target === 'picker') {\n        mode = 2;\n      } else if (target === 'input') {\n        mode = 1;\n      } else {\n        mode = 3;\n      }\n      refreshUI(this, mode, !forceRender);\n    }\n\n    /**\n     * Enter edit mode\n     * Not available on inline picker or when the picker element is hidden\n     */\n  }, {\n    key: \"enterEditMode\",\n    value: function enterEditMode() {\n      if (this.inline || !this.picker.active || this.editMode) {\n        return;\n      }\n      this.editMode = true;\n      this.inputField.classList.add('in-edit', 'border-blue-700', '!border-primary-700');\n    }\n\n    /**\n     * Exit from edit mode\n     * Not available on inline picker\n     * @param  {Object} [options] - function options\n     * - update: {boolean} - whether to call update() after exiting\n     *     If false, input field is revert to the existing selection\n     *     default: false\n     */\n  }, {\n    key: \"exitEditMode\",\n    value: function exitEditMode() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      if (this.inline || !this.editMode) {\n        return;\n      }\n      var opts = Object.assign({\n        update: false\n      }, options);\n      delete this.editMode;\n      this.inputField.classList.remove('in-edit', 'border-blue-700', '!border-primary-700');\n      if (opts.update) {\n        this.update(opts);\n      }\n    }\n  }], [{\n    key: \"formatDate\",\n    value: function formatDate$1(date, format, lang) {\n      return formatDate(date, format, lang && locales[lang] || locales.en);\n    }\n\n    /**\n     * Parse date string\n     * @param  {String|Date|Number} dateStr - date string, Date object or time\n     * value to parse\n     * @param  {String|Object} format - format string or object that contains\n     * toValue() custom parser, whose signature is\n     * - args:\n     *   - dateStr: {String|Date|Number} - the dateStr passed to the method\n     *   - format: {Object} - the format object passed to the method\n     *   - locale: {Object} - locale for the language specified by `lang`\n     * - return:\n     *     {Date|Number} parsed date or its time value\n     * @param  {String} [lang=en] - language code for the locale to use\n     * @return {Number} time value of parsed date\n     */\n  }, {\n    key: \"parseDate\",\n    value: function parseDate$1(dateStr, format, lang) {\n      return parseDate(dateStr, format, lang && locales[lang] || locales.en);\n    }\n\n    /**\n     * @type {Object} - Installed locales in `[languageCode]: localeObject` format\n     * en`:_English (US)_ is pre-installed.\n     */\n  }, {\n    key: \"locales\",\n    get: function get() {\n      return locales;\n    }\n  }]);\n}();\n\n// filter out the config options inapproprite to pass to Datepicker\nfunction filterOptions(options) {\n  var newOpts = Object.assign({}, options);\n  delete newOpts.inputs;\n  delete newOpts.allowOneSidedRange;\n  delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n  return newOpts;\n}\nfunction setupDatepicker(rangepicker, changeDateListener, el, options) {\n  registerListeners(rangepicker, [[el, 'changeDate', changeDateListener]]);\n  new main_esm_Datepicker(el, options, rangepicker);\n}\nfunction onChangeDate(rangepicker, ev) {\n  // to prevent both datepickers trigger the other side's update each other\n  if (rangepicker._updating) {\n    return;\n  }\n  rangepicker._updating = true;\n  var target = ev.target;\n  if (target.datepicker === undefined) {\n    return;\n  }\n  var datepickers = rangepicker.datepickers;\n  var setDateOptions = {\n    render: false\n  };\n  var changedSide = rangepicker.inputs.indexOf(target);\n  var otherSide = changedSide === 0 ? 1 : 0;\n  var changedDate = datepickers[changedSide].dates[0];\n  var otherDate = datepickers[otherSide].dates[0];\n  if (changedDate !== undefined && otherDate !== undefined) {\n    // if the start of the range > the end, swap them\n    if (changedSide === 0 && changedDate > otherDate) {\n      datepickers[0].setDate(otherDate, setDateOptions);\n      datepickers[1].setDate(changedDate, setDateOptions);\n    } else if (changedSide === 1 && changedDate < otherDate) {\n      datepickers[0].setDate(changedDate, setDateOptions);\n      datepickers[1].setDate(otherDate, setDateOptions);\n    }\n  } else if (!rangepicker.allowOneSidedRange) {\n    // to prevent the range from becoming one-sided, copy changed side's\n    // selection (no matter if it's empty) to the other side\n    if (changedDate !== undefined || otherDate !== undefined) {\n      setDateOptions.clear = true;\n      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n    }\n  }\n  datepickers[0].picker.update().render();\n  datepickers[1].picker.update().render();\n  delete rangepicker._updating;\n}\n\n/**\n * Class representing a date range picker\n */\nvar DateRangePicker = /*#__PURE__*/function () {\n  /**\n   * Create a date range picker\n   * @param  {Element} element - element to bind a date range picker\n   * @param  {Object} [options] - config options\n   */\n  function DateRangePicker(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, DateRangePicker);\n    var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll('input'));\n    if (inputs.length < 2) {\n      return;\n    }\n    element.rangepicker = this;\n    this.element = element;\n    this.inputs = inputs.slice(0, 2);\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n    var changeDateListener = onChangeDate.bind(null, this);\n    var cleanOptions = filterOptions(options);\n    // in order for initial date setup to work right when pcicLvel > 0,\n    // let Datepicker constructor add the instance to the rangepicker\n    var datepickers = [];\n    Object.defineProperty(this, 'datepickers', {\n      get: function get() {\n        return datepickers;\n      }\n    });\n    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);\n    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);\n    Object.freeze(datepickers);\n    // normalize the range if inital dates are given\n    if (datepickers[0].dates.length > 0) {\n      onChangeDate(this, {\n        target: this.inputs[0]\n      });\n    } else if (datepickers[1].dates.length > 0) {\n      onChangeDate(this, {\n        target: this.inputs[1]\n      });\n    }\n  }\n\n  /**\n   * @type {Array} - selected date of the linked date pickers\n   */\n  return _createClass(DateRangePicker, [{\n    key: \"dates\",\n    get: function get() {\n      return this.datepickers.length === 2 ? [this.datepickers[0].dates[0], this.datepickers[1].dates[0]] : undefined;\n    }\n\n    /**\n     * Set new values to the config options\n     * @param {Object} options - config options to update\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.allowOneSidedRange = !!options.allowOneSidedRange;\n      var cleanOptions = filterOptions(options);\n      this.datepickers[0].setOptions(cleanOptions);\n      this.datepickers[1].setOptions(cleanOptions);\n    }\n\n    /**\n     * Destroy the DateRangePicker instance\n     * @return {DateRangePicker} - the instance destroyed\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.datepickers[0].destroy();\n      this.datepickers[1].destroy();\n      unregisterListeners(this);\n      delete this.element.rangepicker;\n    }\n\n    /**\n     * Get the start and end dates of the date range\n     *\n     * The method returns Date objects by default. If format string is passed,\n     * it returns date strings formatted in given format.\n     * The result array always contains 2 items (start date/end date) and\n     * undefined is used for unselected side. (e.g. If none is selected,\n     * the result will be [undefined, undefined]. If only the end date is set\n     * when allowOneSidedRange config option is true, [undefined, endDate] will\n     * be returned.)\n     *\n     * @param  {String} [format] - Format string to stringify the dates\n     * @return {Array} - Start and end dates\n     */\n  }, {\n    key: \"getDates\",\n    value: function getDates() {\n      var _this = this;\n      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var callback = format ? function (date) {\n        return formatDate(date, format, _this.datepickers[0].config.locale);\n      } : function (date) {\n        return new Date(date);\n      };\n      return this.dates.map(function (date) {\n        return date === undefined ? date : callback(date);\n      });\n    }\n\n    /**\n     * Set the start and end dates of the date range\n     *\n     * The method calls datepicker.setDate() internally using each of the\n     * arguments in startend order.\n     *\n     * When a clear: true option object is passed instead of a date, the method\n     * clears the date.\n     *\n     * If an invalid date, the same date as the current one or an option object\n     * without clear: true is passed, the method considers that argument as an\n     * \"ineffective\" argument because calling datepicker.setDate() with those\n     * values makes no changes to the date selection.\n     *\n     * When the allowOneSidedRange config option is false, passing {clear: true}\n     * to clear the range works only when it is done to the last effective\n     * argument (in other words, passed to rangeEnd or to rangeStart along with\n     * ineffective rangeEnd). This is because when the date range is changed,\n     * it gets normalized based on the last change at the end of the changing\n     * process.\n     *\n     * @param {Date|Number|String|Object} rangeStart - Start date of the range\n     * or {clear: true} to clear the date\n     * @param {Date|Number|String|Object} rangeEnd - End date of the range\n     * or {clear: true} to clear the date\n     */\n  }, {\n    key: \"setDates\",\n    value: function setDates(rangeStart, rangeEnd) {\n      var _this$datepickers = _slicedToArray(this.datepickers, 2),\n        datepicker0 = _this$datepickers[0],\n        datepicker1 = _this$datepickers[1];\n      var origDates = this.dates;\n\n      // If range normalization runs on every change, we can't set a new range\n      // that starts after the end of the current range correctly because the\n      // normalization process swaps startend right after setting the new start\n      // date. To prevent this, the normalization process needs to run once after\n      // both of the new dates are set.\n      this._updating = true;\n      datepicker0.setDate(rangeStart);\n      datepicker1.setDate(rangeEnd);\n      delete this._updating;\n      if (datepicker1.dates[0] !== origDates[1]) {\n        onChangeDate(this, {\n          target: this.inputs[1]\n        });\n      } else if (datepicker0.dates[0] !== origDates[0]) {\n        onChangeDate(this, {\n          target: this.inputs[0]\n        });\n      }\n    }\n  }]);\n}();\n\n\n\n;// ./node_modules/flowbite/lib/esm/components/datepicker/index.js\nvar datepicker_assign = (undefined && undefined.__assign) || function () {\n    datepicker_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return datepicker_assign.apply(this, arguments);\n};\n\n\nvar datepicker_Default = {\n    defaultDatepickerId: null,\n    autohide: false,\n    format: 'mm/dd/yyyy',\n    maxDate: null,\n    minDate: null,\n    orientation: 'bottom',\n    buttons: false,\n    autoSelectToday: 0,\n    title: null,\n    language: 'en',\n    rangePicker: false,\n    onShow: function () { },\n    onHide: function () { },\n};\nvar datepicker_DefaultInstanceOptions = {\n    id: null,\n    override: true,\n};\nvar Datepicker = /** @class */ (function () {\n    function Datepicker(datepickerEl, options, instanceOptions) {\n        if (datepickerEl === void 0) { datepickerEl = null; }\n        if (options === void 0) { options = datepicker_Default; }\n        if (instanceOptions === void 0) { instanceOptions = datepicker_DefaultInstanceOptions; }\n        this._instanceId = instanceOptions.id\n            ? instanceOptions.id\n            : datepickerEl.id;\n        this._datepickerEl = datepickerEl;\n        this._datepickerInstance = null;\n        this._options = datepicker_assign(datepicker_assign({}, datepicker_Default), options);\n        this._initialized = false;\n        this.init();\n        dom_instances.addInstance('Datepicker', this, this._instanceId, instanceOptions.override);\n    }\n    Datepicker.prototype.init = function () {\n        if (this._datepickerEl && !this._initialized) {\n            if (this._options.rangePicker) {\n                this._datepickerInstance = new DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options));\n            }\n            else {\n                this._datepickerInstance = new main_esm_Datepicker(this._datepickerEl, this._getDatepickerOptions(this._options));\n            }\n            this._initialized = true;\n        }\n    };\n    Datepicker.prototype.destroy = function () {\n        if (this._initialized) {\n            this._initialized = false;\n            this._datepickerInstance.destroy();\n        }\n    };\n    Datepicker.prototype.removeInstance = function () {\n        this.destroy();\n        dom_instances.removeInstance('Datepicker', this._instanceId);\n    };\n    Datepicker.prototype.destroyAndRemoveInstance = function () {\n        this.destroy();\n        this.removeInstance();\n    };\n    Datepicker.prototype.getDatepickerInstance = function () {\n        return this._datepickerInstance;\n    };\n    Datepicker.prototype.getDate = function () {\n        if (this._options.rangePicker &&\n            this._datepickerInstance instanceof DateRangePicker) {\n            return this._datepickerInstance.getDates();\n        }\n        if (!this._options.rangePicker &&\n            this._datepickerInstance instanceof main_esm_Datepicker) {\n            return this._datepickerInstance.getDate();\n        }\n    };\n    Datepicker.prototype.setDate = function (date) {\n        if (this._options.rangePicker &&\n            this._datepickerInstance instanceof DateRangePicker) {\n            return this._datepickerInstance.setDates(date);\n        }\n        if (!this._options.rangePicker &&\n            this._datepickerInstance instanceof main_esm_Datepicker) {\n            return this._datepickerInstance.setDate(date);\n        }\n    };\n    Datepicker.prototype.show = function () {\n        this._datepickerInstance.show();\n        this._options.onShow(this);\n    };\n    Datepicker.prototype.hide = function () {\n        this._datepickerInstance.hide();\n        this._options.onHide(this);\n    };\n    Datepicker.prototype._getDatepickerOptions = function (options) {\n        var datepickerOptions = {};\n        if (options.buttons) {\n            datepickerOptions.todayBtn = true;\n            datepickerOptions.clearBtn = true;\n            if (options.autoSelectToday) {\n                datepickerOptions.todayBtnMode = 1;\n            }\n        }\n        if (options.autohide) {\n            datepickerOptions.autohide = true;\n        }\n        if (options.format) {\n            datepickerOptions.format = options.format;\n        }\n        if (options.maxDate) {\n            datepickerOptions.maxDate = options.maxDate;\n        }\n        if (options.minDate) {\n            datepickerOptions.minDate = options.minDate;\n        }\n        if (options.orientation) {\n            datepickerOptions.orientation = options.orientation;\n        }\n        if (options.title) {\n            datepickerOptions.title = options.title;\n        }\n        if (options.language) {\n            datepickerOptions.language = options.language;\n        }\n        return datepickerOptions;\n    };\n    Datepicker.prototype.updateOnShow = function (callback) {\n        this._options.onShow = callback;\n    };\n    Datepicker.prototype.updateOnHide = function (callback) {\n        this._options.onHide = callback;\n    };\n    return Datepicker;\n}());\nfunction initDatepickers() {\n    document\n        .querySelectorAll('[datepicker], [inline-datepicker], [date-rangepicker]')\n        .forEach(function ($datepickerEl) {\n        if ($datepickerEl) {\n            var buttons = $datepickerEl.hasAttribute('datepicker-buttons');\n            var autoselectToday = $datepickerEl.hasAttribute('datepicker-autoselect-today');\n            var autohide = $datepickerEl.hasAttribute('datepicker-autohide');\n            var format = $datepickerEl.getAttribute('datepicker-format');\n            var maxDate = $datepickerEl.getAttribute('datepicker-max-date');\n            var minDate = $datepickerEl.getAttribute('datepicker-min-date');\n            var orientation_1 = $datepickerEl.getAttribute('datepicker-orientation');\n            var title = $datepickerEl.getAttribute('datepicker-title');\n            var language = $datepickerEl.getAttribute('datepicker-language');\n            var rangePicker = $datepickerEl.hasAttribute('date-rangepicker');\n            new Datepicker($datepickerEl, {\n                buttons: buttons ? buttons : datepicker_Default.buttons,\n                autoSelectToday: autoselectToday\n                    ? autoselectToday\n                    : datepicker_Default.autoSelectToday,\n                autohide: autohide ? autohide : datepicker_Default.autohide,\n                format: format ? format : datepicker_Default.format,\n                maxDate: maxDate ? maxDate : datepicker_Default.maxDate,\n                minDate: minDate ? minDate : datepicker_Default.minDate,\n                orientation: orientation_1\n                    ? orientation_1\n                    : datepicker_Default.orientation,\n                title: title ? title : datepicker_Default.title,\n                language: language ? language : datepicker_Default.language,\n                rangePicker: rangePicker\n                    ? rangePicker\n                    : datepicker_Default.rangePicker,\n            });\n        }\n        else {\n            console.error(\"The datepicker element does not exist. Please check the datepicker attribute.\");\n        }\n    });\n}\nif (typeof window !== 'undefined') {\n    window.Datepicker = Datepicker;\n    window.initDatepickers = initDatepickers;\n}\n/* harmony default export */ const datepicker = ((/* unused pure expression or super */ null && (Datepicker)));\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/components/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction initFlowbite() {\n    initAccordions();\n    initCollapses();\n    initCarousels();\n    initDismisses();\n    initDropdowns();\n    initModals();\n    initDrawers();\n    initTabs();\n    initTooltips();\n    initPopovers();\n    initDials();\n    initInputCounters();\n    initCopyClipboards();\n    initDatepickers();\n}\nif (typeof window !== 'undefined') {\n    window.initFlowbite = initFlowbite;\n}\n//# sourceMappingURL=index.js.map\n;// ./node_modules/flowbite/lib/esm/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// setup events for data attributes\nvar esm_events = new events('load', [\n    initAccordions,\n    initCollapses,\n    initCarousels,\n    initDismisses,\n    initDropdowns,\n    initModals,\n    initDrawers,\n    initTabs,\n    initTooltips,\n    initPopovers,\n    initDials,\n    initInputCounters,\n    initCopyClipboards,\n    initDatepickers,\n]);\nesm_events.init();\n// export all components\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// export all types\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// export all interfaces\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// export init functions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// export all init functions\n\n//# sourceMappingURL=index.js.map\n;// ./assets/javascript/site.js\n// put site-wide dependencies here.\n// HTMX setup: https://htmx.org/docs/#installing\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI5My5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7QUNyMEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5NkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU2l0ZUpTLy4vYXNzZXRzL2phdmFzY3JpcHQvaHRteC5qcz8zY2FkIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9hbHBpbmVqcy9kaXN0L21vZHVsZS5lc20uanM/ZGQ1MiIsIndlYnBhY2s6Ly9TaXRlSlMvLi9hc3NldHMvamF2YXNjcmlwdC9hbHBpbmUuanM/Nzc2YiIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9kb20vZXZlbnRzLmpzPzA1ZTAiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vZG9tL2luc3RhbmNlcy5qcz9iZmU4Iiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvYWNjb3JkaW9uL2luZGV4LmpzPzVhNGYiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9jb2xsYXBzZS9pbmRleC5qcz9hNDU4Iiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvY2Fyb3VzZWwvaW5kZXguanM/MWU5NSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Rpc21pc3MvaW5kZXguanM/NzRiMCIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/MWZjMCIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzPzI3NjciLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzPzg0YzYiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy91c2VyQWdlbnQuanM/MTJkOCIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc0xheW91dFZpZXdwb3J0LmpzPzc0YWYiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzPzBmODgiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzP2EzMjEiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanM/NWZlNiIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzPzE5OWEiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/NTc4OCIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanM/ZWY1MiIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzPzYxMjUiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcz9iNTE5Iiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzP2FlNmMiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9kMTE2Iiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanM/ZTJlOSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzPzI4YmYiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzPzlkMGUiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanM/ZWExYSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcz9iNDUxIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcz9iNjJiIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NzdmOSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzP2I5ZTYiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcz9iMWUyIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanM/MmEzNSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcz82Y2VlIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzP2FkNmUiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzP2I1MGUiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanM/M2Q4ZCIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcz9hZDlkIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanM/NWQ3ZSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzPzEzNGEiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcz83Y2RhIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzPzBhYjQiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvb2Zmc2V0LmpzPzk4MzUiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcz81MjMyIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanM/NTAwYiIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/N2M3MyIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanM/M2U3OSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcz83ZjM3Iiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcz83YmNmIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcz85ZGUwIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzPzM1ZjYiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanM/ZDM5YiIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz85ODUyIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanM/YjYxNyIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzQzY2UiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcz9lY2IyIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcz9mMmUwIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzP2U0M2YiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzPzk0MzUiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanM/MDkyOSIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzPzFkNmMiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanM/MzljMyIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUvbGliL2VzbS9jb21wb25lbnRzL2Ryb3Bkb3duL2luZGV4LmpzPzAxMjQiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9tb2RhbC9pbmRleC5qcz9iMmUxIiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2NvbXBvbmVudHMvZHJhd2VyL2luZGV4LmpzPzA2NWEiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy90YWJzL2luZGV4LmpzPzFhMDEiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy90b29sdGlwL2luZGV4LmpzPzc4ZDQiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9wb3BvdmVyL2luZGV4LmpzPzQ1MGYiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kaWFsL2luZGV4LmpzP2M0ZGQiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9pbnB1dC1jb3VudGVyL2luZGV4LmpzPzhiYzUiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9jbGlwYm9hcmQvaW5kZXguanM/OWYxNyIsIndlYnBhY2s6Ly9TaXRlSlMvLi9ub2RlX21vZHVsZXMvZmxvd2JpdGUtZGF0ZXBpY2tlci9kaXN0L21haW4uZXNtLmpzP2FlOTMiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9kYXRlcGlja2VyL2luZGV4LmpzP2UzOGEiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2Zsb3diaXRlL2xpYi9lc20vY29tcG9uZW50cy9pbmRleC5qcz83MDc1Iiwid2VicGFjazovL1NpdGVKUy8uL25vZGVfbW9kdWxlcy9mbG93Yml0ZS9saWIvZXNtL2luZGV4LmpzPzhkMzEiLCJ3ZWJwYWNrOi8vU2l0ZUpTLy4vYXNzZXRzL2phdmFzY3JpcHQvc2l0ZS5qcz9hYzk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodG14IGZyb20gXCJodG14Lm9yZ1wiO1xud2luZG93Lmh0bXggPSBodG14OyIsIi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9zY2hlZHVsZXIuanNcbnZhciBmbHVzaFBlbmRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIHF1ZXVlID0gW107XG52YXIgbGFzdEZsdXNoZWRJbmRleCA9IC0xO1xuZnVuY3Rpb24gc2NoZWR1bGVyKGNhbGxiYWNrKSB7XG4gIHF1ZXVlSm9iKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlSm9iKGpvYikge1xuICBpZiAoIXF1ZXVlLmluY2x1ZGVzKGpvYikpXG4gICAgcXVldWUucHVzaChqb2IpO1xuICBxdWV1ZUZsdXNoKCk7XG59XG5mdW5jdGlvbiBkZXF1ZXVlSm9iKGpvYikge1xuICBsZXQgaW5kZXggPSBxdWV1ZS5pbmRleE9mKGpvYik7XG4gIGlmIChpbmRleCAhPT0gLTEgJiYgaW5kZXggPiBsYXN0Rmx1c2hlZEluZGV4KVxuICAgIHF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG59XG5mdW5jdGlvbiBxdWV1ZUZsdXNoKCkge1xuICBpZiAoIWZsdXNoaW5nICYmICFmbHVzaFBlbmRpbmcpIHtcbiAgICBmbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgIHF1ZXVlTWljcm90YXNrKGZsdXNoSm9icyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoSm9icygpIHtcbiAgZmx1c2hQZW5kaW5nID0gZmFsc2U7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldKCk7XG4gICAgbGFzdEZsdXNoZWRJbmRleCA9IGk7XG4gIH1cbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgbGFzdEZsdXNoZWRJbmRleCA9IC0xO1xuICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcmVhY3Rpdml0eS5qc1xudmFyIHJlYWN0aXZlO1xudmFyIGVmZmVjdDtcbnZhciByZWxlYXNlO1xudmFyIHJhdztcbnZhciBzaG91bGRTY2hlZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyhjYWxsYmFjaykge1xuICBzaG91bGRTY2hlZHVsZSA9IGZhbHNlO1xuICBjYWxsYmFjaygpO1xuICBzaG91bGRTY2hlZHVsZSA9IHRydWU7XG59XG5mdW5jdGlvbiBzZXRSZWFjdGl2aXR5RW5naW5lKGVuZ2luZSkge1xuICByZWFjdGl2ZSA9IGVuZ2luZS5yZWFjdGl2ZTtcbiAgcmVsZWFzZSA9IGVuZ2luZS5yZWxlYXNlO1xuICBlZmZlY3QgPSAoY2FsbGJhY2spID0+IGVuZ2luZS5lZmZlY3QoY2FsbGJhY2ssIHsgc2NoZWR1bGVyOiAodGFzaykgPT4ge1xuICAgIGlmIChzaG91bGRTY2hlZHVsZSkge1xuICAgICAgc2NoZWR1bGVyKHRhc2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrKCk7XG4gICAgfVxuICB9IH0pO1xuICByYXcgPSBlbmdpbmUucmF3O1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVFZmZlY3Qob3ZlcnJpZGUpIHtcbiAgZWZmZWN0ID0gb3ZlcnJpZGU7XG59XG5mdW5jdGlvbiBlbGVtZW50Qm91bmRFZmZlY3QoZWwpIHtcbiAgbGV0IGNsZWFudXAyID0gKCkgPT4ge1xuICB9O1xuICBsZXQgd3JhcHBlZEVmZmVjdCA9IChjYWxsYmFjaykgPT4ge1xuICAgIGxldCBlZmZlY3RSZWZlcmVuY2UgPSBlZmZlY3QoY2FsbGJhY2spO1xuICAgIGlmICghZWwuX3hfZWZmZWN0cykge1xuICAgICAgZWwuX3hfZWZmZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBlbC5feF9ydW5FZmZlY3RzID0gKCkgPT4ge1xuICAgICAgICBlbC5feF9lZmZlY3RzLmZvckVhY2goKGkpID0+IGkoKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBlbC5feF9lZmZlY3RzLmFkZChlZmZlY3RSZWZlcmVuY2UpO1xuICAgIGNsZWFudXAyID0gKCkgPT4ge1xuICAgICAgaWYgKGVmZmVjdFJlZmVyZW5jZSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBlbC5feF9lZmZlY3RzLmRlbGV0ZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgICAgcmVsZWFzZShlZmZlY3RSZWZlcmVuY2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGVmZmVjdFJlZmVyZW5jZTtcbiAgfTtcbiAgcmV0dXJuIFt3cmFwcGVkRWZmZWN0LCAoKSA9PiB7XG4gICAgY2xlYW51cDIoKTtcbiAgfV07XG59XG5mdW5jdGlvbiB3YXRjaChnZXR0ZXIsIGNhbGxiYWNrKSB7XG4gIGxldCBmaXJzdFRpbWUgPSB0cnVlO1xuICBsZXQgb2xkVmFsdWU7XG4gIGxldCBlZmZlY3RSZWZlcmVuY2UgPSBlZmZlY3QoKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IGdldHRlcigpO1xuICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoIWZpcnN0VGltZSkge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayh2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9KTtcbiAgcmV0dXJuICgpID0+IHJlbGVhc2UoZWZmZWN0UmVmZXJlbmNlKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL211dGF0aW9uLmpzXG52YXIgb25BdHRyaWJ1dGVBZGRlZHMgPSBbXTtcbnZhciBvbkVsUmVtb3ZlZHMgPSBbXTtcbnZhciBvbkVsQWRkZWRzID0gW107XG5mdW5jdGlvbiBvbkVsQWRkZWQoY2FsbGJhY2spIHtcbiAgb25FbEFkZGVkcy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIG9uRWxSZW1vdmVkKGVsLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoIWVsLl94X2NsZWFudXBzKVxuICAgICAgZWwuX3hfY2xlYW51cHMgPSBbXTtcbiAgICBlbC5feF9jbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjayA9IGVsO1xuICAgIG9uRWxSZW1vdmVkcy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gb25BdHRyaWJ1dGVzQWRkZWQoY2FsbGJhY2spIHtcbiAgb25BdHRyaWJ1dGVBZGRlZHMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvbkF0dHJpYnV0ZVJlbW92ZWQoZWwsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGlmICghZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpXG4gICAgZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMgPSB7fTtcbiAgaWYgKCFlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSlcbiAgICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXSA9IFtdO1xuICBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBBdHRyaWJ1dGVzKGVsLCBuYW1lcykge1xuICBpZiAoIWVsLl94X2F0dHJpYnV0ZUNsZWFudXBzKVxuICAgIHJldHVybjtcbiAgT2JqZWN0LmVudHJpZXMoZWwuX3hfYXR0cmlidXRlQ2xlYW51cHMpLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICBpZiAobmFtZXMgPT09IHZvaWQgMCB8fCBuYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaSkgPT4gaSgpKTtcbiAgICAgIGRlbGV0ZSBlbC5feF9hdHRyaWJ1dGVDbGVhbnVwc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYW51cEVsZW1lbnQoZWwpIHtcbiAgZWwuX3hfZWZmZWN0cz8uZm9yRWFjaChkZXF1ZXVlSm9iKTtcbiAgd2hpbGUgKGVsLl94X2NsZWFudXBzPy5sZW5ndGgpXG4gICAgZWwuX3hfY2xlYW51cHMucG9wKCkoKTtcbn1cbnZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG9uTXV0YXRlKTtcbnZhciBjdXJyZW50bHlPYnNlcnZpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zKCkge1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7IHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUgfSk7XG4gIGN1cnJlbnRseU9ic2VydmluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBzdG9wT2JzZXJ2aW5nTXV0YXRpb25zKCkge1xuICBmbHVzaE9ic2VydmVyKCk7XG4gIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgY3VycmVudGx5T2JzZXJ2aW5nID0gZmFsc2U7XG59XG52YXIgcXVldWVkTXV0YXRpb25zID0gW107XG5mdW5jdGlvbiBmbHVzaE9ic2VydmVyKCkge1xuICBsZXQgcmVjb3JkcyA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gIHF1ZXVlZE11dGF0aW9ucy5wdXNoKCgpID0+IHJlY29yZHMubGVuZ3RoID4gMCAmJiBvbk11dGF0ZShyZWNvcmRzKSk7XG4gIGxldCBxdWV1ZUxlbmd0aFdoZW5UcmlnZ2VyZWQgPSBxdWV1ZWRNdXRhdGlvbnMubGVuZ3RoO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgaWYgKHF1ZXVlZE11dGF0aW9ucy5sZW5ndGggPT09IHF1ZXVlTGVuZ3RoV2hlblRyaWdnZXJlZCkge1xuICAgICAgd2hpbGUgKHF1ZXVlZE11dGF0aW9ucy5sZW5ndGggPiAwKVxuICAgICAgICBxdWV1ZWRNdXRhdGlvbnMuc2hpZnQoKSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBtdXRhdGVEb20oY2FsbGJhY2spIHtcbiAgaWYgKCFjdXJyZW50bHlPYnNlcnZpbmcpXG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMoKTtcbiAgbGV0IHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gIHN0YXJ0T2JzZXJ2aW5nTXV0YXRpb25zKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaXNDb2xsZWN0aW5nID0gZmFsc2U7XG52YXIgZGVmZXJyZWRNdXRhdGlvbnMgPSBbXTtcbmZ1bmN0aW9uIGRlZmVyTXV0YXRpb25zKCkge1xuICBpc0NvbGxlY3RpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gZmx1c2hBbmRTdG9wRGVmZXJyaW5nTXV0YXRpb25zKCkge1xuICBpc0NvbGxlY3RpbmcgPSBmYWxzZTtcbiAgb25NdXRhdGUoZGVmZXJyZWRNdXRhdGlvbnMpO1xuICBkZWZlcnJlZE11dGF0aW9ucyA9IFtdO1xufVxuZnVuY3Rpb24gb25NdXRhdGUobXV0YXRpb25zKSB7XG4gIGlmIChpc0NvbGxlY3RpbmcpIHtcbiAgICBkZWZlcnJlZE11dGF0aW9ucyA9IGRlZmVycmVkTXV0YXRpb25zLmNvbmNhdChtdXRhdGlvbnMpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYWRkZWROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCByZW1vdmVkTm9kZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgYWRkZWRBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHJlbW92ZWRBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobXV0YXRpb25zW2ldLnRhcmdldC5feF9pZ25vcmVNdXRhdGlvbk9ic2VydmVyKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAxICYmIGFkZGVkTm9kZXMuYWRkKG5vZGUpKTtcbiAgICAgIG11dGF0aW9uc1tpXS5yZW1vdmVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiByZW1vdmVkTm9kZXMuYWRkKG5vZGUpKTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgbGV0IGVsID0gbXV0YXRpb25zW2ldLnRhcmdldDtcbiAgICAgIGxldCBuYW1lID0gbXV0YXRpb25zW2ldLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBsZXQgb2xkVmFsdWUgPSBtdXRhdGlvbnNbaV0ub2xkVmFsdWU7XG4gICAgICBsZXQgYWRkMiA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFhZGRlZEF0dHJpYnV0ZXMuaGFzKGVsKSlcbiAgICAgICAgICBhZGRlZEF0dHJpYnV0ZXMuc2V0KGVsLCBbXSk7XG4gICAgICAgIGFkZGVkQXR0cmlidXRlcy5nZXQoZWwpLnB1c2goeyBuYW1lLCB2YWx1ZTogZWwuZ2V0QXR0cmlidXRlKG5hbWUpIH0pO1xuICAgICAgfTtcbiAgICAgIGxldCByZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcmVtb3ZlZEF0dHJpYnV0ZXMuaGFzKGVsKSlcbiAgICAgICAgICByZW1vdmVkQXR0cmlidXRlcy5zZXQoZWwsIFtdKTtcbiAgICAgICAgcmVtb3ZlZEF0dHJpYnV0ZXMuZ2V0KGVsKS5wdXNoKG5hbWUpO1xuICAgICAgfTtcbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkgJiYgb2xkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYWRkMigpO1xuICAgICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIGFkZDIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmVkQXR0cmlidXRlcy5mb3JFYWNoKChhdHRycywgZWwpID0+IHtcbiAgICBjbGVhbnVwQXR0cmlidXRlcyhlbCwgYXR0cnMpO1xuICB9KTtcbiAgYWRkZWRBdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJzLCBlbCkgPT4ge1xuICAgIG9uQXR0cmlidXRlQWRkZWRzLmZvckVhY2goKGkpID0+IGkoZWwsIGF0dHJzKSk7XG4gIH0pO1xuICBmb3IgKGxldCBub2RlIG9mIHJlbW92ZWROb2Rlcykge1xuICAgIGlmIChhZGRlZE5vZGVzLmhhcyhub2RlKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIG9uRWxSZW1vdmVkcy5mb3JFYWNoKChpKSA9PiBpKG5vZGUpKTtcbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBub2RlLl94X2lnbm9yZVNlbGYgPSB0cnVlO1xuICAgIG5vZGUuX3hfaWdub3JlID0gdHJ1ZTtcbiAgfSk7XG4gIGZvciAobGV0IG5vZGUgb2YgYWRkZWROb2Rlcykge1xuICAgIGlmIChyZW1vdmVkTm9kZXMuaGFzKG5vZGUpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKCFub2RlLmlzQ29ubmVjdGVkKVxuICAgICAgY29udGludWU7XG4gICAgZGVsZXRlIG5vZGUuX3hfaWdub3JlU2VsZjtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmU7XG4gICAgb25FbEFkZGVkcy5mb3JFYWNoKChpKSA9PiBpKG5vZGUpKTtcbiAgICBub2RlLl94X2lnbm9yZSA9IHRydWU7XG4gICAgbm9kZS5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgfVxuICBhZGRlZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBkZWxldGUgbm9kZS5feF9pZ25vcmVTZWxmO1xuICAgIGRlbGV0ZSBub2RlLl94X2lnbm9yZTtcbiAgfSk7XG4gIGFkZGVkTm9kZXMgPSBudWxsO1xuICByZW1vdmVkTm9kZXMgPSBudWxsO1xuICBhZGRlZEF0dHJpYnV0ZXMgPSBudWxsO1xuICByZW1vdmVkQXR0cmlidXRlcyA9IG51bGw7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9zY29wZS5qc1xuZnVuY3Rpb24gc2NvcGUobm9kZSkge1xuICByZXR1cm4gbWVyZ2VQcm94aWVzKGNsb3Nlc3REYXRhU3RhY2sobm9kZSkpO1xufVxuZnVuY3Rpb24gYWRkU2NvcGVUb05vZGUobm9kZSwgZGF0YTIsIHJlZmVyZW5jZU5vZGUpIHtcbiAgbm9kZS5feF9kYXRhU3RhY2sgPSBbZGF0YTIsIC4uLmNsb3Nlc3REYXRhU3RhY2socmVmZXJlbmNlTm9kZSB8fCBub2RlKV07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbm9kZS5feF9kYXRhU3RhY2sgPSBub2RlLl94X2RhdGFTdGFjay5maWx0ZXIoKGkpID0+IGkgIT09IGRhdGEyKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3REYXRhU3RhY2sobm9kZSkge1xuICBpZiAobm9kZS5feF9kYXRhU3RhY2spXG4gICAgcmV0dXJuIG5vZGUuX3hfZGF0YVN0YWNrO1xuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09IFwiZnVuY3Rpb25cIiAmJiBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgIHJldHVybiBjbG9zZXN0RGF0YVN0YWNrKG5vZGUuaG9zdCk7XG4gIH1cbiAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3REYXRhU3RhY2sobm9kZS5wYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJveGllcyhvYmplY3RzKSB7XG4gIHJldHVybiBuZXcgUHJveHkoeyBvYmplY3RzIH0sIG1lcmdlUHJveHlUcmFwKTtcbn1cbnZhciBtZXJnZVByb3h5VHJhcCA9IHtcbiAgb3duS2V5cyh7IG9iamVjdHMgfSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKFxuICAgICAgbmV3IFNldChvYmplY3RzLmZsYXRNYXAoKGkpID0+IE9iamVjdC5rZXlzKGkpKSlcbiAgICApO1xuICB9LFxuICBoYXMoeyBvYmplY3RzIH0sIG5hbWUpIHtcbiAgICBpZiAobmFtZSA9PSBTeW1ib2wudW5zY29wYWJsZXMpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIG9iamVjdHMuc29tZShcbiAgICAgIChvYmopID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIG5hbWUpIHx8IFJlZmxlY3QuaGFzKG9iaiwgbmFtZSlcbiAgICApO1xuICB9LFxuICBnZXQoeyBvYmplY3RzIH0sIG5hbWUsIHRoaXNQcm94eSkge1xuICAgIGlmIChuYW1lID09IFwidG9KU09OXCIpXG4gICAgICByZXR1cm4gY29sbGFwc2VQcm94aWVzO1xuICAgIHJldHVybiBSZWZsZWN0LmdldChcbiAgICAgIG9iamVjdHMuZmluZChcbiAgICAgICAgKG9iaikgPT4gUmVmbGVjdC5oYXMob2JqLCBuYW1lKVxuICAgICAgKSB8fCB7fSxcbiAgICAgIG5hbWUsXG4gICAgICB0aGlzUHJveHlcbiAgICApO1xuICB9LFxuICBzZXQoeyBvYmplY3RzIH0sIG5hbWUsIHZhbHVlLCB0aGlzUHJveHkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBvYmplY3RzLmZpbmQoXG4gICAgICAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBuYW1lKVxuICAgICkgfHwgb2JqZWN0c1tvYmplY3RzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgbmFtZSk7XG4gICAgaWYgKGRlc2NyaXB0b3I/LnNldCAmJiBkZXNjcmlwdG9yPy5nZXQpXG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzUHJveHksIHZhbHVlKSB8fCB0cnVlO1xuICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNvbGxhcHNlUHJveGllcygpIHtcbiAgbGV0IGtleXMgPSBSZWZsZWN0Lm93bktleXModGhpcyk7XG4gIHJldHVybiBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IFJlZmxlY3QuZ2V0KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvaW50ZXJjZXB0b3IuanNcbmZ1bmN0aW9uIGluaXRJbnRlcmNlcHRvcnMoZGF0YTIpIHtcbiAgbGV0IGlzT2JqZWN0MiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwgIT09IG51bGw7XG4gIGxldCByZWN1cnNlID0gKG9iaiwgYmFzZVBhdGggPSBcIlwiKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSkuZm9yRWFjaCgoW2tleSwgeyB2YWx1ZSwgZW51bWVyYWJsZSB9XSkgPT4ge1xuICAgICAgaWYgKGVudW1lcmFibGUgPT09IGZhbHNlIHx8IHZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuX192X3NraXApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBwYXRoID0gYmFzZVBhdGggPT09IFwiXCIgPyBrZXkgOiBgJHtiYXNlUGF0aH0uJHtrZXl9YDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuX3hfaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5pbml0aWFsaXplKGRhdGEyLCBwYXRoLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0Mih2YWx1ZSkgJiYgdmFsdWUgIT09IG9iaiAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgICByZWN1cnNlKHZhbHVlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcmVjdXJzZShkYXRhMik7XG59XG5mdW5jdGlvbiBpbnRlcmNlcHRvcihjYWxsYmFjaywgbXV0YXRlT2JqID0gKCkgPT4ge1xufSkge1xuICBsZXQgb2JqID0ge1xuICAgIGluaXRpYWxWYWx1ZTogdm9pZCAwLFxuICAgIF94X2ludGVyY2VwdG9yOiB0cnVlLFxuICAgIGluaXRpYWxpemUoZGF0YTIsIHBhdGgsIGtleSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuaW5pdGlhbFZhbHVlLCAoKSA9PiBnZXQoZGF0YTIsIHBhdGgpLCAodmFsdWUpID0+IHNldChkYXRhMiwgcGF0aCwgdmFsdWUpLCBwYXRoLCBrZXkpO1xuICAgIH1cbiAgfTtcbiAgbXV0YXRlT2JqKG9iaik7XG4gIHJldHVybiAoaW5pdGlhbFZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbml0aWFsVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgaW5pdGlhbFZhbHVlICE9PSBudWxsICYmIGluaXRpYWxWYWx1ZS5feF9pbnRlcmNlcHRvcikge1xuICAgICAgbGV0IGluaXRpYWxpemUgPSBvYmouaW5pdGlhbGl6ZS5iaW5kKG9iaik7XG4gICAgICBvYmouaW5pdGlhbGl6ZSA9IChkYXRhMiwgcGF0aCwga2V5KSA9PiB7XG4gICAgICAgIGxldCBpbm5lclZhbHVlID0gaW5pdGlhbFZhbHVlLmluaXRpYWxpemUoZGF0YTIsIHBhdGgsIGtleSk7XG4gICAgICAgIG9iai5pbml0aWFsVmFsdWUgPSBpbm5lclZhbHVlO1xuICAgICAgICByZXR1cm4gaW5pdGlhbGl6ZShkYXRhMiwgcGF0aCwga2V5KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iai5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG59XG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKGNhcnJ5LCBzZWdtZW50KSA9PiBjYXJyeVtzZWdtZW50XSwgb2JqKTtcbn1cbmZ1bmN0aW9uIHNldChvYmosIHBhdGgsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJzdHJpbmdcIilcbiAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSlcbiAgICBvYmpbcGF0aFswXV0gPSB2YWx1ZTtcbiAgZWxzZSBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgdGhyb3cgZXJyb3I7XG4gIGVsc2Uge1xuICAgIGlmIChvYmpbcGF0aFswXV0pXG4gICAgICByZXR1cm4gc2V0KG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUpO1xuICAgIGVsc2Uge1xuICAgICAgb2JqW3BhdGhbMF1dID0ge307XG4gICAgICByZXR1cm4gc2V0KG9ialtwYXRoWzBdXSwgcGF0aC5zbGljZSgxKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLmpzXG52YXIgbWFnaWNzID0ge307XG5mdW5jdGlvbiBtYWdpYyhuYW1lLCBjYWxsYmFjaykge1xuICBtYWdpY3NbbmFtZV0gPSBjYWxsYmFjaztcbn1cbmZ1bmN0aW9uIGluamVjdE1hZ2ljcyhvYmosIGVsKSB7XG4gIGxldCBtZW1vaXplZFV0aWxpdGllcyA9IGdldFV0aWxpdGllcyhlbCk7XG4gIE9iamVjdC5lbnRyaWVzKG1hZ2ljcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGAkJHtuYW1lfWAsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVsLCBtZW1vaXplZFV0aWxpdGllcyk7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBnZXRVdGlsaXRpZXMoZWwpIHtcbiAgbGV0IFt1dGlsaXRpZXMsIGNsZWFudXAyXSA9IGdldEVsZW1lbnRCb3VuZFV0aWxpdGllcyhlbCk7XG4gIGxldCB1dGlscyA9IHsgaW50ZXJjZXB0b3IsIC4uLnV0aWxpdGllcyB9O1xuICBvbkVsUmVtb3ZlZChlbCwgY2xlYW51cDIpO1xuICByZXR1cm4gdXRpbHM7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9lcnJvci5qc1xuZnVuY3Rpb24gdHJ5Q2F0Y2goZWwsIGV4cHJlc3Npb24sIGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgZWwsIGV4cHJlc3Npb24pO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCBleHByZXNzaW9uID0gdm9pZCAwKSB7XG4gIGVycm9yMiA9IE9iamVjdC5hc3NpZ24oXG4gICAgZXJyb3IyID8/IHsgbWVzc2FnZTogXCJObyBlcnJvciBtZXNzYWdlIGdpdmVuLlwiIH0sXG4gICAgeyBlbCwgZXhwcmVzc2lvbiB9XG4gICk7XG4gIGNvbnNvbGUud2FybihgQWxwaW5lIEV4cHJlc3Npb24gRXJyb3I6ICR7ZXJyb3IyLm1lc3NhZ2V9XG5cbiR7ZXhwcmVzc2lvbiA/ICdFeHByZXNzaW9uOiBcIicgKyBleHByZXNzaW9uICsgJ1wiXFxuXFxuJyA6IFwiXCJ9YCwgZWwpO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0aHJvdyBlcnJvcjI7XG4gIH0sIDApO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZXZhbHVhdG9yLmpzXG52YXIgc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zID0gdHJ1ZTtcbmZ1bmN0aW9uIGRvbnRBdXRvRXZhbHVhdGVGdW5jdGlvbnMoY2FsbGJhY2spIHtcbiAgbGV0IGNhY2hlID0gc2hvdWxkQXV0b0V2YWx1YXRlRnVuY3Rpb25zO1xuICBzaG91bGRBdXRvRXZhbHVhdGVGdW5jdGlvbnMgPSBmYWxzZTtcbiAgbGV0IHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gIHNob3VsZEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucyA9IGNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXZhbHVhdGUoZWwsIGV4cHJlc3Npb24sIGV4dHJhcyA9IHt9KSB7XG4gIGxldCByZXN1bHQ7XG4gIGV2YWx1YXRlTGF0ZXIoZWwsIGV4cHJlc3Npb24pKCh2YWx1ZSkgPT4gcmVzdWx0ID0gdmFsdWUsIGV4dHJhcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBldmFsdWF0ZUxhdGVyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHRoZUV2YWx1YXRvckZ1bmN0aW9uKC4uLmFyZ3MpO1xufVxudmFyIHRoZUV2YWx1YXRvckZ1bmN0aW9uID0gbm9ybWFsRXZhbHVhdG9yO1xuZnVuY3Rpb24gc2V0RXZhbHVhdG9yKG5ld0V2YWx1YXRvcikge1xuICB0aGVFdmFsdWF0b3JGdW5jdGlvbiA9IG5ld0V2YWx1YXRvcjtcbn1cbmZ1bmN0aW9uIG5vcm1hbEV2YWx1YXRvcihlbCwgZXhwcmVzc2lvbikge1xuICBsZXQgb3ZlcnJpZGRlbk1hZ2ljcyA9IHt9O1xuICBpbmplY3RNYWdpY3Mob3ZlcnJpZGRlbk1hZ2ljcywgZWwpO1xuICBsZXQgZGF0YVN0YWNrID0gW292ZXJyaWRkZW5NYWdpY3MsIC4uLmNsb3Nlc3REYXRhU3RhY2soZWwpXTtcbiAgbGV0IGV2YWx1YXRvciA9IHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIgPyBnZW5lcmF0ZUV2YWx1YXRvckZyb21GdW5jdGlvbihkYXRhU3RhY2ssIGV4cHJlc3Npb24pIDogZ2VuZXJhdGVFdmFsdWF0b3JGcm9tU3RyaW5nKGRhdGFTdGFjaywgZXhwcmVzc2lvbiwgZWwpO1xuICByZXR1cm4gdHJ5Q2F0Y2guYmluZChudWxsLCBlbCwgZXhwcmVzc2lvbiwgZXZhbHVhdG9yKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlRXZhbHVhdG9yRnJvbUZ1bmN0aW9uKGRhdGFTdGFjaywgZnVuYykge1xuICByZXR1cm4gKHJlY2VpdmVyID0gKCkgPT4ge1xuICB9LCB7IHNjb3BlOiBzY29wZTIgPSB7fSwgcGFyYW1zID0gW10gfSA9IHt9KSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IGZ1bmMuYXBwbHkobWVyZ2VQcm94aWVzKFtzY29wZTIsIC4uLmRhdGFTdGFja10pLCBwYXJhbXMpO1xuICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCk7XG4gIH07XG59XG52YXIgZXZhbHVhdG9yTWVtbyA9IHt9O1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbkZyb21TdHJpbmcoZXhwcmVzc2lvbiwgZWwpIHtcbiAgaWYgKGV2YWx1YXRvck1lbW9bZXhwcmVzc2lvbl0pIHtcbiAgICByZXR1cm4gZXZhbHVhdG9yTWVtb1tleHByZXNzaW9uXTtcbiAgfVxuICBsZXQgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpIHtcbiAgfSkuY29uc3RydWN0b3I7XG4gIGxldCByaWdodFNpZGVTYWZlRXhwcmVzc2lvbiA9IC9eW1xcblxcc10qaWYuKlxcKC4qXFwpLy50ZXN0KGV4cHJlc3Npb24udHJpbSgpKSB8fCAvXihsZXR8Y29uc3QpXFxzLy50ZXN0KGV4cHJlc3Npb24udHJpbSgpKSA/IGAoYXN5bmMoKT0+eyAke2V4cHJlc3Npb259IH0pKClgIDogZXhwcmVzc2lvbjtcbiAgY29uc3Qgc2FmZUFzeW5jRnVuY3Rpb24gPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBmdW5jMiA9IG5ldyBBc3luY0Z1bmN0aW9uKFxuICAgICAgICBbXCJfX3NlbGZcIiwgXCJzY29wZVwiXSxcbiAgICAgICAgYHdpdGggKHNjb3BlKSB7IF9fc2VsZi5yZXN1bHQgPSAke3JpZ2h0U2lkZVNhZmVFeHByZXNzaW9ufSB9OyBfX3NlbGYuZmluaXNoZWQgPSB0cnVlOyByZXR1cm4gX19zZWxmLnJlc3VsdDtgXG4gICAgICApO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmMyLCBcIm5hbWVcIiwge1xuICAgICAgICB2YWx1ZTogYFtBbHBpbmVdICR7ZXhwcmVzc2lvbn1gXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jMjtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIGV4cHJlc3Npb24pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgfTtcbiAgbGV0IGZ1bmMgPSBzYWZlQXN5bmNGdW5jdGlvbigpO1xuICBldmFsdWF0b3JNZW1vW2V4cHJlc3Npb25dID0gZnVuYztcbiAgcmV0dXJuIGZ1bmM7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUV2YWx1YXRvckZyb21TdHJpbmcoZGF0YVN0YWNrLCBleHByZXNzaW9uLCBlbCkge1xuICBsZXQgZnVuYyA9IGdlbmVyYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKGV4cHJlc3Npb24sIGVsKTtcbiAgcmV0dXJuIChyZWNlaXZlciA9ICgpID0+IHtcbiAgfSwgeyBzY29wZTogc2NvcGUyID0ge30sIHBhcmFtcyA9IFtdIH0gPSB7fSkgPT4ge1xuICAgIGZ1bmMucmVzdWx0ID0gdm9pZCAwO1xuICAgIGZ1bmMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICBsZXQgY29tcGxldGVTY29wZSA9IG1lcmdlUHJveGllcyhbc2NvcGUyLCAuLi5kYXRhU3RhY2tdKTtcbiAgICBpZiAodHlwZW9mIGZ1bmMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbGV0IHByb21pc2UgPSBmdW5jKGZ1bmMsIGNvbXBsZXRlU2NvcGUpLmNhdGNoKChlcnJvcjIpID0+IGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIGV4cHJlc3Npb24pKTtcbiAgICAgIGlmIChmdW5jLmZpbmlzaGVkKSB7XG4gICAgICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIGZ1bmMucmVzdWx0LCBjb21wbGV0ZVNjb3BlLCBwYXJhbXMsIGVsKTtcbiAgICAgICAgZnVuYy5yZXN1bHQgPSB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIHJ1bklmVHlwZU9mRnVuY3Rpb24ocmVjZWl2ZXIsIHJlc3VsdCwgY29tcGxldGVTY29wZSwgcGFyYW1zLCBlbCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcjIpID0+IGhhbmRsZUVycm9yKGVycm9yMiwgZWwsIGV4cHJlc3Npb24pKS5maW5hbGx5KCgpID0+IGZ1bmMucmVzdWx0ID0gdm9pZCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBydW5JZlR5cGVPZkZ1bmN0aW9uKHJlY2VpdmVyLCB2YWx1ZSwgc2NvcGUyLCBwYXJhbXMsIGVsKSB7XG4gIGlmIChzaG91bGRBdXRvRXZhbHVhdGVGdW5jdGlvbnMgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUuYXBwbHkoc2NvcGUyLCBwYXJhbXMpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXN1bHQudGhlbigoaSkgPT4gcnVuSWZUeXBlT2ZGdW5jdGlvbihyZWNlaXZlciwgaSwgc2NvcGUyLCBwYXJhbXMpKS5jYXRjaCgoZXJyb3IyKSA9PiBoYW5kbGVFcnJvcihlcnJvcjIsIGVsLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNlaXZlcihyZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgdmFsdWUudGhlbigoaSkgPT4gcmVjZWl2ZXIoaSkpO1xuICB9IGVsc2Uge1xuICAgIHJlY2VpdmVyKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy5qc1xudmFyIHByZWZpeEFzU3RyaW5nID0gXCJ4LVwiO1xuZnVuY3Rpb24gcHJlZml4KHN1YmplY3QgPSBcIlwiKSB7XG4gIHJldHVybiBwcmVmaXhBc1N0cmluZyArIHN1YmplY3Q7XG59XG5mdW5jdGlvbiBzZXRQcmVmaXgobmV3UHJlZml4KSB7XG4gIHByZWZpeEFzU3RyaW5nID0gbmV3UHJlZml4O1xufVxudmFyIGRpcmVjdGl2ZUhhbmRsZXJzID0ge307XG5mdW5jdGlvbiBkaXJlY3RpdmUobmFtZSwgY2FsbGJhY2spIHtcbiAgZGlyZWN0aXZlSGFuZGxlcnNbbmFtZV0gPSBjYWxsYmFjaztcbiAgcmV0dXJuIHtcbiAgICBiZWZvcmUoZGlyZWN0aXZlMikge1xuICAgICAgaWYgKCFkaXJlY3RpdmVIYW5kbGVyc1tkaXJlY3RpdmUyXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oU3RyaW5nLnJhd2BDYW5ub3QgZmluZCBkaXJlY3RpdmUgXFxgJHtkaXJlY3RpdmUyfVxcYC4gXFxgJHtuYW1lfVxcYCB3aWxsIHVzZSB0aGUgZGVmYXVsdCBvcmRlciBvZiBleGVjdXRpb25gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihkaXJlY3RpdmUyKTtcbiAgICAgIGRpcmVjdGl2ZU9yZGVyLnNwbGljZShwb3MgPj0gMCA/IHBvcyA6IGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YoXCJERUZBVUxUXCIpLCAwLCBuYW1lKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkaXJlY3RpdmVFeGlzdHMobmFtZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZGlyZWN0aXZlSGFuZGxlcnMpLmluY2x1ZGVzKG5hbWUpO1xufVxuZnVuY3Rpb24gZGlyZWN0aXZlcyhlbCwgYXR0cmlidXRlcywgb3JpZ2luYWxBdHRyaWJ1dGVPdmVycmlkZSkge1xuICBhdHRyaWJ1dGVzID0gQXJyYXkuZnJvbShhdHRyaWJ1dGVzKTtcbiAgaWYgKGVsLl94X3ZpcnR1YWxEaXJlY3RpdmVzKSB7XG4gICAgbGV0IHZBdHRyaWJ1dGVzID0gT2JqZWN0LmVudHJpZXMoZWwuX3hfdmlydHVhbERpcmVjdGl2ZXMpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gKHsgbmFtZSwgdmFsdWUgfSkpO1xuICAgIGxldCBzdGF0aWNBdHRyaWJ1dGVzID0gYXR0cmlidXRlc09ubHkodkF0dHJpYnV0ZXMpO1xuICAgIHZBdHRyaWJ1dGVzID0gdkF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgIGlmIChzdGF0aWNBdHRyaWJ1dGVzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gYXR0cmlidXRlLm5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogYHgtYmluZDoke2F0dHJpYnV0ZS5uYW1lfWAsXG4gICAgICAgICAgdmFsdWU6IGBcIiR7YXR0cmlidXRlLnZhbHVlfVwiYFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9KTtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQodkF0dHJpYnV0ZXMpO1xuICB9XG4gIGxldCB0cmFuc2Zvcm1lZEF0dHJpYnV0ZU1hcCA9IHt9O1xuICBsZXQgZGlyZWN0aXZlczIgPSBhdHRyaWJ1dGVzLm1hcCh0b1RyYW5zZm9ybWVkQXR0cmlidXRlcygobmV3TmFtZSwgb2xkTmFtZSkgPT4gdHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXBbbmV3TmFtZV0gPSBvbGROYW1lKSkuZmlsdGVyKG91dE5vbkFscGluZUF0dHJpYnV0ZXMpLm1hcCh0b1BhcnNlZERpcmVjdGl2ZXModHJhbnNmb3JtZWRBdHRyaWJ1dGVNYXAsIG9yaWdpbmFsQXR0cmlidXRlT3ZlcnJpZGUpKS5zb3J0KGJ5UHJpb3JpdHkpO1xuICByZXR1cm4gZGlyZWN0aXZlczIubWFwKChkaXJlY3RpdmUyKSA9PiB7XG4gICAgcmV0dXJuIGdldERpcmVjdGl2ZUhhbmRsZXIoZWwsIGRpcmVjdGl2ZTIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZXNPbmx5KGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oYXR0cmlidXRlcykubWFwKHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKCkpLmZpbHRlcigoYXR0cikgPT4gIW91dE5vbkFscGluZUF0dHJpYnV0ZXMoYXR0cikpO1xufVxudmFyIGlzRGVmZXJyaW5nSGFuZGxlcnMgPSBmYWxzZTtcbnZhciBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBkZWZlckhhbmRsaW5nRGlyZWN0aXZlcyhjYWxsYmFjaykge1xuICBpc0RlZmVycmluZ0hhbmRsZXJzID0gdHJ1ZTtcbiAgbGV0IGtleSA9IFN5bWJvbCgpO1xuICBjdXJyZW50SGFuZGxlclN0YWNrS2V5ID0ga2V5O1xuICBkaXJlY3RpdmVIYW5kbGVyU3RhY2tzLnNldChrZXksIFtdKTtcbiAgbGV0IGZsdXNoSGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgd2hpbGUgKGRpcmVjdGl2ZUhhbmRsZXJTdGFja3MuZ2V0KGtleSkubGVuZ3RoKVxuICAgICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoa2V5KS5zaGlmdCgpKCk7XG4gICAgZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5kZWxldGUoa2V5KTtcbiAgfTtcbiAgbGV0IHN0b3BEZWZlcnJpbmcgPSAoKSA9PiB7XG4gICAgaXNEZWZlcnJpbmdIYW5kbGVycyA9IGZhbHNlO1xuICAgIGZsdXNoSGFuZGxlcnMoKTtcbiAgfTtcbiAgY2FsbGJhY2soZmx1c2hIYW5kbGVycyk7XG4gIHN0b3BEZWZlcnJpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRCb3VuZFV0aWxpdGllcyhlbCkge1xuICBsZXQgY2xlYW51cHMgPSBbXTtcbiAgbGV0IGNsZWFudXAyID0gKGNhbGxiYWNrKSA9PiBjbGVhbnVwcy5wdXNoKGNhbGxiYWNrKTtcbiAgbGV0IFtlZmZlY3QzLCBjbGVhbnVwRWZmZWN0XSA9IGVsZW1lbnRCb3VuZEVmZmVjdChlbCk7XG4gIGNsZWFudXBzLnB1c2goY2xlYW51cEVmZmVjdCk7XG4gIGxldCB1dGlsaXRpZXMgPSB7XG4gICAgQWxwaW5lOiBhbHBpbmVfZGVmYXVsdCxcbiAgICBlZmZlY3Q6IGVmZmVjdDMsXG4gICAgY2xlYW51cDogY2xlYW51cDIsXG4gICAgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlci5iaW5kKGV2YWx1YXRlTGF0ZXIsIGVsKSxcbiAgICBldmFsdWF0ZTogZXZhbHVhdGUuYmluZChldmFsdWF0ZSwgZWwpXG4gIH07XG4gIGxldCBkb0NsZWFudXAgPSAoKSA9PiBjbGVhbnVwcy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICByZXR1cm4gW3V0aWxpdGllcywgZG9DbGVhbnVwXTtcbn1cbmZ1bmN0aW9uIGdldERpcmVjdGl2ZUhhbmRsZXIoZWwsIGRpcmVjdGl2ZTIpIHtcbiAgbGV0IG5vb3AgPSAoKSA9PiB7XG4gIH07XG4gIGxldCBoYW5kbGVyNCA9IGRpcmVjdGl2ZUhhbmRsZXJzW2RpcmVjdGl2ZTIudHlwZV0gfHwgbm9vcDtcbiAgbGV0IFt1dGlsaXRpZXMsIGNsZWFudXAyXSA9IGdldEVsZW1lbnRCb3VuZFV0aWxpdGllcyhlbCk7XG4gIG9uQXR0cmlidXRlUmVtb3ZlZChlbCwgZGlyZWN0aXZlMi5vcmlnaW5hbCwgY2xlYW51cDIpO1xuICBsZXQgZnVsbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgaWYgKGVsLl94X2lnbm9yZSB8fCBlbC5feF9pZ25vcmVTZWxmKVxuICAgICAgcmV0dXJuO1xuICAgIGhhbmRsZXI0LmlubGluZSAmJiBoYW5kbGVyNC5pbmxpbmUoZWwsIGRpcmVjdGl2ZTIsIHV0aWxpdGllcyk7XG4gICAgaGFuZGxlcjQgPSBoYW5kbGVyNC5iaW5kKGhhbmRsZXI0LCBlbCwgZGlyZWN0aXZlMiwgdXRpbGl0aWVzKTtcbiAgICBpc0RlZmVycmluZ0hhbmRsZXJzID8gZGlyZWN0aXZlSGFuZGxlclN0YWNrcy5nZXQoY3VycmVudEhhbmRsZXJTdGFja0tleSkucHVzaChoYW5kbGVyNCkgOiBoYW5kbGVyNCgpO1xuICB9O1xuICBmdWxsSGFuZGxlci5ydW5DbGVhbnVwcyA9IGNsZWFudXAyO1xuICByZXR1cm4gZnVsbEhhbmRsZXI7XG59XG52YXIgc3RhcnRpbmdXaXRoID0gKHN1YmplY3QsIHJlcGxhY2VtZW50KSA9PiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoc3ViamVjdCkpXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShzdWJqZWN0LCByZXBsYWNlbWVudCk7XG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG59O1xudmFyIGludG8gPSAoaSkgPT4gaTtcbmZ1bmN0aW9uIHRvVHJhbnNmb3JtZWRBdHRyaWJ1dGVzKGNhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICByZXR1cm4gKHsgbmFtZSwgdmFsdWUgfSkgPT4ge1xuICAgIGxldCB7IG5hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZSB9ID0gYXR0cmlidXRlVHJhbnNmb3JtZXJzLnJlZHVjZSgoY2FycnksIHRyYW5zZm9ybSkgPT4ge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybShjYXJyeSk7XG4gICAgfSwgeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICBpZiAobmV3TmFtZSAhPT0gbmFtZSlcbiAgICAgIGNhbGxiYWNrKG5ld05hbWUsIG5hbWUpO1xuICAgIHJldHVybiB7IG5hbWU6IG5ld05hbWUsIHZhbHVlOiBuZXdWYWx1ZSB9O1xuICB9O1xufVxudmFyIGF0dHJpYnV0ZVRyYW5zZm9ybWVycyA9IFtdO1xuZnVuY3Rpb24gbWFwQXR0cmlidXRlcyhjYWxsYmFjaykge1xuICBhdHRyaWJ1dGVUcmFuc2Zvcm1lcnMucHVzaChjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBvdXROb25BbHBpbmVBdHRyaWJ1dGVzKHsgbmFtZSB9KSB7XG4gIHJldHVybiBhbHBpbmVBdHRyaWJ1dGVSZWdleCgpLnRlc3QobmFtZSk7XG59XG52YXIgYWxwaW5lQXR0cmlidXRlUmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBeJHtwcmVmaXhBc1N0cmluZ30oW146Xi5dKylcXFxcYmApO1xuZnVuY3Rpb24gdG9QYXJzZWREaXJlY3RpdmVzKHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwLCBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlKSB7XG4gIHJldHVybiAoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgbGV0IHR5cGVNYXRjaCA9IG5hbWUubWF0Y2goYWxwaW5lQXR0cmlidXRlUmVnZXgoKSk7XG4gICAgbGV0IHZhbHVlTWF0Y2ggPSBuYW1lLm1hdGNoKC86KFthLXpBLVowLTlcXC1fOl0rKS8pO1xuICAgIGxldCBtb2RpZmllcnMgPSBuYW1lLm1hdGNoKC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nKSB8fCBbXTtcbiAgICBsZXQgb3JpZ2luYWwgPSBvcmlnaW5hbEF0dHJpYnV0ZU92ZXJyaWRlIHx8IHRyYW5zZm9ybWVkQXR0cmlidXRlTWFwW25hbWVdIHx8IG5hbWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMubWFwKChpKSA9PiBpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKSxcbiAgICAgIGV4cHJlc3Npb246IHZhbHVlLFxuICAgICAgb3JpZ2luYWxcbiAgICB9O1xuICB9O1xufVxudmFyIERFRkFVTFQgPSBcIkRFRkFVTFRcIjtcbnZhciBkaXJlY3RpdmVPcmRlciA9IFtcbiAgXCJpZ25vcmVcIixcbiAgXCJyZWZcIixcbiAgXCJkYXRhXCIsXG4gIFwiaWRcIixcbiAgXCJhbmNob3JcIixcbiAgXCJiaW5kXCIsXG4gIFwiaW5pdFwiLFxuICBcImZvclwiLFxuICBcIm1vZGVsXCIsXG4gIFwibW9kZWxhYmxlXCIsXG4gIFwidHJhbnNpdGlvblwiLFxuICBcInNob3dcIixcbiAgXCJpZlwiLFxuICBERUZBVUxULFxuICBcInRlbGVwb3J0XCJcbl07XG5mdW5jdGlvbiBieVByaW9yaXR5KGEsIGIpIHtcbiAgbGV0IHR5cGVBID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihhLnR5cGUpID09PSAtMSA/IERFRkFVTFQgOiBhLnR5cGU7XG4gIGxldCB0eXBlQiA9IGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YoYi50eXBlKSA9PT0gLTEgPyBERUZBVUxUIDogYi50eXBlO1xuICByZXR1cm4gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQSkgLSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVCKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL2Rpc3BhdGNoLmpzXG5mdW5jdGlvbiBkaXNwYXRjaChlbCwgbmFtZSwgZGV0YWlsID0ge30pIHtcbiAgZWwuZGlzcGF0Y2hFdmVudChcbiAgICBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgZGV0YWlsLFxuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIC8vIEFsbG93cyBldmVudHMgdG8gcGFzcyB0aGUgc2hhZG93IERPTSBiYXJyaWVyLlxuICAgICAgY29tcG9zZWQ6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSlcbiAgKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL3dhbGsuanNcbmZ1bmN0aW9uIHdhbGsoZWwsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gXCJmdW5jdGlvblwiICYmIGVsIGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgIEFycmF5LmZyb20oZWwuY2hpbGRyZW4pLmZvckVhY2goKGVsMikgPT4gd2FsayhlbDIsIGNhbGxiYWNrKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBza2lwID0gZmFsc2U7XG4gIGNhbGxiYWNrKGVsLCAoKSA9PiBza2lwID0gdHJ1ZSk7XG4gIGlmIChza2lwKVxuICAgIHJldHVybjtcbiAgbGV0IG5vZGUgPSBlbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICB3YWxrKG5vZGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgbm9kZSA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy93YXJuLmpzXG5mdW5jdGlvbiB3YXJuKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgY29uc29sZS53YXJuKGBBbHBpbmUgV2FybmluZzogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbGlmZWN5Y2xlLmpzXG52YXIgc3RhcnRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnQoKSB7XG4gIGlmIChzdGFydGVkKVxuICAgIHdhcm4oXCJBbHBpbmUgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZCBvbiB0aGlzIHBhZ2UuIENhbGxpbmcgQWxwaW5lLnN0YXJ0KCkgbW9yZSB0aGFuIG9uY2UgY2FuIGNhdXNlIHByb2JsZW1zLlwiKTtcbiAgc3RhcnRlZCA9IHRydWU7XG4gIGlmICghZG9jdW1lbnQuYm9keSlcbiAgICB3YXJuKFwiVW5hYmxlIHRvIGluaXRpYWxpemUuIFRyeWluZyB0byBsb2FkIEFscGluZSBiZWZvcmUgYDxib2R5PmAgaXMgYXZhaWxhYmxlLiBEaWQgeW91IGZvcmdldCB0byBhZGQgYGRlZmVyYCBpbiBBbHBpbmUncyBgPHNjcmlwdD5gIHRhZz9cIik7XG4gIGRpc3BhdGNoKGRvY3VtZW50LCBcImFscGluZTppbml0XCIpO1xuICBkaXNwYXRjaChkb2N1bWVudCwgXCJhbHBpbmU6aW5pdGlhbGl6aW5nXCIpO1xuICBzdGFydE9ic2VydmluZ011dGF0aW9ucygpO1xuICBvbkVsQWRkZWQoKGVsKSA9PiBpbml0VHJlZShlbCwgd2FsaykpO1xuICBvbkVsUmVtb3ZlZCgoZWwpID0+IGRlc3Ryb3lUcmVlKGVsKSk7XG4gIG9uQXR0cmlidXRlc0FkZGVkKChlbCwgYXR0cnMpID0+IHtcbiAgICBkaXJlY3RpdmVzKGVsLCBhdHRycykuZm9yRWFjaCgoaGFuZGxlKSA9PiBoYW5kbGUoKSk7XG4gIH0pO1xuICBsZXQgb3V0TmVzdGVkQ29tcG9uZW50cyA9IChlbCkgPT4gIWNsb3Nlc3RSb290KGVsLnBhcmVudEVsZW1lbnQsIHRydWUpO1xuICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYWxsU2VsZWN0b3JzKCkuam9pbihcIixcIikpKS5maWx0ZXIob3V0TmVzdGVkQ29tcG9uZW50cykuZm9yRWFjaCgoZWwpID0+IHtcbiAgICBpbml0VHJlZShlbCk7XG4gIH0pO1xuICBkaXNwYXRjaChkb2N1bWVudCwgXCJhbHBpbmU6aW5pdGlhbGl6ZWRcIik7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHdhcm5BYm91dE1pc3NpbmdQbHVnaW5zKCk7XG4gIH0pO1xufVxudmFyIHJvb3RTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xudmFyIGluaXRTZWxlY3RvckNhbGxiYWNrcyA9IFtdO1xuZnVuY3Rpb24gcm9vdFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFsbFNlbGVjdG9ycygpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5jb25jYXQoaW5pdFNlbGVjdG9yQ2FsbGJhY2tzKS5tYXAoKGZuKSA9PiBmbigpKTtcbn1cbmZ1bmN0aW9uIGFkZFJvb3RTZWxlY3RvcihzZWxlY3RvckNhbGxiYWNrKSB7XG4gIHJvb3RTZWxlY3RvckNhbGxiYWNrcy5wdXNoKHNlbGVjdG9yQ2FsbGJhY2spO1xufVxuZnVuY3Rpb24gYWRkSW5pdFNlbGVjdG9yKHNlbGVjdG9yQ2FsbGJhY2spIHtcbiAgaW5pdFNlbGVjdG9yQ2FsbGJhY2tzLnB1c2goc2VsZWN0b3JDYWxsYmFjayk7XG59XG5mdW5jdGlvbiBjbG9zZXN0Um9vdChlbCwgaW5jbHVkZUluaXRTZWxlY3RvcnMgPSBmYWxzZSkge1xuICByZXR1cm4gZmluZENsb3Nlc3QoZWwsIChlbGVtZW50KSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0b3JzID0gaW5jbHVkZUluaXRTZWxlY3RvcnMgPyBhbGxTZWxlY3RvcnMoKSA6IHJvb3RTZWxlY3RvcnMoKTtcbiAgICBpZiAoc2VsZWN0b3JzLnNvbWUoKHNlbGVjdG9yKSA9PiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0KGVsLCBjYWxsYmFjaykge1xuICBpZiAoIWVsKVxuICAgIHJldHVybjtcbiAgaWYgKGNhbGxiYWNrKGVsKSlcbiAgICByZXR1cm4gZWw7XG4gIGlmIChlbC5feF90ZWxlcG9ydEJhY2spXG4gICAgZWwgPSBlbC5feF90ZWxlcG9ydEJhY2s7XG4gIGlmICghZWwucGFyZW50RWxlbWVudClcbiAgICByZXR1cm47XG4gIHJldHVybiBmaW5kQ2xvc2VzdChlbC5wYXJlbnRFbGVtZW50LCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBpc1Jvb3QoZWwpIHtcbiAgcmV0dXJuIHJvb3RTZWxlY3RvcnMoKS5zb21lKChzZWxlY3RvcikgPT4gZWwubWF0Y2hlcyhzZWxlY3RvcikpO1xufVxudmFyIGluaXRJbnRlcmNlcHRvcnMyID0gW107XG5mdW5jdGlvbiBpbnRlcmNlcHRJbml0KGNhbGxiYWNrKSB7XG4gIGluaXRJbnRlcmNlcHRvcnMyLnB1c2goY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gaW5pdFRyZWUoZWwsIHdhbGtlciA9IHdhbGssIGludGVyY2VwdCA9ICgpID0+IHtcbn0pIHtcbiAgZGVmZXJIYW5kbGluZ0RpcmVjdGl2ZXMoKCkgPT4ge1xuICAgIHdhbGtlcihlbCwgKGVsMiwgc2tpcCkgPT4ge1xuICAgICAgaW50ZXJjZXB0KGVsMiwgc2tpcCk7XG4gICAgICBpbml0SW50ZXJjZXB0b3JzMi5mb3JFYWNoKChpKSA9PiBpKGVsMiwgc2tpcCkpO1xuICAgICAgZGlyZWN0aXZlcyhlbDIsIGVsMi5hdHRyaWJ1dGVzKS5mb3JFYWNoKChoYW5kbGUpID0+IGhhbmRsZSgpKTtcbiAgICAgIGVsMi5feF9pZ25vcmUgJiYgc2tpcCgpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lUcmVlKHJvb3QsIHdhbGtlciA9IHdhbGspIHtcbiAgd2Fsa2VyKHJvb3QsIChlbCkgPT4ge1xuICAgIGNsZWFudXBFbGVtZW50KGVsKTtcbiAgICBjbGVhbnVwQXR0cmlidXRlcyhlbCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gd2FybkFib3V0TWlzc2luZ1BsdWdpbnMoKSB7XG4gIGxldCBwbHVnaW5EaXJlY3RpdmVzID0gW1xuICAgIFtcInVpXCIsIFwiZGlhbG9nXCIsIFtcIlt4LWRpYWxvZ10sIFt4LXBvcG92ZXJdXCJdXSxcbiAgICBbXCJhbmNob3JcIiwgXCJhbmNob3JcIiwgW1wiW3gtYW5jaG9yXVwiXV0sXG4gICAgW1wic29ydFwiLCBcInNvcnRcIiwgW1wiW3gtc29ydF1cIl1dXG4gIF07XG4gIHBsdWdpbkRpcmVjdGl2ZXMuZm9yRWFjaCgoW3BsdWdpbjIsIGRpcmVjdGl2ZTIsIHNlbGVjdG9yc10pID0+IHtcbiAgICBpZiAoZGlyZWN0aXZlRXhpc3RzKGRpcmVjdGl2ZTIpKVxuICAgICAgcmV0dXJuO1xuICAgIHNlbGVjdG9ycy5zb21lKChzZWxlY3RvcikgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgIHdhcm4oYGZvdW5kIFwiJHtzZWxlY3Rvcn1cIiwgYnV0IG1pc3NpbmcgJHtwbHVnaW4yfSBwbHVnaW5gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbmV4dFRpY2suanNcbnZhciB0aWNrU3RhY2sgPSBbXTtcbnZhciBpc0hvbGRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIG5leHRUaWNrKGNhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgaXNIb2xkaW5nIHx8IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICB0aWNrU3RhY2sucHVzaCgoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgcmVzKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVsZWFzZU5leHRUaWNrcygpIHtcbiAgaXNIb2xkaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0aWNrU3RhY2subGVuZ3RoKVxuICAgIHRpY2tTdGFjay5zaGlmdCgpKCk7XG59XG5mdW5jdGlvbiBob2xkTmV4dFRpY2tzKCkge1xuICBpc0hvbGRpbmcgPSB0cnVlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvY2xhc3Nlcy5qc1xuZnVuY3Rpb24gc2V0Q2xhc3NlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZS5qb2luKFwiIFwiKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNldENsYXNzZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gc2V0Q2xhc3NlcyhlbCwgdmFsdWUoKSk7XG4gIH1cbiAgcmV0dXJuIHNldENsYXNzZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbVN0cmluZyhlbCwgY2xhc3NTdHJpbmcpIHtcbiAgbGV0IHNwbGl0ID0gKGNsYXNzU3RyaW5nMikgPT4gY2xhc3NTdHJpbmcyLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBtaXNzaW5nQ2xhc3NlcyA9IChjbGFzc1N0cmluZzIpID0+IGNsYXNzU3RyaW5nMi5zcGxpdChcIiBcIikuZmlsdGVyKChpKSA9PiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKS5maWx0ZXIoQm9vbGVhbik7XG4gIGxldCBhZGRDbGFzc2VzQW5kUmV0dXJuVW5kbyA9IChjbGFzc2VzKSA9PiB7XG4gICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzKTtcbiAgICB9O1xuICB9O1xuICBjbGFzc1N0cmluZyA9IGNsYXNzU3RyaW5nID09PSB0cnVlID8gY2xhc3NTdHJpbmcgPSBcIlwiIDogY2xhc3NTdHJpbmcgfHwgXCJcIjtcbiAgcmV0dXJuIGFkZENsYXNzZXNBbmRSZXR1cm5VbmRvKG1pc3NpbmdDbGFzc2VzKGNsYXNzU3RyaW5nKSk7XG59XG5mdW5jdGlvbiBzZXRDbGFzc2VzRnJvbU9iamVjdChlbCwgY2xhc3NPYmplY3QpIHtcbiAgbGV0IHNwbGl0ID0gKGNsYXNzU3RyaW5nKSA9PiBjbGFzc1N0cmluZy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgZm9yQWRkID0gT2JqZWN0LmVudHJpZXMoY2xhc3NPYmplY3QpLmZsYXRNYXAoKFtjbGFzc1N0cmluZywgYm9vbF0pID0+IGJvb2wgPyBzcGxpdChjbGFzc1N0cmluZykgOiBmYWxzZSkuZmlsdGVyKEJvb2xlYW4pO1xuICBsZXQgZm9yUmVtb3ZlID0gT2JqZWN0LmVudHJpZXMoY2xhc3NPYmplY3QpLmZsYXRNYXAoKFtjbGFzc1N0cmluZywgYm9vbF0pID0+ICFib29sID8gc3BsaXQoY2xhc3NTdHJpbmcpIDogZmFsc2UpLmZpbHRlcihCb29sZWFuKTtcbiAgbGV0IGFkZGVkID0gW107XG4gIGxldCByZW1vdmVkID0gW107XG4gIGZvclJlbW92ZS5mb3JFYWNoKChpKSA9PiB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucyhpKSkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShpKTtcbiAgICAgIHJlbW92ZWQucHVzaChpKTtcbiAgICB9XG4gIH0pO1xuICBmb3JBZGQuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGlmICghZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGkpKSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGkpO1xuICAgICAgYWRkZWQucHVzaChpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZWQuZm9yRWFjaCgoaSkgPT4gZWwuY2xhc3NMaXN0LmFkZChpKSk7XG4gICAgYWRkZWQuZm9yRWFjaCgoaSkgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShpKSk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9zdHlsZXMuanNcbmZ1bmN0aW9uIHNldFN0eWxlcyhlbCwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzZXRTdHlsZXNGcm9tT2JqZWN0KGVsLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHNldFN0eWxlc0Zyb21TdHJpbmcoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlc0Zyb21PYmplY3QoZWwsIHZhbHVlKSB7XG4gIGxldCBwcmV2aW91c1N0eWxlcyA9IHt9O1xuICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdmFsdWUyXSkgPT4ge1xuICAgIHByZXZpb3VzU3R5bGVzW2tleV0gPSBlbC5zdHlsZVtrZXldO1xuICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoXCItLVwiKSkge1xuICAgICAga2V5ID0ga2ViYWJDYXNlKGtleSk7XG4gICAgfVxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUyKTtcbiAgfSk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgc2V0U3R5bGVzKGVsLCBwcmV2aW91c1N0eWxlcyk7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRTdHlsZXNGcm9tU3RyaW5nKGVsLCB2YWx1ZSkge1xuICBsZXQgY2FjaGUgPSBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCB2YWx1ZSk7XG4gIGVsLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIHZhbHVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBjYWNoZSB8fCBcIlwiKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGtlYmFiQ2FzZShzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL3V0aWxzL29uY2UuanNcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2ssIGZhbGxiYWNrID0gKCkgPT4ge1xufSkge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRyYW5zaXRpb24uanNcbmRpcmVjdGl2ZShcInRyYW5zaXRpb25cIiwgKGVsLCB7IHZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBldmFsdWF0ZTogZXZhbHVhdGUyIH0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcImZ1bmN0aW9uXCIpXG4gICAgZXhwcmVzc2lvbiA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgaWYgKGV4cHJlc3Npb24gPT09IGZhbHNlKVxuICAgIHJldHVybjtcbiAgaWYgKCFleHByZXNzaW9uIHx8IHR5cGVvZiBleHByZXNzaW9uID09PSBcImJvb2xlYW5cIikge1xuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZWdpc3RlclRyYW5zaXRpb25zRnJvbUNsYXNzU3RyaW5nKGVsLCBleHByZXNzaW9uLCB2YWx1ZSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uc0Zyb21DbGFzc1N0cmluZyhlbCwgY2xhc3NTdHJpbmcsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0Q2xhc3NlcywgXCJcIik7XG4gIGxldCBkaXJlY3RpdmVTdG9yYWdlTWFwID0ge1xuICAgIFwiZW50ZXJcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwiZW50ZXItc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJlbnRlci1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24uZW50ZXIuZW5kID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmVcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0gY2xhc3NlcztcbiAgICB9LFxuICAgIFwibGVhdmUtc3RhcnRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuc3RhcnQgPSBjbGFzc2VzO1xuICAgIH0sXG4gICAgXCJsZWF2ZS1lbmRcIjogKGNsYXNzZXMpID0+IHtcbiAgICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0gY2xhc3NlcztcbiAgICB9XG4gIH07XG4gIGRpcmVjdGl2ZVN0b3JhZ2VNYXBbc3RhZ2VdKGNsYXNzU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbnNGcm9tSGVscGVyKGVsLCBtb2RpZmllcnMsIHN0YWdlKSB7XG4gIHJlZ2lzdGVyVHJhbnNpdGlvbk9iamVjdChlbCwgc2V0U3R5bGVzKTtcbiAgbGV0IGRvZXNudFNwZWNpZnkgPSAhbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW5cIikgJiYgIW1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSAmJiAhc3RhZ2U7XG4gIGxldCB0cmFuc2l0aW9uaW5nSW4gPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcImluXCIpIHx8IFtcImVudGVyXCJdLmluY2x1ZGVzKHN0YWdlKTtcbiAgbGV0IHRyYW5zaXRpb25pbmdPdXQgPSBkb2VzbnRTcGVjaWZ5IHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm91dFwiKSB8fCBbXCJsZWF2ZVwiXS5pbmNsdWRlcyhzdGFnZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpblwiKSAmJiAhZG9lc250U3BlY2lmeSkge1xuICAgIG1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA8IG1vZGlmaWVycy5pbmRleE9mKFwib3V0XCIpKTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwib3V0XCIpICYmICFkb2VzbnRTcGVjaWZ5KSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4ID4gbW9kaWZpZXJzLmluZGV4T2YoXCJvdXRcIikpO1xuICB9XG4gIGxldCB3YW50c0FsbCA9ICFtb2RpZmllcnMuaW5jbHVkZXMoXCJvcGFjaXR5XCIpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoXCJzY2FsZVwiKTtcbiAgbGV0IHdhbnRzT3BhY2l0eSA9IHdhbnRzQWxsIHx8IG1vZGlmaWVycy5pbmNsdWRlcyhcIm9wYWNpdHlcIik7XG4gIGxldCB3YW50c1NjYWxlID0gd2FudHNBbGwgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKFwic2NhbGVcIik7XG4gIGxldCBvcGFjaXR5VmFsdWUgPSB3YW50c09wYWNpdHkgPyAwIDogMTtcbiAgbGV0IHNjYWxlVmFsdWUgPSB3YW50c1NjYWxlID8gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwic2NhbGVcIiwgOTUpIC8gMTAwIDogMTtcbiAgbGV0IGRlbGF5ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZGVsYXlcIiwgMCkgLyAxZTM7XG4gIGxldCBvcmlnaW4gPSBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgXCJvcmlnaW5cIiwgXCJjZW50ZXJcIik7XG4gIGxldCBwcm9wZXJ0eSA9IFwib3BhY2l0eSwgdHJhbnNmb3JtXCI7XG4gIGxldCBkdXJhdGlvbkluID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgMTUwKSAvIDFlMztcbiAgbGV0IGR1cmF0aW9uT3V0ID0gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsIFwiZHVyYXRpb25cIiwgNzUpIC8gMWUzO1xuICBsZXQgZWFzaW5nID0gYGN1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKWA7XG4gIGlmICh0cmFuc2l0aW9uaW5nSW4pIHtcbiAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZyA9IHtcbiAgICAgIHRyYW5zZm9ybU9yaWdpbjogb3JpZ2luLFxuICAgICAgdHJhbnNpdGlvbkRlbGF5OiBgJHtkZWxheX1zYCxcbiAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9uSW59c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IG9wYWNpdHlWYWx1ZSxcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7c2NhbGVWYWx1ZX0pYFxuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5lbnRlci5lbmQgPSB7XG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoMSlgXG4gICAgfTtcbiAgfVxuICBpZiAodHJhbnNpdGlvbmluZ091dCkge1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZHVyaW5nID0ge1xuICAgICAgdHJhbnNmb3JtT3JpZ2luOiBvcmlnaW4sXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGAke2RlbGF5fXNgLFxuICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7ZHVyYXRpb25PdXR9c2AsXG4gICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGVhc2luZ1xuICAgIH07XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5sZWF2ZS5zdGFydCA9IHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgxKWBcbiAgICB9O1xuICAgIGVsLl94X3RyYW5zaXRpb24ubGVhdmUuZW5kID0ge1xuICAgICAgb3BhY2l0eTogb3BhY2l0eVZhbHVlLFxuICAgICAgdHJhbnNmb3JtOiBgc2NhbGUoJHtzY2FsZVZhbHVlfSlgXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uT2JqZWN0KGVsLCBzZXRGdW5jdGlvbiwgZGVmYXVsdFZhbHVlID0ge30pIHtcbiAgaWYgKCFlbC5feF90cmFuc2l0aW9uKVxuICAgIGVsLl94X3RyYW5zaXRpb24gPSB7XG4gICAgICBlbnRlcjogeyBkdXJpbmc6IGRlZmF1bHRWYWx1ZSwgc3RhcnQ6IGRlZmF1bHRWYWx1ZSwgZW5kOiBkZWZhdWx0VmFsdWUgfSxcbiAgICAgIGxlYXZlOiB7IGR1cmluZzogZGVmYXVsdFZhbHVlLCBzdGFydDogZGVmYXVsdFZhbHVlLCBlbmQ6IGRlZmF1bHRWYWx1ZSB9LFxuICAgICAgaW4oYmVmb3JlID0gKCkgPT4ge1xuICAgICAgfSwgYWZ0ZXIgPSAoKSA9PiB7XG4gICAgICB9KSB7XG4gICAgICAgIHRyYW5zaXRpb24oZWwsIHNldEZ1bmN0aW9uLCB7XG4gICAgICAgICAgZHVyaW5nOiB0aGlzLmVudGVyLmR1cmluZyxcbiAgICAgICAgICBzdGFydDogdGhpcy5lbnRlci5zdGFydCxcbiAgICAgICAgICBlbmQ6IHRoaXMuZW50ZXIuZW5kXG4gICAgICAgIH0sIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgfSxcbiAgICAgIG91dChiZWZvcmUgPSAoKSA9PiB7XG4gICAgICB9LCBhZnRlciA9ICgpID0+IHtcbiAgICAgIH0pIHtcbiAgICAgICAgdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHtcbiAgICAgICAgICBkdXJpbmc6IHRoaXMubGVhdmUuZHVyaW5nLFxuICAgICAgICAgIHN0YXJ0OiB0aGlzLmxlYXZlLnN0YXJ0LFxuICAgICAgICAgIGVuZDogdGhpcy5sZWF2ZS5lbmRcbiAgICAgICAgfSwgYmVmb3JlLCBhZnRlcik7XG4gICAgICB9XG4gICAgfTtcbn1cbndpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5feF90b2dnbGVBbmRDYXNjYWRlV2l0aFRyYW5zaXRpb25zID0gZnVuY3Rpb24oZWwsIHZhbHVlLCBzaG93LCBoaWRlKSB7XG4gIGNvbnN0IG5leHRUaWNrMiA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBzZXRUaW1lb3V0O1xuICBsZXQgY2xpY2tBd2F5Q29tcGF0aWJsZVNob3cgPSAoKSA9PiBuZXh0VGljazIoc2hvdyk7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmIChlbC5feF90cmFuc2l0aW9uICYmIChlbC5feF90cmFuc2l0aW9uLmVudGVyIHx8IGVsLl94X3RyYW5zaXRpb24ubGVhdmUpKSB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uLmVudGVyICYmIChPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLmR1cmluZykubGVuZ3RoIHx8IE9iamVjdC5lbnRyaWVzKGVsLl94X3RyYW5zaXRpb24uZW50ZXIuc3RhcnQpLmxlbmd0aCB8fCBPYmplY3QuZW50cmllcyhlbC5feF90cmFuc2l0aW9uLmVudGVyLmVuZCkubGVuZ3RoKSA/IGVsLl94X3RyYW5zaXRpb24uaW4oc2hvdykgOiBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5feF90cmFuc2l0aW9uID8gZWwuX3hfdHJhbnNpdGlvbi5pbihzaG93KSA6IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBlbC5feF9oaWRlUHJvbWlzZSA9IGVsLl94X3RyYW5zaXRpb24gPyBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZWwuX3hfdHJhbnNpdGlvbi5vdXQoKCkgPT4ge1xuICAgIH0sICgpID0+IHJlc29sdmUoaGlkZSkpO1xuICAgIGVsLl94X3RyYW5zaXRpb25pbmcgJiYgZWwuX3hfdHJhbnNpdGlvbmluZy5iZWZvcmVDYW5jZWwoKCkgPT4gcmVqZWN0KHsgaXNGcm9tQ2FuY2VsbGVkVHJhbnNpdGlvbjogdHJ1ZSB9KSk7XG4gIH0pIDogUHJvbWlzZS5yZXNvbHZlKGhpZGUpO1xuICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgbGV0IGNsb3Nlc3QgPSBjbG9zZXN0SGlkZShlbCk7XG4gICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgIGlmICghY2xvc2VzdC5feF9oaWRlQ2hpbGRyZW4pXG4gICAgICAgIGNsb3Nlc3QuX3hfaGlkZUNoaWxkcmVuID0gW107XG4gICAgICBjbG9zZXN0Ll94X2hpZGVDaGlsZHJlbi5wdXNoKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFRpY2syKCgpID0+IHtcbiAgICAgICAgbGV0IGhpZGVBZnRlckNoaWxkcmVuID0gKGVsMikgPT4ge1xuICAgICAgICAgIGxldCBjYXJyeSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGVsMi5feF9oaWRlUHJvbWlzZSxcbiAgICAgICAgICAgIC4uLihlbDIuX3hfaGlkZUNoaWxkcmVuIHx8IFtdKS5tYXAoaGlkZUFmdGVyQ2hpbGRyZW4pXG4gICAgICAgICAgXSkudGhlbigoW2ldKSA9PiBpPy4oKSk7XG4gICAgICAgICAgZGVsZXRlIGVsMi5feF9oaWRlUHJvbWlzZTtcbiAgICAgICAgICBkZWxldGUgZWwyLl94X2hpZGVDaGlsZHJlbjtcbiAgICAgICAgICByZXR1cm4gY2Fycnk7XG4gICAgICAgIH07XG4gICAgICAgIGhpZGVBZnRlckNoaWxkcmVuKGVsKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGlmICghZS5pc0Zyb21DYW5jZWxsZWRUcmFuc2l0aW9uKVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNsb3Nlc3RIaWRlKGVsKSB7XG4gIGxldCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICBpZiAoIXBhcmVudClcbiAgICByZXR1cm47XG4gIHJldHVybiBwYXJlbnQuX3hfaGlkZVByb21pc2UgPyBwYXJlbnQgOiBjbG9zZXN0SGlkZShwYXJlbnQpO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbihlbCwgc2V0RnVuY3Rpb24sIHsgZHVyaW5nLCBzdGFydDogc3RhcnQyLCBlbmQgfSA9IHt9LCBiZWZvcmUgPSAoKSA9PiB7XG59LCBhZnRlciA9ICgpID0+IHtcbn0pIHtcbiAgaWYgKGVsLl94X3RyYW5zaXRpb25pbmcpXG4gICAgZWwuX3hfdHJhbnNpdGlvbmluZy5jYW5jZWwoKTtcbiAgaWYgKE9iamVjdC5rZXlzKGR1cmluZykubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKHN0YXJ0MikubGVuZ3RoID09PSAwICYmIE9iamVjdC5rZXlzKGVuZCkubGVuZ3RoID09PSAwKSB7XG4gICAgYmVmb3JlKCk7XG4gICAgYWZ0ZXIoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHVuZG9TdGFydCwgdW5kb0R1cmluZywgdW5kb0VuZDtcbiAgcGVyZm9ybVRyYW5zaXRpb24oZWwsIHtcbiAgICBzdGFydCgpIHtcbiAgICAgIHVuZG9TdGFydCA9IHNldEZ1bmN0aW9uKGVsLCBzdGFydDIpO1xuICAgIH0sXG4gICAgZHVyaW5nKCkge1xuICAgICAgdW5kb0R1cmluZyA9IHNldEZ1bmN0aW9uKGVsLCBkdXJpbmcpO1xuICAgIH0sXG4gICAgYmVmb3JlLFxuICAgIGVuZCgpIHtcbiAgICAgIHVuZG9TdGFydCgpO1xuICAgICAgdW5kb0VuZCA9IHNldEZ1bmN0aW9uKGVsLCBlbmQpO1xuICAgIH0sXG4gICAgYWZ0ZXIsXG4gICAgY2xlYW51cCgpIHtcbiAgICAgIHVuZG9EdXJpbmcoKTtcbiAgICAgIHVuZG9FbmQoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGVyZm9ybVRyYW5zaXRpb24oZWwsIHN0YWdlcykge1xuICBsZXQgaW50ZXJydXB0ZWQsIHJlYWNoZWRCZWZvcmUsIHJlYWNoZWRFbmQ7XG4gIGxldCBmaW5pc2ggPSBvbmNlKCgpID0+IHtcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgaW50ZXJydXB0ZWQgPSB0cnVlO1xuICAgICAgaWYgKCFyZWFjaGVkQmVmb3JlKVxuICAgICAgICBzdGFnZXMuYmVmb3JlKCk7XG4gICAgICBpZiAoIXJlYWNoZWRFbmQpIHtcbiAgICAgICAgc3RhZ2VzLmVuZCgpO1xuICAgICAgICByZWxlYXNlTmV4dFRpY2tzKCk7XG4gICAgICB9XG4gICAgICBzdGFnZXMuYWZ0ZXIoKTtcbiAgICAgIGlmIChlbC5pc0Nvbm5lY3RlZClcbiAgICAgICAgc3RhZ2VzLmNsZWFudXAoKTtcbiAgICAgIGRlbGV0ZSBlbC5feF90cmFuc2l0aW9uaW5nO1xuICAgIH0pO1xuICB9KTtcbiAgZWwuX3hfdHJhbnNpdGlvbmluZyA9IHtcbiAgICBiZWZvcmVDYW5jZWxzOiBbXSxcbiAgICBiZWZvcmVDYW5jZWwoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuYmVmb3JlQ2FuY2Vscy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGNhbmNlbDogb25jZShmdW5jdGlvbigpIHtcbiAgICAgIHdoaWxlICh0aGlzLmJlZm9yZUNhbmNlbHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmVmb3JlQ2FuY2Vscy5zaGlmdCgpKCk7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBmaW5pc2goKTtcbiAgICB9KSxcbiAgICBmaW5pc2hcbiAgfTtcbiAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICBzdGFnZXMuc3RhcnQoKTtcbiAgICBzdGFnZXMuZHVyaW5nKCk7XG4gIH0pO1xuICBob2xkTmV4dFRpY2tzKCk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgaWYgKGludGVycnVwdGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBkdXJhdGlvbiA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS50cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgvLC4qLywgXCJcIikucmVwbGFjZShcInNcIiwgXCJcIikpICogMWUzO1xuICAgIGxldCBkZWxheSA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS50cmFuc2l0aW9uRGVsYXkucmVwbGFjZSgvLC4qLywgXCJcIikucmVwbGFjZShcInNcIiwgXCJcIikpICogMWUzO1xuICAgIGlmIChkdXJhdGlvbiA9PT0gMClcbiAgICAgIGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLmFuaW1hdGlvbkR1cmF0aW9uLnJlcGxhY2UoXCJzXCIsIFwiXCIpKSAqIDFlMztcbiAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgc3RhZ2VzLmJlZm9yZSgpO1xuICAgIH0pO1xuICAgIHJlYWNoZWRCZWZvcmUgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoaW50ZXJydXB0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIHN0YWdlcy5lbmQoKTtcbiAgICAgIH0pO1xuICAgICAgcmVsZWFzZU5leHRUaWNrcygpO1xuICAgICAgc2V0VGltZW91dChlbC5feF90cmFuc2l0aW9uaW5nLmZpbmlzaCwgZHVyYXRpb24gKyBkZWxheSk7XG4gICAgICByZWFjaGVkRW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywga2V5LCBmYWxsYmFjaykge1xuICBpZiAobW9kaWZpZXJzLmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICBjb25zdCByYXdWYWx1ZSA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihrZXkpICsgMV07XG4gIGlmICghcmF3VmFsdWUpXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICBpZiAoa2V5ID09PSBcInNjYWxlXCIpIHtcbiAgICBpZiAoaXNOYU4ocmF3VmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIGlmIChrZXkgPT09IFwiZHVyYXRpb25cIiB8fCBrZXkgPT09IFwiZGVsYXlcIikge1xuICAgIGxldCBtYXRjaCA9IHJhd1ZhbHVlLm1hdGNoKC8oWzAtOV0rKW1zLyk7XG4gICAgaWYgKG1hdGNoKVxuICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICB9XG4gIGlmIChrZXkgPT09IFwib3JpZ2luXCIpIHtcbiAgICBpZiAoW1widG9wXCIsIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwiYm90dG9tXCJdLmluY2x1ZGVzKG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihrZXkpICsgMl0pKSB7XG4gICAgICByZXR1cm4gW3Jhd1ZhbHVlLCBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdXS5qb2luKFwiIFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhd1ZhbHVlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvY2xvbmUuanNcbnZhciBpc0Nsb25pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHNraXBEdXJpbmdDbG9uZShjYWxsYmFjaywgZmFsbGJhY2sgPSAoKSA9PiB7XG59KSB7XG4gIHJldHVybiAoLi4uYXJncykgPT4gaXNDbG9uaW5nID8gZmFsbGJhY2soLi4uYXJncykgOiBjYWxsYmFjayguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIG9ubHlEdXJpbmdDbG9uZShjYWxsYmFjaykge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IGlzQ2xvbmluZyAmJiBjYWxsYmFjayguLi5hcmdzKTtcbn1cbnZhciBpbnRlcmNlcHRvcnMgPSBbXTtcbmZ1bmN0aW9uIGludGVyY2VwdENsb25lKGNhbGxiYWNrKSB7XG4gIGludGVyY2VwdG9ycy5wdXNoKGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGNsb25lTm9kZShmcm9tLCB0bykge1xuICBpbnRlcmNlcHRvcnMuZm9yRWFjaCgoaSkgPT4gaShmcm9tLCB0bykpO1xuICBpc0Nsb25pbmcgPSB0cnVlO1xuICBkb250UmVnaXN0ZXJSZWFjdGl2ZVNpZGVFZmZlY3RzKCgpID0+IHtcbiAgICBpbml0VHJlZSh0bywgKGVsLCBjYWxsYmFjaykgPT4ge1xuICAgICAgY2FsbGJhY2soZWwsICgpID0+IHtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgaXNDbG9uaW5nID0gZmFsc2U7XG59XG52YXIgaXNDbG9uaW5nTGVnYWN5ID0gZmFsc2U7XG5mdW5jdGlvbiBjbG9uZShvbGRFbCwgbmV3RWwpIHtcbiAgaWYgKCFuZXdFbC5feF9kYXRhU3RhY2spXG4gICAgbmV3RWwuX3hfZGF0YVN0YWNrID0gb2xkRWwuX3hfZGF0YVN0YWNrO1xuICBpc0Nsb25pbmcgPSB0cnVlO1xuICBpc0Nsb25pbmdMZWdhY3kgPSB0cnVlO1xuICBkb250UmVnaXN0ZXJSZWFjdGl2ZVNpZGVFZmZlY3RzKCgpID0+IHtcbiAgICBjbG9uZVRyZWUobmV3RWwpO1xuICB9KTtcbiAgaXNDbG9uaW5nID0gZmFsc2U7XG4gIGlzQ2xvbmluZ0xlZ2FjeSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2xvbmVUcmVlKGVsKSB7XG4gIGxldCBoYXNSdW5UaHJvdWdoRmlyc3RFbCA9IGZhbHNlO1xuICBsZXQgc2hhbGxvd1dhbGtlciA9IChlbDIsIGNhbGxiYWNrKSA9PiB7XG4gICAgd2FsayhlbDIsIChlbDMsIHNraXApID0+IHtcbiAgICAgIGlmIChoYXNSdW5UaHJvdWdoRmlyc3RFbCAmJiBpc1Jvb3QoZWwzKSlcbiAgICAgICAgcmV0dXJuIHNraXAoKTtcbiAgICAgIGhhc1J1blRocm91Z2hGaXJzdEVsID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVsMywgc2tpcCk7XG4gICAgfSk7XG4gIH07XG4gIGluaXRUcmVlKGVsLCBzaGFsbG93V2Fsa2VyKTtcbn1cbmZ1bmN0aW9uIGRvbnRSZWdpc3RlclJlYWN0aXZlU2lkZUVmZmVjdHMoY2FsbGJhY2spIHtcbiAgbGV0IGNhY2hlID0gZWZmZWN0O1xuICBvdmVycmlkZUVmZmVjdCgoY2FsbGJhY2syLCBlbCkgPT4ge1xuICAgIGxldCBzdG9yZWRFZmZlY3QgPSBjYWNoZShjYWxsYmFjazIpO1xuICAgIHJlbGVhc2Uoc3RvcmVkRWZmZWN0KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIH0pO1xuICBjYWxsYmFjaygpO1xuICBvdmVycmlkZUVmZmVjdChjYWNoZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9iaW5kLmpzXG5mdW5jdGlvbiBiaW5kKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzID0gW10pIHtcbiAgaWYgKCFlbC5feF9iaW5kaW5ncylcbiAgICBlbC5feF9iaW5kaW5ncyA9IHJlYWN0aXZlKHt9KTtcbiAgZWwuX3hfYmluZGluZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgbmFtZSA9IG1vZGlmaWVycy5pbmNsdWRlcyhcImNhbWVsXCIpID8gY2FtZWxDYXNlKG5hbWUpIDogbmFtZTtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICBiaW5kSW5wdXRWYWx1ZShlbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBiaW5kU3R5bGVzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgYmluZEF0dHJpYnV0ZUFuZFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRJbnB1dFZhbHVlKGVsLCB2YWx1ZSkge1xuICBpZiAoaXNSYWRpbyhlbCkpIHtcbiAgICBpZiAoZWwuYXR0cmlidXRlcy52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAod2luZG93LmZyb21Nb2RlbCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgZWwuY2hlY2tlZCA9IHNhZmVQYXJzZUJvb2xlYW4oZWwudmFsdWUpID09PSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZShlbC52YWx1ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NoZWNrYm94KGVsKSkge1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiICYmICFbbnVsbCwgdm9pZCAwXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGVsLnZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5zb21lKCh2YWwpID0+IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbCwgZWwudmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChlbC50YWdOYW1lID09PSBcIlNFTEVDVFwiKSB7XG4gICAgdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVsLnZhbHVlID09PSB2YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBlbC52YWx1ZSA9IHZhbHVlID09PSB2b2lkIDAgPyBcIlwiIDogdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpbmRDbGFzc2VzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcylcbiAgICBlbC5feF91bmRvQWRkZWRDbGFzc2VzKCk7XG4gIGVsLl94X3VuZG9BZGRlZENsYXNzZXMgPSBzZXRDbGFzc2VzKGVsLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBiaW5kU3R5bGVzKGVsLCB2YWx1ZSkge1xuICBpZiAoZWwuX3hfdW5kb0FkZGVkU3R5bGVzKVxuICAgIGVsLl94X3VuZG9BZGRlZFN0eWxlcygpO1xuICBlbC5feF91bmRvQWRkZWRTdHlsZXMgPSBzZXRTdHlsZXMoZWwsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGJpbmRBdHRyaWJ1dGVBbmRQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpO1xuICBzZXRQcm9wZXJ0eUlmQ2hhbmdlZChlbCwgbmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gYmluZEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKFtudWxsLCB2b2lkIDAsIGZhbHNlXS5pbmNsdWRlcyh2YWx1ZSkgJiYgYXR0cmlidXRlU2hvdWxkbnRCZVByZXNlcnZlZElmRmFsc3kobmFtZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQm9vbGVhbkF0dHIobmFtZSkpXG4gICAgICB2YWx1ZSA9IG5hbWU7XG4gICAgc2V0SWZDaGFuZ2VkKGVsLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gIGlmIChlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpICE9IHZhbHVlKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFByb3BlcnR5SWZDaGFuZ2VkKGVsLCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgaWYgKGVsW3Byb3BOYW1lXSAhPT0gdmFsdWUpIHtcbiAgICBlbFtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSkge1xuICBjb25zdCBhcnJheVdyYXBwZWRWYWx1ZSA9IFtdLmNvbmNhdCh2YWx1ZSkubWFwKCh2YWx1ZTIpID0+IHtcbiAgICByZXR1cm4gdmFsdWUyICsgXCJcIjtcbiAgfSk7XG4gIEFycmF5LmZyb20oZWwub3B0aW9ucykuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgb3B0aW9uLnNlbGVjdGVkID0gYXJyYXlXcmFwcGVkVmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjYW1lbENhc2Uoc3ViamVjdCkge1xuICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZSh2YWx1ZUEsIHZhbHVlQikge1xuICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbn1cbmZ1bmN0aW9uIHNhZmVQYXJzZUJvb2xlYW4ocmF3VmFsdWUpIHtcbiAgaWYgKFsxLCBcIjFcIiwgXCJ0cnVlXCIsIFwib25cIiwgXCJ5ZXNcIiwgdHJ1ZV0uaW5jbHVkZXMocmF3VmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFswLCBcIjBcIiwgXCJmYWxzZVwiLCBcIm9mZlwiLCBcIm5vXCIsIGZhbHNlXS5pbmNsdWRlcyhyYXdWYWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJhd1ZhbHVlID8gQm9vbGVhbihyYXdWYWx1ZSkgOiBudWxsO1xufVxudmFyIGJvb2xlYW5BdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImFsbG93ZnVsbHNjcmVlblwiLFxuICBcImFzeW5jXCIsXG4gIFwiYXV0b2ZvY3VzXCIsXG4gIFwiYXV0b3BsYXlcIixcbiAgXCJjaGVja2VkXCIsXG4gIFwiY29udHJvbHNcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwiZGVmZXJcIixcbiAgXCJkaXNhYmxlZFwiLFxuICBcImZvcm1ub3ZhbGlkYXRlXCIsXG4gIFwiaW5lcnRcIixcbiAgXCJpc21hcFwiLFxuICBcIml0ZW1zY29wZVwiLFxuICBcImxvb3BcIixcbiAgXCJtdWx0aXBsZVwiLFxuICBcIm11dGVkXCIsXG4gIFwibm9tb2R1bGVcIixcbiAgXCJub3ZhbGlkYXRlXCIsXG4gIFwib3BlblwiLFxuICBcInBsYXlzaW5saW5lXCIsXG4gIFwicmVhZG9ubHlcIixcbiAgXCJyZXF1aXJlZFwiLFxuICBcInJldmVyc2VkXCIsXG4gIFwic2VsZWN0ZWRcIixcbiAgXCJzaGFkb3dyb290Y2xvbmFibGVcIixcbiAgXCJzaGFkb3dyb290ZGVsZWdhdGVzZm9jdXNcIixcbiAgXCJzaGFkb3dyb290c2VyaWFsaXphYmxlXCJcbl0pO1xuZnVuY3Rpb24gaXNCb29sZWFuQXR0cihhdHRyTmFtZSkge1xuICByZXR1cm4gYm9vbGVhbkF0dHJpYnV0ZXMuaGFzKGF0dHJOYW1lKTtcbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZVNob3VsZG50QmVQcmVzZXJ2ZWRJZkZhbHN5KG5hbWUpIHtcbiAgcmV0dXJuICFbXCJhcmlhLXByZXNzZWRcIiwgXCJhcmlhLWNoZWNrZWRcIiwgXCJhcmlhLWV4cGFuZGVkXCIsIFwiYXJpYS1zZWxlY3RlZFwiXS5pbmNsdWRlcyhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmcoZWwsIG5hbWUsIGZhbGxiYWNrKSB7XG4gIGlmIChlbC5feF9iaW5kaW5ncyAmJiBlbC5feF9iaW5kaW5nc1tuYW1lXSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiBlbC5feF9iaW5kaW5nc1tuYW1lXTtcbiAgcmV0dXJuIGdldEF0dHJpYnV0ZUJpbmRpbmcoZWwsIG5hbWUsIGZhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wKGVsLCBuYW1lLCBmYWxsYmFjaywgZXh0cmFjdCA9IHRydWUpIHtcbiAgaWYgKGVsLl94X2JpbmRpbmdzICYmIGVsLl94X2JpbmRpbmdzW25hbWVdICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIGVsLl94X2JpbmRpbmdzW25hbWVdO1xuICBpZiAoZWwuX3hfaW5saW5lQmluZGluZ3MgJiYgZWwuX3hfaW5saW5lQmluZGluZ3NbbmFtZV0gIT09IHZvaWQgMCkge1xuICAgIGxldCBiaW5kaW5nID0gZWwuX3hfaW5saW5lQmluZGluZ3NbbmFtZV07XG4gICAgYmluZGluZy5leHRyYWN0ID0gZXh0cmFjdDtcbiAgICByZXR1cm4gZG9udEF1dG9FdmFsdWF0ZUZ1bmN0aW9ucygoKSA9PiB7XG4gICAgICByZXR1cm4gZXZhbHVhdGUoZWwsIGJpbmRpbmcuZXhwcmVzc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGdldEF0dHJpYnV0ZUJpbmRpbmcoZWwsIG5hbWUsIGZhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJpbmRpbmcoZWwsIG5hbWUsIGZhbGxiYWNrKSB7XG4gIGxldCBhdHRyID0gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICBpZiAoYXR0ciA9PT0gbnVsbClcbiAgICByZXR1cm4gdHlwZW9mIGZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG4gIGlmIChhdHRyID09PSBcIlwiKVxuICAgIHJldHVybiB0cnVlO1xuICBpZiAoaXNCb29sZWFuQXR0cihuYW1lKSkge1xuICAgIHJldHVybiAhIVtuYW1lLCBcInRydWVcIl0uaW5jbHVkZXMoYXR0cik7XG4gIH1cbiAgcmV0dXJuIGF0dHI7XG59XG5mdW5jdGlvbiBpc0NoZWNrYm94KGVsKSB7XG4gIHJldHVybiBlbC50eXBlID09PSBcImNoZWNrYm94XCIgfHwgZWwubG9jYWxOYW1lID09PSBcInVpLWNoZWNrYm94XCIgfHwgZWwubG9jYWxOYW1lID09PSBcInVpLXN3aXRjaFwiO1xufVxuZnVuY3Rpb24gaXNSYWRpbyhlbCkge1xuICByZXR1cm4gZWwudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsLmxvY2FsTmFtZSA9PT0gXCJ1aS1yYWRpb1wiO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvZGVib3VuY2UuanNcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvdXRpbHMvdGhyb3R0bGUuanNcbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIGxpbWl0KSB7XG4gIGxldCBpblRocm90dGxlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIGlmICghaW5UaHJvdHRsZSkge1xuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGluVGhyb3R0bGUgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBpblRocm90dGxlID0gZmFsc2UsIGxpbWl0KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9lbnRhbmdsZS5qc1xuZnVuY3Rpb24gZW50YW5nbGUoeyBnZXQ6IG91dGVyR2V0LCBzZXQ6IG91dGVyU2V0IH0sIHsgZ2V0OiBpbm5lckdldCwgc2V0OiBpbm5lclNldCB9KSB7XG4gIGxldCBmaXJzdFJ1biA9IHRydWU7XG4gIGxldCBvdXRlckhhc2g7XG4gIGxldCBpbm5lckhhc2g7XG4gIGxldCByZWZlcmVuY2UgPSBlZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvdXRlciA9IG91dGVyR2V0KCk7XG4gICAgbGV0IGlubmVyID0gaW5uZXJHZXQoKTtcbiAgICBpZiAoZmlyc3RSdW4pIHtcbiAgICAgIGlubmVyU2V0KGNsb25lSWZPYmplY3Qob3V0ZXIpKTtcbiAgICAgIGZpcnN0UnVuID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBvdXRlckhhc2hMYXRlc3QgPSBKU09OLnN0cmluZ2lmeShvdXRlcik7XG4gICAgICBsZXQgaW5uZXJIYXNoTGF0ZXN0ID0gSlNPTi5zdHJpbmdpZnkoaW5uZXIpO1xuICAgICAgaWYgKG91dGVySGFzaExhdGVzdCAhPT0gb3V0ZXJIYXNoKSB7XG4gICAgICAgIGlubmVyU2V0KGNsb25lSWZPYmplY3Qob3V0ZXIpKTtcbiAgICAgIH0gZWxzZSBpZiAob3V0ZXJIYXNoTGF0ZXN0ICE9PSBpbm5lckhhc2hMYXRlc3QpIHtcbiAgICAgICAgb3V0ZXJTZXQoY2xvbmVJZk9iamVjdChpbm5lcikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ZXJIYXNoID0gSlNPTi5zdHJpbmdpZnkob3V0ZXJHZXQoKSk7XG4gICAgaW5uZXJIYXNoID0gSlNPTi5zdHJpbmdpZnkoaW5uZXJHZXQoKSk7XG4gIH0pO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbGVhc2UocmVmZXJlbmNlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lSWZPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSA6IHZhbHVlO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvcGx1Z2luLmpzXG5mdW5jdGlvbiBwbHVnaW4oY2FsbGJhY2spIHtcbiAgbGV0IGNhbGxiYWNrcyA9IEFycmF5LmlzQXJyYXkoY2FsbGJhY2spID8gY2FsbGJhY2sgOiBbY2FsbGJhY2tdO1xuICBjYWxsYmFja3MuZm9yRWFjaCgoaSkgPT4gaShhbHBpbmVfZGVmYXVsdCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvc3RvcmUuanNcbnZhciBzdG9yZXMgPSB7fTtcbnZhciBpc1JlYWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBzdG9yZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzUmVhY3RpdmUpIHtcbiAgICBzdG9yZXMgPSByZWFjdGl2ZShzdG9yZXMpO1xuICAgIGlzUmVhY3RpdmUgPSB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN0b3Jlc1tuYW1lXTtcbiAgfVxuICBzdG9yZXNbbmFtZV0gPSB2YWx1ZTtcbiAgaW5pdEludGVyY2VwdG9ycyhzdG9yZXNbbmFtZV0pO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLmhhc093blByb3BlcnR5KFwiaW5pdFwiKSAmJiB0eXBlb2YgdmFsdWUuaW5pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgc3RvcmVzW25hbWVdLmluaXQoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3RvcmVzKCkge1xuICByZXR1cm4gc3RvcmVzO1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvYmluZHMuanNcbnZhciBiaW5kcyA9IHt9O1xuZnVuY3Rpb24gYmluZDIobmFtZSwgYmluZGluZ3MpIHtcbiAgbGV0IGdldEJpbmRpbmdzID0gdHlwZW9mIGJpbmRpbmdzICE9PSBcImZ1bmN0aW9uXCIgPyAoKSA9PiBiaW5kaW5ncyA6IGJpbmRpbmdzO1xuICBpZiAobmFtZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICByZXR1cm4gYXBwbHlCaW5kaW5nc09iamVjdChuYW1lLCBnZXRCaW5kaW5ncygpKTtcbiAgfSBlbHNlIHtcbiAgICBiaW5kc1tuYW1lXSA9IGdldEJpbmRpbmdzO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gIH07XG59XG5mdW5jdGlvbiBpbmplY3RCaW5kaW5nUHJvdmlkZXJzKG9iaikge1xuICBPYmplY3QuZW50cmllcyhiaW5kcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGFwcGx5QmluZGluZ3NPYmplY3QoZWwsIG9iaiwgb3JpZ2luYWwpIHtcbiAgbGV0IGNsZWFudXBSdW5uZXJzID0gW107XG4gIHdoaWxlIChjbGVhbnVwUnVubmVycy5sZW5ndGgpXG4gICAgY2xlYW51cFJ1bm5lcnMucG9wKCkoKTtcbiAgbGV0IGF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gKHsgbmFtZSwgdmFsdWUgfSkpO1xuICBsZXQgc3RhdGljQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNPbmx5KGF0dHJpYnV0ZXMpO1xuICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgIGlmIChzdGF0aWNBdHRyaWJ1dGVzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gYXR0cmlidXRlLm5hbWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBgeC1iaW5kOiR7YXR0cmlidXRlLm5hbWV9YCxcbiAgICAgICAgdmFsdWU6IGBcIiR7YXR0cmlidXRlLnZhbHVlfVwiYFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgfSk7XG4gIGRpcmVjdGl2ZXMoZWwsIGF0dHJpYnV0ZXMsIG9yaWdpbmFsKS5tYXAoKGhhbmRsZSkgPT4ge1xuICAgIGNsZWFudXBSdW5uZXJzLnB1c2goaGFuZGxlLnJ1bkNsZWFudXBzKTtcbiAgICBoYW5kbGUoKTtcbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2hpbGUgKGNsZWFudXBSdW5uZXJzLmxlbmd0aClcbiAgICAgIGNsZWFudXBSdW5uZXJzLnBvcCgpKCk7XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kYXRhcy5qc1xudmFyIGRhdGFzID0ge307XG5mdW5jdGlvbiBkYXRhKG5hbWUsIGNhbGxiYWNrKSB7XG4gIGRhdGFzW25hbWVdID0gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiBpbmplY3REYXRhUHJvdmlkZXJzKG9iaiwgY29udGV4dCkge1xuICBPYmplY3QuZW50cmllcyhkYXRhcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmJpbmQoY29udGV4dCkoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9hbHBpbmUuanNcbnZhciBBbHBpbmUgPSB7XG4gIGdldCByZWFjdGl2ZSgpIHtcbiAgICByZXR1cm4gcmVhY3RpdmU7XG4gIH0sXG4gIGdldCByZWxlYXNlKCkge1xuICAgIHJldHVybiByZWxlYXNlO1xuICB9LFxuICBnZXQgZWZmZWN0KCkge1xuICAgIHJldHVybiBlZmZlY3Q7XG4gIH0sXG4gIGdldCByYXcoKSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfSxcbiAgdmVyc2lvbjogXCIzLjE0LjNcIixcbiAgZmx1c2hBbmRTdG9wRGVmZXJyaW5nTXV0YXRpb25zLFxuICBkb250QXV0b0V2YWx1YXRlRnVuY3Rpb25zLFxuICBkaXNhYmxlRWZmZWN0U2NoZWR1bGluZyxcbiAgc3RhcnRPYnNlcnZpbmdNdXRhdGlvbnMsXG4gIHN0b3BPYnNlcnZpbmdNdXRhdGlvbnMsXG4gIHNldFJlYWN0aXZpdHlFbmdpbmUsXG4gIG9uQXR0cmlidXRlUmVtb3ZlZCxcbiAgb25BdHRyaWJ1dGVzQWRkZWQsXG4gIGNsb3Nlc3REYXRhU3RhY2ssXG4gIHNraXBEdXJpbmdDbG9uZSxcbiAgb25seUR1cmluZ0Nsb25lLFxuICBhZGRSb290U2VsZWN0b3IsXG4gIGFkZEluaXRTZWxlY3RvcixcbiAgaW50ZXJjZXB0Q2xvbmUsXG4gIGFkZFNjb3BlVG9Ob2RlLFxuICBkZWZlck11dGF0aW9ucyxcbiAgbWFwQXR0cmlidXRlcyxcbiAgZXZhbHVhdGVMYXRlcixcbiAgaW50ZXJjZXB0SW5pdCxcbiAgc2V0RXZhbHVhdG9yLFxuICBtZXJnZVByb3hpZXMsXG4gIGV4dHJhY3RQcm9wLFxuICBmaW5kQ2xvc2VzdCxcbiAgb25FbFJlbW92ZWQsXG4gIGNsb3Nlc3RSb290LFxuICBkZXN0cm95VHJlZSxcbiAgaW50ZXJjZXB0b3IsXG4gIC8vIElOVEVSTkFMOiBub3QgcHVibGljIEFQSSBhbmQgaXMgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBtYWpvciByZWxlYXNlLlxuICB0cmFuc2l0aW9uLFxuICAvLyBJTlRFUk5BTFxuICBzZXRTdHlsZXMsXG4gIC8vIElOVEVSTkFMXG4gIG11dGF0ZURvbSxcbiAgZGlyZWN0aXZlLFxuICBlbnRhbmdsZSxcbiAgdGhyb3R0bGUsXG4gIGRlYm91bmNlLFxuICBldmFsdWF0ZSxcbiAgaW5pdFRyZWUsXG4gIG5leHRUaWNrLFxuICBwcmVmaXhlZDogcHJlZml4LFxuICBwcmVmaXg6IHNldFByZWZpeCxcbiAgcGx1Z2luLFxuICBtYWdpYyxcbiAgc3RvcmUsXG4gIHN0YXJ0LFxuICBjbG9uZSxcbiAgLy8gSU5URVJOQUxcbiAgY2xvbmVOb2RlLFxuICAvLyBJTlRFUk5BTFxuICBib3VuZDogZ2V0QmluZGluZyxcbiAgJGRhdGE6IHNjb3BlLFxuICB3YXRjaCxcbiAgd2FsayxcbiAgZGF0YSxcbiAgYmluZDogYmluZDJcbn07XG52YXIgYWxwaW5lX2RlZmF1bHQgPSBBbHBpbmU7XG5cbi8vIG5vZGVfbW9kdWxlcy9AdnVlL3NoYXJlZC9kaXN0L3NoYXJlZC5lc20tYnVuZGxlci5qc1xuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gKHZhbCkgPT4gISFtYXBbdmFsLnRvTG93ZXJDYXNlKCldIDogKHZhbCkgPT4gISFtYXBbdmFsXTtcbn1cbnZhciBzcGVjaWFsQm9vbGVhbkF0dHJzID0gYGl0ZW1zY29wZSxhbGxvd2Z1bGxzY3JlZW4sZm9ybW5vdmFsaWRhdGUsaXNtYXAsbm9tb2R1bGUsbm92YWxpZGF0ZSxyZWFkb25seWA7XG52YXIgaXNCb29sZWFuQXR0cjIgPSAvKiBAX19QVVJFX18gKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzICsgYCxhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY29udHJvbHMsZGVmYXVsdCxkZWZlcixkaXNhYmxlZCxoaWRkZW4sbG9vcCxvcGVuLHJlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxjaGVja2VkLG11dGVkLG11bHRpcGxlLHNlbGVjdGVkYCk7XG52YXIgRU1QVFlfT0JKID0gdHJ1ZSA/IE9iamVjdC5mcmVlemUoe30pIDoge307XG52YXIgRU1QVFlfQVJSID0gdHJ1ZSA/IE9iamVjdC5mcmVlemUoW10pIDogW107XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGhhc093biA9ICh2YWwsIGtleSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbCh2YWwsIGtleSk7XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG52YXIgaXNNYXAgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gXCJbb2JqZWN0IE1hcF1cIjtcbnZhciBpc1N0cmluZyA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG52YXIgaXNTeW1ib2wgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN5bWJvbFwiO1xudmFyIGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCI7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHRvVHlwZVN0cmluZyA9ICh2YWx1ZSkgPT4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG52YXIgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0b1R5cGVTdHJpbmcodmFsdWUpLnNsaWNlKDgsIC0xKTtcbn07XG52YXIgaXNJbnRlZ2VyS2V5ID0gKGtleSkgPT4gaXNTdHJpbmcoa2V5KSAmJiBrZXkgIT09IFwiTmFOXCIgJiYga2V5WzBdICE9PSBcIi1cIiAmJiBcIlwiICsgcGFyc2VJbnQoa2V5LCAxMCkgPT09IGtleTtcbnZhciBjYWNoZVN0cmluZ0Z1bmN0aW9uID0gKGZuKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoc3RyKSA9PiB7XG4gICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XG4gIH07XG59O1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIik7XG59KTtcbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcbnZhciB0b0hhbmRsZXJLZXkgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ciA/IGBvbiR7Y2FwaXRhbGl6ZShzdHIpfWAgOiBgYCk7XG52YXIgaGFzQ2hhbmdlZCA9ICh2YWx1ZSwgb2xkVmFsdWUpID0+IHZhbHVlICE9PSBvbGRWYWx1ZSAmJiAodmFsdWUgPT09IHZhbHVlIHx8IG9sZFZhbHVlID09PSBvbGRWYWx1ZSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AdnVlL3JlYWN0aXZpdHkvZGlzdC9yZWFjdGl2aXR5LmVzbS1idW5kbGVyLmpzXG52YXIgdGFyZ2V0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgZWZmZWN0U3RhY2sgPSBbXTtcbnZhciBhY3RpdmVFZmZlY3Q7XG52YXIgSVRFUkFURV9LRVkgPSBTeW1ib2wodHJ1ZSA/IFwiaXRlcmF0ZVwiIDogXCJcIik7XG52YXIgTUFQX0tFWV9JVEVSQVRFX0tFWSA9IFN5bWJvbCh0cnVlID8gXCJNYXAga2V5IGl0ZXJhdGVcIiA6IFwiXCIpO1xuZnVuY3Rpb24gaXNFZmZlY3QoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZuLl9pc0VmZmVjdCA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVmZmVjdDIoZm4sIG9wdGlvbnMgPSBFTVBUWV9PQkopIHtcbiAgaWYgKGlzRWZmZWN0KGZuKSkge1xuICAgIGZuID0gZm4ucmF3O1xuICB9XG4gIGNvbnN0IGVmZmVjdDMgPSBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucyk7XG4gIGlmICghb3B0aW9ucy5sYXp5KSB7XG4gICAgZWZmZWN0MygpO1xuICB9XG4gIHJldHVybiBlZmZlY3QzO1xufVxuZnVuY3Rpb24gc3RvcChlZmZlY3QzKSB7XG4gIGlmIChlZmZlY3QzLmFjdGl2ZSkge1xuICAgIGNsZWFudXAoZWZmZWN0Myk7XG4gICAgaWYgKGVmZmVjdDMub3B0aW9ucy5vblN0b3ApIHtcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5vblN0b3AoKTtcbiAgICB9XG4gICAgZWZmZWN0My5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufVxudmFyIHVpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGl2ZUVmZmVjdChmbiwgb3B0aW9ucykge1xuICBjb25zdCBlZmZlY3QzID0gZnVuY3Rpb24gcmVhY3RpdmVFZmZlY3QoKSB7XG4gICAgaWYgKCFlZmZlY3QzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGlmICghZWZmZWN0U3RhY2suaW5jbHVkZXMoZWZmZWN0MykpIHtcbiAgICAgIGNsZWFudXAoZWZmZWN0Myk7XG4gICAgICB0cnkge1xuICAgICAgICBlbmFibGVUcmFja2luZygpO1xuICAgICAgICBlZmZlY3RTdGFjay5wdXNoKGVmZmVjdDMpO1xuICAgICAgICBhY3RpdmVFZmZlY3QgPSBlZmZlY3QzO1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGVmZmVjdFN0YWNrLnBvcCgpO1xuICAgICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICAgIGFjdGl2ZUVmZmVjdCA9IGVmZmVjdFN0YWNrW2VmZmVjdFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZWZmZWN0My5pZCA9IHVpZCsrO1xuICBlZmZlY3QzLmFsbG93UmVjdXJzZSA9ICEhb3B0aW9ucy5hbGxvd1JlY3Vyc2U7XG4gIGVmZmVjdDMuX2lzRWZmZWN0ID0gdHJ1ZTtcbiAgZWZmZWN0My5hY3RpdmUgPSB0cnVlO1xuICBlZmZlY3QzLnJhdyA9IGZuO1xuICBlZmZlY3QzLmRlcHMgPSBbXTtcbiAgZWZmZWN0My5vcHRpb25zID0gb3B0aW9ucztcbiAgcmV0dXJuIGVmZmVjdDM7XG59XG5mdW5jdGlvbiBjbGVhbnVwKGVmZmVjdDMpIHtcbiAgY29uc3QgeyBkZXBzIH0gPSBlZmZlY3QzO1xuICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdDMpO1xuICAgIH1cbiAgICBkZXBzLmxlbmd0aCA9IDA7XG4gIH1cbn1cbnZhciBzaG91bGRUcmFjayA9IHRydWU7XG52YXIgdHJhY2tTdGFjayA9IFtdO1xuZnVuY3Rpb24gcGF1c2VUcmFja2luZygpIHtcbiAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcbiAgc2hvdWxkVHJhY2sgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVuYWJsZVRyYWNraW5nKCkge1xuICB0cmFja1N0YWNrLnB1c2goc2hvdWxkVHJhY2spO1xuICBzaG91bGRUcmFjayA9IHRydWU7XG59XG5mdW5jdGlvbiByZXNldFRyYWNraW5nKCkge1xuICBjb25zdCBsYXN0ID0gdHJhY2tTdGFjay5wb3AoKTtcbiAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB2b2lkIDAgPyB0cnVlIDogbGFzdDtcbn1cbmZ1bmN0aW9uIHRyYWNrKHRhcmdldCwgdHlwZSwga2V5KSB7XG4gIGlmICghc2hvdWxkVHJhY2sgfHwgYWN0aXZlRWZmZWN0ID09PSB2b2lkIDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XG4gIGlmICghZGVwc01hcCkge1xuICAgIHRhcmdldE1hcC5zZXQodGFyZ2V0LCBkZXBzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XG4gIGlmICghZGVwKSB7XG4gICAgZGVwc01hcC5zZXQoa2V5LCBkZXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgfVxuICBpZiAoIWRlcC5oYXMoYWN0aXZlRWZmZWN0KSkge1xuICAgIGRlcC5hZGQoYWN0aXZlRWZmZWN0KTtcbiAgICBhY3RpdmVFZmZlY3QuZGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2spIHtcbiAgICAgIGFjdGl2ZUVmZmVjdC5vcHRpb25zLm9uVHJhY2soe1xuICAgICAgICBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0eXBlLFxuICAgICAgICBrZXlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcbiAgY29uc3QgZGVwc01hcCA9IHRhcmdldE1hcC5nZXQodGFyZ2V0KTtcbiAgaWYgKCFkZXBzTWFwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGVmZmVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhZGQyID0gKGVmZmVjdHNUb0FkZCkgPT4ge1xuICAgIGlmIChlZmZlY3RzVG9BZGQpIHtcbiAgICAgIGVmZmVjdHNUb0FkZC5mb3JFYWNoKChlZmZlY3QzKSA9PiB7XG4gICAgICAgIGlmIChlZmZlY3QzICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0My5hbGxvd1JlY3Vyc2UpIHtcbiAgICAgICAgICBlZmZlY3RzLmFkZChlZmZlY3QzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBpZiAodHlwZSA9PT0gXCJjbGVhclwiKSB7XG4gICAgZGVwc01hcC5mb3JFYWNoKGFkZDIpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsZW5ndGhcIiAmJiBpc0FycmF5KHRhcmdldCkpIHtcbiAgICBkZXBzTWFwLmZvckVhY2goKGRlcCwga2V5MikgPT4ge1xuICAgICAgaWYgKGtleTIgPT09IFwibGVuZ3RoXCIgfHwga2V5MiA+PSBuZXdWYWx1ZSkge1xuICAgICAgICBhZGQyKGRlcCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XG4gICAgICBhZGQyKGRlcHNNYXAuZ2V0KGtleSkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICBhZGQyKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XG4gICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0ludGVnZXJLZXkoa2V5KSkge1xuICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoXCJsZW5ndGhcIikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgICAgYWRkMihkZXBzTWFwLmdldChNQVBfS0VZX0lURVJBVEVfS0VZKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xuICAgICAgICAgIGFkZDIoZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgcnVuID0gKGVmZmVjdDMpID0+IHtcbiAgICBpZiAoZWZmZWN0My5vcHRpb25zLm9uVHJpZ2dlcikge1xuICAgICAgZWZmZWN0My5vcHRpb25zLm9uVHJpZ2dlcih7XG4gICAgICAgIGVmZmVjdDogZWZmZWN0MyxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXksXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgb2xkVGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdDMub3B0aW9ucy5zY2hlZHVsZXIpIHtcbiAgICAgIGVmZmVjdDMub3B0aW9ucy5zY2hlZHVsZXIoZWZmZWN0Myk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVmZmVjdDMoKTtcbiAgICB9XG4gIH07XG4gIGVmZmVjdHMuZm9yRWFjaChydW4pO1xufVxudmFyIGlzTm9uVHJhY2thYmxlS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcbnZhciBidWlsdEluU3ltYm9scyA9IG5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5tYXAoKGtleSkgPT4gU3ltYm9sW2tleV0pLmZpbHRlcihpc1N5bWJvbCkpO1xudmFyIGdldDIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKCk7XG52YXIgcmVhZG9ubHlHZXQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xudmFyIGFycmF5SW5zdHJ1bWVudGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUFycmF5SW5zdHJ1bWVudGF0aW9ucygpIHtcbiAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xuICBbXCJpbmNsdWRlc1wiLCBcImluZGV4T2ZcIiwgXCJsYXN0SW5kZXhPZlwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpbnN0cnVtZW50YXRpb25zW2tleV0gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBjb25zdCBhcnIgPSB0b1Jhdyh0aGlzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJhY2soYXJyLCBcImdldFwiLCBpICsgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXMgPSBhcnJba2V5XSguLi5hcmdzKTtcbiAgICAgIGlmIChyZXMgPT09IC0xIHx8IHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGFycltrZXldKC4uLmFyZ3MubWFwKHRvUmF3KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBbXCJwdXNoXCIsIFwicG9wXCIsIFwic2hpZnRcIiwgXCJ1bnNoaWZ0XCIsIFwic3BsaWNlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIHBhdXNlVHJhY2tpbmcoKTtcbiAgICAgIGNvbnN0IHJlcyA9IHRvUmF3KHRoaXMpW2tleV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICByZXNldFRyYWNraW5nKCk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gaW5zdHJ1bWVudGF0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlcihpc1JlYWRvbmx5ID0gZmFsc2UsIHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0Myh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIpIHtcbiAgICAgIHJldHVybiAhaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgJiYgcmVjZWl2ZXIgPT09IChpc1JlYWRvbmx5ID8gc2hhbGxvdyA/IHNoYWxsb3dSZWFkb25seU1hcCA6IHJlYWRvbmx5TWFwIDogc2hhbGxvdyA/IHNoYWxsb3dSZWFjdGl2ZU1hcCA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0SXNBcnJheSA9IGlzQXJyYXkodGFyZ2V0KTtcbiAgICBpZiAoIWlzUmVhZG9ubHkgJiYgdGFyZ2V0SXNBcnJheSAmJiBoYXNPd24oYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXkpKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXQoYXJyYXlJbnN0cnVtZW50YXRpb25zLCBrZXksIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICBpZiAoaXNTeW1ib2woa2V5KSA/IGJ1aWx0SW5TeW1ib2xzLmhhcyhrZXkpIDogaXNOb25UcmFja2FibGVLZXlzKGtleSkpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICghaXNSZWFkb25seSkge1xuICAgICAgdHJhY2sodGFyZ2V0LCBcImdldFwiLCBrZXkpO1xuICAgIH1cbiAgICBpZiAoc2hhbGxvdykge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKGlzUmVmKHJlcykpIHtcbiAgICAgIGNvbnN0IHNob3VsZFVud3JhcCA9ICF0YXJnZXRJc0FycmF5IHx8ICFpc0ludGVnZXJLZXkoa2V5KTtcbiAgICAgIHJldHVybiBzaG91bGRVbndyYXAgPyByZXMudmFsdWUgOiByZXM7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICByZXR1cm4gaXNSZWFkb25seSA/IHJlYWRvbmx5KHJlcykgOiByZWFjdGl2ZTIocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cbnZhciBzZXQyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVNldHRlcigpO1xuZnVuY3Rpb24gY3JlYXRlU2V0dGVyKHNoYWxsb3cgPSBmYWxzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gc2V0Myh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgbGV0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgICAgIG9sZFZhbHVlID0gdG9SYXcob2xkVmFsdWUpO1xuICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aCA6IGhhc093bih0YXJnZXQsIGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgaWYgKHRhcmdldCA9PT0gdG9SYXcocmVjZWl2ZXIpKSB7XG4gICAgICBpZiAoIWhhZEtleSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiwga2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NoYW5nZWQodmFsdWUsIG9sZFZhbHVlKSkge1xuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcbiAgY29uc3Qgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSk7XG4gIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIsIGtleSwgdm9pZCAwLCBvbGRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhcyh0YXJnZXQsIGtleSkge1xuICBjb25zdCByZXN1bHQgPSBSZWZsZWN0Lmhhcyh0YXJnZXQsIGtleSk7XG4gIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcbiAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG93bktleXModGFyZ2V0KSB7XG4gIHRyYWNrKHRhcmdldCwgXCJpdGVyYXRlXCIsIGlzQXJyYXkodGFyZ2V0KSA/IFwibGVuZ3RoXCIgOiBJVEVSQVRFX0tFWSk7XG4gIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbn1cbnZhciBtdXRhYmxlSGFuZGxlcnMgPSB7XG4gIGdldDogZ2V0MixcbiAgc2V0OiBzZXQyLFxuICBkZWxldGVQcm9wZXJ0eSxcbiAgaGFzLFxuICBvd25LZXlzXG59O1xudmFyIHJlYWRvbmx5SGFuZGxlcnMgPSB7XG4gIGdldDogcmVhZG9ubHlHZXQsXG4gIHNldCh0YXJnZXQsIGtleSkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgY29uc29sZS53YXJuKGBEZWxldGUgb3BlcmF0aW9uIG9uIGtleSBcIiR7U3RyaW5nKGtleSl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCwgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG52YXIgdG9SZWFjdGl2ZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpID8gcmVhY3RpdmUyKHZhbHVlKSA6IHZhbHVlO1xudmFyIHRvUmVhZG9ubHkgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWRvbmx5KHZhbHVlKSA6IHZhbHVlO1xudmFyIHRvU2hhbGxvdyA9ICh2YWx1ZSkgPT4gdmFsdWU7XG52YXIgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcbmZ1bmN0aW9uIGdldCQxKHRhcmdldCwga2V5LCBpc1JlYWRvbmx5ID0gZmFsc2UsIGlzU2hhbGxvdyA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcbiAgICBcIl9fdl9yYXdcIlxuICAgIC8qIFJBVyAqL1xuICBdO1xuICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xuICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiZ2V0XCIsIGtleSk7XG4gIH1cbiAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcImdldFwiLCByYXdLZXkpO1xuICBjb25zdCB7IGhhczogaGFzMiB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcbiAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KGtleSkpO1xuICB9IGVsc2UgaWYgKGhhczIuY2FsbChyYXdUYXJnZXQsIHJhd0tleSkpIHtcbiAgICByZXR1cm4gd3JhcCh0YXJnZXQuZ2V0KHJhd0tleSkpO1xuICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gcmF3VGFyZ2V0KSB7XG4gICAgdGFyZ2V0LmdldChrZXkpO1xuICB9XG59XG5mdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xuICBjb25zdCB0YXJnZXQgPSB0aGlzW1xuICAgIFwiX192X3Jhd1wiXG4gICAgLyogUkFXICovXG4gIF07XG4gIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XG4gIGlmIChrZXkgIT09IHJhd0tleSkge1xuICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJoYXNcIiwga2V5KTtcbiAgfVxuICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaGFzXCIsIHJhd0tleSk7XG4gIHJldHVybiBrZXkgPT09IHJhd0tleSA/IHRhcmdldC5oYXMoa2V5KSA6IHRhcmdldC5oYXMoa2V5KSB8fCB0YXJnZXQuaGFzKHJhd0tleSk7XG59XG5mdW5jdGlvbiBzaXplKHRhcmdldCwgaXNSZWFkb25seSA9IGZhbHNlKSB7XG4gIHRhcmdldCA9IHRhcmdldFtcbiAgICBcIl9fdl9yYXdcIlxuICAgIC8qIFJBVyAqL1xuICBdO1xuICAhaXNSZWFkb25seSAmJiB0cmFjayh0b1Jhdyh0YXJnZXQpLCBcIml0ZXJhdGVcIiwgSVRFUkFURV9LRVkpO1xuICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBcInNpemVcIiwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcbiAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XG4gIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgY29uc3QgaGFkS2V5ID0gcHJvdG8uaGFzLmNhbGwodGFyZ2V0LCB2YWx1ZSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAgdGFyZ2V0LmFkZCh2YWx1ZSk7XG4gICAgdHJpZ2dlcih0YXJnZXQsIFwiYWRkXCIsIHZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XG4gIHZhbHVlID0gdG9SYXcodmFsdWUpO1xuICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcbiAgY29uc3QgeyBoYXM6IGhhczIsIGdldDogZ2V0MyB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcbiAgbGV0IGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIGlmICghaGFkS2V5KSB7XG4gICAga2V5ID0gdG9SYXcoa2V5KTtcbiAgICBoYWRLZXkgPSBoYXMyLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB9IGVsc2UgaWYgKHRydWUpIHtcbiAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhczIsIGtleSk7XG4gIH1cbiAgY29uc3Qgb2xkVmFsdWUgPSBnZXQzLmNhbGwodGFyZ2V0LCBrZXkpO1xuICB0YXJnZXQuc2V0KGtleSwgdmFsdWUpO1xuICBpZiAoIWhhZEtleSkge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiwga2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZGVsZXRlRW50cnkoa2V5KSB7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCB7IGhhczogaGFzMiwgZ2V0OiBnZXQzIH0gPSBnZXRQcm90byh0YXJnZXQpO1xuICBsZXQgaGFkS2V5ID0gaGFzMi5jYWxsKHRhcmdldCwga2V5KTtcbiAgaWYgKCFoYWRLZXkpIHtcbiAgICBrZXkgPSB0b1JhdyhrZXkpO1xuICAgIGhhZEtleSA9IGhhczIuY2FsbCh0YXJnZXQsIGtleSk7XG4gIH0gZWxzZSBpZiAodHJ1ZSkge1xuICAgIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzMiwga2V5KTtcbiAgfVxuICBjb25zdCBvbGRWYWx1ZSA9IGdldDMgPyBnZXQzLmNhbGwodGFyZ2V0LCBrZXkpIDogdm9pZCAwO1xuICBjb25zdCByZXN1bHQgPSB0YXJnZXQuZGVsZXRlKGtleSk7XG4gIGlmIChoYWRLZXkpIHtcbiAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiwga2V5LCB2b2lkIDAsIG9sZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xuICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xuICBjb25zdCBvbGRUYXJnZXQgPSB0cnVlID8gaXNNYXAodGFyZ2V0KSA/IG5ldyBNYXAodGFyZ2V0KSA6IG5ldyBTZXQodGFyZ2V0KSA6IHZvaWQgMDtcbiAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XG4gIGlmIChoYWRJdGVtcykge1xuICAgIHRyaWdnZXIodGFyZ2V0LCBcImNsZWFyXCIsIHZvaWQgMCwgdm9pZCAwLCBvbGRUYXJnZXQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JFYWNoKGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICByZXR1cm4gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGNvbnN0IG9ic2VydmVkID0gdGhpcztcbiAgICBjb25zdCB0YXJnZXQgPSBvYnNlcnZlZFtcbiAgICAgIFwiX192X3Jhd1wiXG4gICAgICAvKiBSQVcgKi9cbiAgICBdO1xuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XG4gICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcbiAgICAhaXNSZWFkb25seSAmJiB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiLCBJVEVSQVRFX0tFWSk7XG4gICAgcmV0dXJuIHRhcmdldC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGlzUmVhZG9ubHksIGlzU2hhbGxvdykge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXNbXG4gICAgICBcIl9fdl9yYXdcIlxuICAgICAgLyogUkFXICovXG4gICAgXTtcbiAgICBjb25zdCByYXdUYXJnZXQgPSB0b1Jhdyh0YXJnZXQpO1xuICAgIGNvbnN0IHRhcmdldElzTWFwID0gaXNNYXAocmF3VGFyZ2V0KTtcbiAgICBjb25zdCBpc1BhaXIgPSBtZXRob2QgPT09IFwiZW50cmllc1wiIHx8IG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwO1xuICAgIGNvbnN0IGlzS2V5T25seSA9IG1ldGhvZCA9PT0gXCJrZXlzXCIgJiYgdGFyZ2V0SXNNYXA7XG4gICAgY29uc3QgaW5uZXJJdGVyYXRvciA9IHRhcmdldFttZXRob2RdKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2socmF3VGFyZ2V0LCBcIml0ZXJhdGVcIiwgaXNLZXlPbmx5ID8gTUFQX0tFWV9JVEVSQVRFX0tFWSA6IElURVJBVEVfS0VZKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGlubmVySXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gZG9uZSA/IHsgdmFsdWUsIGRvbmUgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogaXNQYWlyID8gW3dyYXAodmFsdWVbMF0pLCB3cmFwKHZhbHVlWzFdKV0gOiB3cmFwKHZhbHVlKSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHlNZXRob2QodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb25zdCBrZXkgPSBhcmdzWzBdID8gYG9uIGtleSBcIiR7YXJnc1swXX1cIiBgIDogYGA7XG4gICAgICBjb25zb2xlLndhcm4oYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRvUmF3KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgPyBmYWxzZSA6IHRoaXM7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xuICBjb25zdCBtdXRhYmxlSW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBzaXplKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzOiBoYXMkMSxcbiAgICBhZGQsXG4gICAgc2V0OiBzZXQkMSxcbiAgICBkZWxldGU6IGRlbGV0ZUVudHJ5LFxuICAgIGNsZWFyLFxuICAgIGZvckVhY2g6IGNyZWF0ZUZvckVhY2goZmFsc2UsIGZhbHNlKVxuICB9O1xuICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9uczIgPSB7XG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgZmFsc2UsIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcbiAgICB9LFxuICAgIGhhczogaGFzJDEsXG4gICAgYWRkLFxuICAgIHNldDogc2V0JDEsXG4gICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcbiAgICBjbGVhcixcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxuICB9O1xuICBjb25zdCByZWFkb25seUluc3RydW1lbnRhdGlvbnMyID0ge1xuICAgIGdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gc2l6ZSh0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxuICAgICAgXCJhZGRcIlxuICAgICAgLyogQUREICovXG4gICAgKSxcbiAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxuICAgICAgXCJzZXRcIlxuICAgICAgLyogU0VUICovXG4gICAgKSxcbiAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxuICAgICAgXCJkZWxldGVcIlxuICAgICAgLyogREVMRVRFICovXG4gICAgKSxcbiAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXG4gICAgICBcImNsZWFyXCJcbiAgICAgIC8qIENMRUFSICovXG4gICAgKSxcbiAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIGZhbHNlKVxuICB9O1xuICBjb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMiA9IHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5LCB0cnVlLCB0cnVlKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBoYXMoa2V5KSB7XG4gICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH0sXG4gICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcbiAgICAgIFwiYWRkXCJcbiAgICAgIC8qIEFERCAqL1xuICAgICksXG4gICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcbiAgICAgIFwic2V0XCJcbiAgICAgIC8qIFNFVCAqL1xuICAgICksXG4gICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcbiAgICAgIFwiZGVsZXRlXCJcbiAgICAgIC8qIERFTEVURSAqL1xuICAgICksXG4gICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFxuICAgICAgXCJjbGVhclwiXG4gICAgICAvKiBDTEVBUiAqL1xuICAgICksXG4gICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCB0cnVlKVxuICB9O1xuICBjb25zdCBpdGVyYXRvck1ldGhvZHMgPSBbXCJrZXlzXCIsIFwidmFsdWVzXCIsIFwiZW50cmllc1wiLCBTeW1ib2wuaXRlcmF0b3JdO1xuICBpdGVyYXRvck1ldGhvZHMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCBmYWxzZSk7XG4gICAgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcbiAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zMlttZXRob2RdID0gY3JlYXRlSXRlcmFibGVNZXRob2QobWV0aG9kLCB0cnVlLCB0cnVlKTtcbiAgfSk7XG4gIHJldHVybiBbXG4gICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMyLFxuICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uczIsXG4gICAgc2hhbGxvd0luc3RydW1lbnRhdGlvbnMyLFxuICAgIHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnMyXG4gIF07XG59XG52YXIgW211dGFibGVJbnN0cnVtZW50YXRpb25zLCByZWFkb25seUluc3RydW1lbnRhdGlvbnMsIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoaXNSZWFkb25seSwgc2hhbGxvdykge1xuICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvdyA/IGlzUmVhZG9ubHkgPyBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogc2hhbGxvd0luc3RydW1lbnRhdGlvbnMgOiBpc1JlYWRvbmx5ID8gcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zIDogbXV0YWJsZUluc3RydW1lbnRhdGlvbnM7XG4gIHJldHVybiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFjdGl2ZVwiKSB7XG4gICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIikge1xuICAgICAgcmV0dXJuIGlzUmVhZG9ubHk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiX192X3Jhd1wiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gUmVmbGVjdC5nZXQoaGFzT3duKGluc3RydW1lbnRhdGlvbnMsIGtleSkgJiYga2V5IGluIHRhcmdldCA/IGluc3RydW1lbnRhdGlvbnMgOiB0YXJnZXQsIGtleSwgcmVjZWl2ZXIpO1xuICB9O1xufVxudmFyIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgZmFsc2UpXG59O1xudmFyIHJlYWRvbmx5Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIodHJ1ZSwgZmFsc2UpXG59O1xuZnVuY3Rpb24gY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMyLCBrZXkpIHtcbiAgY29uc3QgcmF3S2V5ID0gdG9SYXcoa2V5KTtcbiAgaWYgKHJhd0tleSAhPT0ga2V5ICYmIGhhczIuY2FsbCh0YXJnZXQsIHJhd0tleSkpIHtcbiAgICBjb25zdCB0eXBlID0gdG9SYXdUeXBlKHRhcmdldCk7XG4gICAgY29uc29sZS53YXJuKGBSZWFjdGl2ZSAke3R5cGV9IGNvbnRhaW5zIGJvdGggdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIHdoaWNoIGNhbiBsZWFkIHRvIGluY29uc2lzdGVuY2llcy4gQXZvaWQgZGlmZmVyZW50aWF0aW5nIGJldHdlZW4gdGhlIHJhdyBhbmQgcmVhY3RpdmUgdmVyc2lvbnMgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcbiAgfVxufVxudmFyIHJlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgc2hhbGxvd1JlYWN0aXZlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgcmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBzaGFsbG93UmVhZG9ubHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHRhcmdldFR5cGVNYXAocmF3VHlwZSkge1xuICBzd2l0Y2ggKHJhd1R5cGUpIHtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgIHJldHVybiAyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VHlwZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbXG4gICAgXCJfX3Zfc2tpcFwiXG4gICAgLyogU0tJUCAqL1xuICBdIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSA/IDAgOiB0YXJnZXRUeXBlTWFwKHRvUmF3VHlwZSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gcmVhY3RpdmUyKHRhcmdldCkge1xuICBpZiAodGFyZ2V0ICYmIHRhcmdldFtcbiAgICBcIl9fdl9pc1JlYWRvbmx5XCJcbiAgICAvKiBJU19SRUFET05MWSAqL1xuICBdKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBmYWxzZSwgbXV0YWJsZUhhbmRsZXJzLCBtdXRhYmxlQ29sbGVjdGlvbkhhbmRsZXJzLCByZWFjdGl2ZU1hcCk7XG59XG5mdW5jdGlvbiByZWFkb25seSh0YXJnZXQpIHtcbiAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgaXNSZWFkb25seSwgYmFzZUhhbmRsZXJzLCBjb2xsZWN0aW9uSGFuZGxlcnMsIHByb3h5TWFwKSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWN0aXZlOiAke1N0cmluZyh0YXJnZXQpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXRbXG4gICAgXCJfX3ZfcmF3XCJcbiAgICAvKiBSQVcgKi9cbiAgXSAmJiAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1xuICAgIFwiX192X2lzUmVhY3RpdmVcIlxuICAgIC8qIElTX1JFQUNUSVZFICovXG4gIF0pKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XG4gIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nUHJveHk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0VHlwZSA9IGdldFRhcmdldFR5cGUodGFyZ2V0KTtcbiAgaWYgKHRhcmdldFR5cGUgPT09IDApIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwgdGFyZ2V0VHlwZSA9PT0gMiA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVycyk7XG4gIHByb3h5TWFwLnNldCh0YXJnZXQsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcbiAgcmV0dXJuIG9ic2VydmVkICYmIHRvUmF3KG9ic2VydmVkW1xuICAgIFwiX192X3Jhd1wiXG4gICAgLyogUkFXICovXG4gIF0pIHx8IG9ic2VydmVkO1xufVxuZnVuY3Rpb24gaXNSZWYocikge1xuICByZXR1cm4gQm9vbGVhbihyICYmIHIuX192X2lzUmVmID09PSB0cnVlKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy8kbmV4dFRpY2suanNcbm1hZ2ljKFwibmV4dFRpY2tcIiwgKCkgPT4gbmV4dFRpY2spO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRkaXNwYXRjaC5qc1xubWFnaWMoXCJkaXNwYXRjaFwiLCAoZWwpID0+IGRpc3BhdGNoLmJpbmQoZGlzcGF0Y2gsIGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHdhdGNoLmpzXG5tYWdpYyhcIndhdGNoXCIsIChlbCwgeyBldmFsdWF0ZUxhdGVyOiBldmFsdWF0ZUxhdGVyMiwgY2xlYW51cDogY2xlYW51cDIgfSkgPT4gKGtleSwgY2FsbGJhY2spID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGtleSk7XG4gIGxldCBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGV2YWx1YXRlMigoaSkgPT4gdmFsdWUgPSBpKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGxldCB1bndhdGNoID0gd2F0Y2goZ2V0dGVyLCBjYWxsYmFjayk7XG4gIGNsZWFudXAyKHVud2F0Y2gpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHN0b3JlLmpzXG5tYWdpYyhcInN0b3JlXCIsIGdldFN0b3Jlcyk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGRhdGEuanNcbm1hZ2ljKFwiZGF0YVwiLCAoZWwpID0+IHNjb3BlKGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJvb3QuanNcbm1hZ2ljKFwicm9vdFwiLCAoZWwpID0+IGNsb3Nlc3RSb290KGVsKSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJHJlZnMuanNcbm1hZ2ljKFwicmVmc1wiLCAoZWwpID0+IHtcbiAgaWYgKGVsLl94X3JlZnNfcHJveHkpXG4gICAgcmV0dXJuIGVsLl94X3JlZnNfcHJveHk7XG4gIGVsLl94X3JlZnNfcHJveHkgPSBtZXJnZVByb3hpZXMoZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkpO1xuICByZXR1cm4gZWwuX3hfcmVmc19wcm94eTtcbn0pO1xuZnVuY3Rpb24gZ2V0QXJyYXlPZlJlZk9iamVjdChlbCkge1xuICBsZXQgcmVmT2JqZWN0cyA9IFtdO1xuICBmaW5kQ2xvc2VzdChlbCwgKGkpID0+IHtcbiAgICBpZiAoaS5feF9yZWZzKVxuICAgICAgcmVmT2JqZWN0cy5wdXNoKGkuX3hfcmVmcyk7XG4gIH0pO1xuICByZXR1cm4gcmVmT2JqZWN0cztcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2lkcy5qc1xudmFyIGdsb2JhbElkTWVtbyA9IHt9O1xuZnVuY3Rpb24gZmluZEFuZEluY3JlbWVudElkKG5hbWUpIHtcbiAgaWYgKCFnbG9iYWxJZE1lbW9bbmFtZV0pXG4gICAgZ2xvYmFsSWRNZW1vW25hbWVdID0gMDtcbiAgcmV0dXJuICsrZ2xvYmFsSWRNZW1vW25hbWVdO1xufVxuZnVuY3Rpb24gY2xvc2VzdElkUm9vdChlbCwgbmFtZSkge1xuICByZXR1cm4gZmluZENsb3Nlc3QoZWwsIChlbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsZW1lbnQuX3hfaWRzICYmIGVsZW1lbnQuX3hfaWRzW25hbWVdKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0SWRSb290KGVsLCBuYW1lKSB7XG4gIGlmICghZWwuX3hfaWRzKVxuICAgIGVsLl94X2lkcyA9IHt9O1xuICBpZiAoIWVsLl94X2lkc1tuYW1lXSlcbiAgICBlbC5feF9pZHNbbmFtZV0gPSBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9tYWdpY3MvJGlkLmpzXG5tYWdpYyhcImlkXCIsIChlbCwgeyBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiAobmFtZSwga2V5ID0gbnVsbCkgPT4ge1xuICBsZXQgY2FjaGVLZXkgPSBgJHtuYW1lfSR7a2V5ID8gYC0ke2tleX1gIDogXCJcIn1gO1xuICByZXR1cm4gY2FjaGVJZEJ5TmFtZU9uRWxlbWVudChlbCwgY2FjaGVLZXksIGNsZWFudXAyLCAoKSA9PiB7XG4gICAgbGV0IHJvb3QgPSBjbG9zZXN0SWRSb290KGVsLCBuYW1lKTtcbiAgICBsZXQgaWQgPSByb290ID8gcm9vdC5feF9pZHNbbmFtZV0gOiBmaW5kQW5kSW5jcmVtZW50SWQobmFtZSk7XG4gICAgcmV0dXJuIGtleSA/IGAke25hbWV9LSR7aWR9LSR7a2V5fWAgOiBgJHtuYW1lfS0ke2lkfWA7XG4gIH0pO1xufSk7XG5pbnRlcmNlcHRDbG9uZSgoZnJvbSwgdG8pID0+IHtcbiAgaWYgKGZyb20uX3hfaWQpIHtcbiAgICB0by5feF9pZCA9IGZyb20uX3hfaWQ7XG4gIH1cbn0pO1xuZnVuY3Rpb24gY2FjaGVJZEJ5TmFtZU9uRWxlbWVudChlbCwgY2FjaGVLZXksIGNsZWFudXAyLCBjYWxsYmFjaykge1xuICBpZiAoIWVsLl94X2lkKVxuICAgIGVsLl94X2lkID0ge307XG4gIGlmIChlbC5feF9pZFtjYWNoZUtleV0pXG4gICAgcmV0dXJuIGVsLl94X2lkW2NhY2hlS2V5XTtcbiAgbGV0IG91dHB1dCA9IGNhbGxiYWNrKCk7XG4gIGVsLl94X2lkW2NhY2hlS2V5XSA9IG91dHB1dDtcbiAgY2xlYW51cDIoKCkgPT4ge1xuICAgIGRlbGV0ZSBlbC5feF9pZFtjYWNoZUtleV07XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvbWFnaWNzLyRlbC5qc1xubWFnaWMoXCJlbFwiLCAoZWwpID0+IGVsKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL21hZ2ljcy9pbmRleC5qc1xud2Fybk1pc3NpbmdQbHVnaW5NYWdpYyhcIkZvY3VzXCIsIFwiZm9jdXNcIiwgXCJmb2N1c1wiKTtcbndhcm5NaXNzaW5nUGx1Z2luTWFnaWMoXCJQZXJzaXN0XCIsIFwicGVyc2lzdFwiLCBcInBlcnNpc3RcIik7XG5mdW5jdGlvbiB3YXJuTWlzc2luZ1BsdWdpbk1hZ2ljKG5hbWUsIG1hZ2ljTmFtZSwgc2x1Zykge1xuICBtYWdpYyhtYWdpY05hbWUsIChlbCkgPT4gd2FybihgWW91IGNhbid0IHVzZSBbJCR7bWFnaWNOYW1lfV0gd2l0aG91dCBmaXJzdCBpbnN0YWxsaW5nIHRoZSBcIiR7bmFtZX1cIiBwbHVnaW4gaGVyZTogaHR0cHM6Ly9hbHBpbmVqcy5kZXYvcGx1Z2lucy8ke3NsdWd9YCwgZWwpKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1tb2RlbGFibGUuanNcbmRpcmVjdGl2ZShcIm1vZGVsYWJsZVwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjIsIGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcbiAgbGV0IGZ1bmMgPSBldmFsdWF0ZUxhdGVyMihleHByZXNzaW9uKTtcbiAgbGV0IGlubmVyR2V0ID0gKCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZnVuYygoaSkgPT4gcmVzdWx0ID0gaSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbGV0IGV2YWx1YXRlSW5uZXJTZXQgPSBldmFsdWF0ZUxhdGVyMihgJHtleHByZXNzaW9ufSA9IF9fcGxhY2Vob2xkZXJgKTtcbiAgbGV0IGlubmVyU2V0ID0gKHZhbCkgPT4gZXZhbHVhdGVJbm5lclNldCgoKSA9PiB7XG4gIH0sIHsgc2NvcGU6IHsgXCJfX3BsYWNlaG9sZGVyXCI6IHZhbCB9IH0pO1xuICBsZXQgaW5pdGlhbFZhbHVlID0gaW5uZXJHZXQoKTtcbiAgaW5uZXJTZXQoaW5pdGlhbFZhbHVlKTtcbiAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgIGlmICghZWwuX3hfbW9kZWwpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfcmVtb3ZlTW9kZWxMaXN0ZW5lcnNbXCJkZWZhdWx0XCJdKCk7XG4gICAgbGV0IG91dGVyR2V0ID0gZWwuX3hfbW9kZWwuZ2V0O1xuICAgIGxldCBvdXRlclNldCA9IGVsLl94X21vZGVsLnNldDtcbiAgICBsZXQgcmVsZWFzZUVudGFuZ2xlbWVudCA9IGVudGFuZ2xlKFxuICAgICAge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyR2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIG91dGVyU2V0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBpbm5lckdldCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICBpbm5lclNldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGNsZWFudXAyKHJlbGVhc2VFbnRhbmdsZW1lbnQpO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRlbGVwb3J0LmpzXG5kaXJlY3RpdmUoXCJ0ZWxlcG9ydFwiLCAoZWwsIHsgbW9kaWZpZXJzLCBleHByZXNzaW9uIH0sIHsgY2xlYW51cDogY2xlYW51cDIgfSkgPT4ge1xuICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInRlbXBsYXRlXCIpXG4gICAgd2FybihcIngtdGVsZXBvcnQgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIDx0ZW1wbGF0ZT4gdGFnXCIsIGVsKTtcbiAgbGV0IHRhcmdldCA9IGdldFRhcmdldChleHByZXNzaW9uKTtcbiAgbGV0IGNsb25lMiA9IGVsLmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpLmZpcnN0RWxlbWVudENoaWxkO1xuICBlbC5feF90ZWxlcG9ydCA9IGNsb25lMjtcbiAgY2xvbmUyLl94X3RlbGVwb3J0QmFjayA9IGVsO1xuICBlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlbGVwb3J0LXRlbXBsYXRlXCIsIHRydWUpO1xuICBjbG9uZTIuc2V0QXR0cmlidXRlKFwiZGF0YS10ZWxlcG9ydC10YXJnZXRcIiwgdHJ1ZSk7XG4gIGlmIChlbC5feF9mb3J3YXJkRXZlbnRzKSB7XG4gICAgZWwuX3hfZm9yd2FyZEV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgIGNsb25lMi5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgZS5jb25zdHJ1Y3RvcihlLnR5cGUsIGUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFkZFNjb3BlVG9Ob2RlKGNsb25lMiwge30sIGVsKTtcbiAgbGV0IHBsYWNlSW5Eb20gPSAoY2xvbmUzLCB0YXJnZXQyLCBtb2RpZmllcnMyKSA9PiB7XG4gICAgaWYgKG1vZGlmaWVyczIuaW5jbHVkZXMoXCJwcmVwZW5kXCIpKSB7XG4gICAgICB0YXJnZXQyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lMywgdGFyZ2V0Mik7XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMyLmluY2x1ZGVzKFwiYXBwZW5kXCIpKSB7XG4gICAgICB0YXJnZXQyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lMywgdGFyZ2V0Mi5uZXh0U2libGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldDIuYXBwZW5kQ2hpbGQoY2xvbmUzKTtcbiAgICB9XG4gIH07XG4gIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgcGxhY2VJbkRvbShjbG9uZTIsIHRhcmdldCwgbW9kaWZpZXJzKTtcbiAgICBza2lwRHVyaW5nQ2xvbmUoKCkgPT4ge1xuICAgICAgaW5pdFRyZWUoY2xvbmUyKTtcbiAgICAgIGNsb25lMi5feF9pZ25vcmUgPSB0cnVlO1xuICAgIH0pKCk7XG4gIH0pO1xuICBlbC5feF90ZWxlcG9ydFB1dEJhY2sgPSAoKSA9PiB7XG4gICAgbGV0IHRhcmdldDIgPSBnZXRUYXJnZXQoZXhwcmVzc2lvbik7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIHBsYWNlSW5Eb20oZWwuX3hfdGVsZXBvcnQsIHRhcmdldDIsIG1vZGlmaWVycyk7XG4gICAgfSk7XG4gIH07XG4gIGNsZWFudXAyKFxuICAgICgpID0+IG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBjbG9uZTIucmVtb3ZlKCk7XG4gICAgICBkZXN0cm95VHJlZShjbG9uZTIpO1xuICAgIH0pXG4gICk7XG59KTtcbnZhciB0ZWxlcG9ydENvbnRhaW5lckR1cmluZ0Nsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbmZ1bmN0aW9uIGdldFRhcmdldChleHByZXNzaW9uKSB7XG4gIGxldCB0YXJnZXQgPSBza2lwRHVyaW5nQ2xvbmUoKCkgPT4ge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGV4cHJlc3Npb24pO1xuICB9LCAoKSA9PiB7XG4gICAgcmV0dXJuIHRlbGVwb3J0Q29udGFpbmVyRHVyaW5nQ2xvbmU7XG4gIH0pKCk7XG4gIGlmICghdGFyZ2V0KVxuICAgIHdhcm4oYENhbm5vdCBmaW5kIHgtdGVsZXBvcnQgZWxlbWVudCBmb3Igc2VsZWN0b3I6IFwiJHtleHByZXNzaW9ufVwiYCk7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaWdub3JlLmpzXG52YXIgaGFuZGxlciA9ICgpID0+IHtcbn07XG5oYW5kbGVyLmlubGluZSA9IChlbCwgeyBtb2RpZmllcnMgfSwgeyBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XG4gIG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikgPyBlbC5feF9pZ25vcmVTZWxmID0gdHJ1ZSA6IGVsLl94X2lnbm9yZSA9IHRydWU7XG4gIGNsZWFudXAyKCgpID0+IHtcbiAgICBtb2RpZmllcnMuaW5jbHVkZXMoXCJzZWxmXCIpID8gZGVsZXRlIGVsLl94X2lnbm9yZVNlbGYgOiBkZWxldGUgZWwuX3hfaWdub3JlO1xuICB9KTtcbn07XG5kaXJlY3RpdmUoXCJpZ25vcmVcIiwgaGFuZGxlcik7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtZWZmZWN0LmpzXG5kaXJlY3RpdmUoXCJlZmZlY3RcIiwgc2tpcER1cmluZ0Nsb25lKChlbCwgeyBleHByZXNzaW9uIH0sIHsgZWZmZWN0OiBlZmZlY3QzIH0pID0+IHtcbiAgZWZmZWN0MyhldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy91dGlscy9vbi5qc1xuZnVuY3Rpb24gb24oZWwsIGV2ZW50LCBtb2RpZmllcnMsIGNhbGxiYWNrKSB7XG4gIGxldCBsaXN0ZW5lclRhcmdldCA9IGVsO1xuICBsZXQgaGFuZGxlcjQgPSAoZSkgPT4gY2FsbGJhY2soZSk7XG4gIGxldCBvcHRpb25zID0ge307XG4gIGxldCB3cmFwSGFuZGxlciA9IChjYWxsYmFjazIsIHdyYXBwZXIpID0+IChlKSA9PiB3cmFwcGVyKGNhbGxiYWNrMiwgZSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkb3RcIikpXG4gICAgZXZlbnQgPSBkb3RTeW50YXgoZXZlbnQpO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiY2FtZWxcIikpXG4gICAgZXZlbnQgPSBjYW1lbENhc2UyKGV2ZW50KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInBhc3NpdmVcIikpXG4gICAgb3B0aW9ucy5wYXNzaXZlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImNhcHR1cmVcIikpXG4gICAgb3B0aW9ucy5jYXB0dXJlID0gdHJ1ZTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIndpbmRvd1wiKSlcbiAgICBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImRvY3VtZW50XCIpKVxuICAgIGxpc3RlbmVyVGFyZ2V0ID0gZG9jdW1lbnQ7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xuICAgIGxldCBuZXh0TW9kaWZpZXIgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2YoXCJkZWJvdW5jZVwiKSArIDFdIHx8IFwiaW52YWxpZC13YWl0XCI7XG4gICAgbGV0IHdhaXQgPSBpc051bWVyaWMobmV4dE1vZGlmaWVyLnNwbGl0KFwibXNcIilbMF0pID8gTnVtYmVyKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA6IDI1MDtcbiAgICBoYW5kbGVyNCA9IGRlYm91bmNlKGhhbmRsZXI0LCB3YWl0KTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidGhyb3R0bGVcIikpIHtcbiAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKFwidGhyb3R0bGVcIikgKyAxXSB8fCBcImludmFsaWQtd2FpdFwiO1xuICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdChcIm1zXCIpWzBdKSA/IE51bWJlcihuZXh0TW9kaWZpZXIuc3BsaXQoXCJtc1wiKVswXSkgOiAyNTA7XG4gICAgaGFuZGxlcjQgPSB0aHJvdHRsZShoYW5kbGVyNCwgd2FpdCk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInByZXZlbnRcIikpXG4gICAgaGFuZGxlcjQgPSB3cmFwSGFuZGxlcihoYW5kbGVyNCwgKG5leHQsIGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJzdG9wXCIpKVxuICAgIGhhbmRsZXI0ID0gd3JhcEhhbmRsZXIoaGFuZGxlcjQsIChuZXh0LCBlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgbmV4dChlKTtcbiAgICB9KTtcbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcIm9uY2VcIikpIHtcbiAgICBoYW5kbGVyNCA9IHdyYXBIYW5kbGVyKGhhbmRsZXI0LCAobmV4dCwgZSkgPT4ge1xuICAgICAgbmV4dChlKTtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXI0LCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiYXdheVwiKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJvdXRzaWRlXCIpKSB7XG4gICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcbiAgICBoYW5kbGVyNCA9IHdyYXBIYW5kbGVyKGhhbmRsZXI0LCAobmV4dCwgZSkgPT4ge1xuICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGUudGFyZ2V0LmlzQ29ubmVjdGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgMSAmJiBlbC5vZmZzZXRIZWlnaHQgPCAxKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZWwuX3hfaXNTaG93biA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInNlbGZcIikpXG4gICAgaGFuZGxlcjQgPSB3cmFwSGFuZGxlcihoYW5kbGVyNCwgKG5leHQsIGUpID0+IHtcbiAgICAgIGUudGFyZ2V0ID09PSBlbCAmJiBuZXh0KGUpO1xuICAgIH0pO1xuICBpZiAoaXNLZXlFdmVudChldmVudCkgfHwgaXNDbGlja0V2ZW50KGV2ZW50KSkge1xuICAgIGhhbmRsZXI0ID0gd3JhcEhhbmRsZXIoaGFuZGxlcjQsIChuZXh0LCBlKSA9PiB7XG4gICAgICBpZiAoaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5leHQoZSk7XG4gICAgfSk7XG4gIH1cbiAgbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcjQsIG9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXI0LCBvcHRpb25zKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvdFN5bnRheChzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnJlcGxhY2UoLy0vZywgXCIuXCIpO1xufVxuZnVuY3Rpb24gY2FtZWxDYXNlMihzdWJqZWN0KSB7XG4gIHJldHVybiBzdWJqZWN0LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShcXHcpL2csIChtYXRjaCwgY2hhcikgPT4gY2hhci50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpYyhzdWJqZWN0KSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheShzdWJqZWN0KSAmJiAhaXNOYU4oc3ViamVjdCk7XG59XG5mdW5jdGlvbiBrZWJhYkNhc2UyKHN1YmplY3QpIHtcbiAgaWYgKFtcIiBcIiwgXCJfXCJdLmluY2x1ZGVzKFxuICAgIHN1YmplY3RcbiAgKSlcbiAgICByZXR1cm4gc3ViamVjdDtcbiAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgXCIkMS0kMlwiKS5yZXBsYWNlKC9bX1xcc10vLCBcIi1cIikudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGlzS2V5RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIFtcImtleWRvd25cIiwgXCJrZXl1cFwiXS5pbmNsdWRlcyhldmVudCk7XG59XG5mdW5jdGlvbiBpc0NsaWNrRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIFtcImNvbnRleHRtZW51XCIsIFwiY2xpY2tcIiwgXCJtb3VzZVwiXS5zb21lKChpKSA9PiBldmVudC5pbmNsdWRlcyhpKSk7XG59XG5mdW5jdGlvbiBpc0xpc3RlbmluZ0ZvckFTcGVjaWZpY0tleVRoYXRIYXNudEJlZW5QcmVzc2VkKGUsIG1vZGlmaWVycykge1xuICBsZXQga2V5TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcigoaSkgPT4ge1xuICAgIHJldHVybiAhW1wid2luZG93XCIsIFwiZG9jdW1lbnRcIiwgXCJwcmV2ZW50XCIsIFwic3RvcFwiLCBcIm9uY2VcIiwgXCJjYXB0dXJlXCIsIFwic2VsZlwiLCBcImF3YXlcIiwgXCJvdXRzaWRlXCIsIFwicGFzc2l2ZVwiXS5pbmNsdWRlcyhpKTtcbiAgfSk7XG4gIGlmIChrZXlNb2RpZmllcnMuaW5jbHVkZXMoXCJkZWJvdW5jZVwiKSkge1xuICAgIGxldCBkZWJvdW5jZUluZGV4ID0ga2V5TW9kaWZpZXJzLmluZGV4T2YoXCJkZWJvdW5jZVwiKTtcbiAgICBrZXlNb2RpZmllcnMuc3BsaWNlKGRlYm91bmNlSW5kZXgsIGlzTnVtZXJpYygoa2V5TW9kaWZpZXJzW2RlYm91bmNlSW5kZXggKyAxXSB8fCBcImludmFsaWQtd2FpdFwiKS5zcGxpdChcIm1zXCIpWzBdKSA/IDIgOiAxKTtcbiAgfVxuICBpZiAoa2V5TW9kaWZpZXJzLmluY2x1ZGVzKFwidGhyb3R0bGVcIikpIHtcbiAgICBsZXQgZGVib3VuY2VJbmRleCA9IGtleU1vZGlmaWVycy5pbmRleE9mKFwidGhyb3R0bGVcIik7XG4gICAga2V5TW9kaWZpZXJzLnNwbGljZShkZWJvdW5jZUluZGV4LCBpc051bWVyaWMoKGtleU1vZGlmaWVyc1tkZWJvdW5jZUluZGV4ICsgMV0gfHwgXCJpbnZhbGlkLXdhaXRcIikuc3BsaXQoXCJtc1wiKVswXSkgPyAyIDogMSk7XG4gIH1cbiAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBrZXlUb01vZGlmaWVycyhlLmtleSkuaW5jbHVkZXMoa2V5TW9kaWZpZXJzWzBdKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHN5c3RlbUtleU1vZGlmaWVycyA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIiwgXCJjbWRcIiwgXCJzdXBlclwiXTtcbiAgY29uc3Qgc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMgPSBzeXN0ZW1LZXlNb2RpZmllcnMuZmlsdGVyKChtb2RpZmllcikgPT4ga2V5TW9kaWZpZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSk7XG4gIGtleU1vZGlmaWVycyA9IGtleU1vZGlmaWVycy5maWx0ZXIoKGkpID0+ICFzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5pbmNsdWRlcyhpKSk7XG4gIGlmIChzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgYWN0aXZlbHlQcmVzc2VkS2V5TW9kaWZpZXJzID0gc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuZmlsdGVyKChtb2RpZmllcikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBcImNtZFwiIHx8IG1vZGlmaWVyID09PSBcInN1cGVyXCIpXG4gICAgICAgIG1vZGlmaWVyID0gXCJtZXRhXCI7XG4gICAgICByZXR1cm4gZVtgJHttb2RpZmllcn1LZXlgXTtcbiAgICB9KTtcbiAgICBpZiAoYWN0aXZlbHlQcmVzc2VkS2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNDbGlja0V2ZW50KGUudHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChrZXlUb01vZGlmaWVycyhlLmtleSkuaW5jbHVkZXMoa2V5TW9kaWZpZXJzWzBdKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGtleVRvTW9kaWZpZXJzKGtleSkge1xuICBpZiAoIWtleSlcbiAgICByZXR1cm4gW107XG4gIGtleSA9IGtlYmFiQ2FzZTIoa2V5KTtcbiAgbGV0IG1vZGlmaWVyVG9LZXlNYXAgPSB7XG4gICAgXCJjdHJsXCI6IFwiY29udHJvbFwiLFxuICAgIFwic2xhc2hcIjogXCIvXCIsXG4gICAgXCJzcGFjZVwiOiBcIiBcIixcbiAgICBcInNwYWNlYmFyXCI6IFwiIFwiLFxuICAgIFwiY21kXCI6IFwibWV0YVwiLFxuICAgIFwiZXNjXCI6IFwiZXNjYXBlXCIsXG4gICAgXCJ1cFwiOiBcImFycm93LXVwXCIsXG4gICAgXCJkb3duXCI6IFwiYXJyb3ctZG93blwiLFxuICAgIFwibGVmdFwiOiBcImFycm93LWxlZnRcIixcbiAgICBcInJpZ2h0XCI6IFwiYXJyb3ctcmlnaHRcIixcbiAgICBcInBlcmlvZFwiOiBcIi5cIixcbiAgICBcImNvbW1hXCI6IFwiLFwiLFxuICAgIFwiZXF1YWxcIjogXCI9XCIsXG4gICAgXCJtaW51c1wiOiBcIi1cIixcbiAgICBcInVuZGVyc2NvcmVcIjogXCJfXCJcbiAgfTtcbiAgbW9kaWZpZXJUb0tleU1hcFtrZXldID0ga2V5O1xuICByZXR1cm4gT2JqZWN0LmtleXMobW9kaWZpZXJUb0tleU1hcCkubWFwKChtb2RpZmllcikgPT4ge1xuICAgIGlmIChtb2RpZmllclRvS2V5TWFwW21vZGlmaWVyXSA9PT0ga2V5KVxuICAgICAgcmV0dXJuIG1vZGlmaWVyO1xuICB9KS5maWx0ZXIoKG1vZGlmaWVyKSA9PiBtb2RpZmllcik7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtbW9kZWwuanNcbmRpcmVjdGl2ZShcIm1vZGVsXCIsIChlbCwgeyBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcbiAgbGV0IHNjb3BlVGFyZ2V0ID0gZWw7XG4gIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJwYXJlbnRcIikpIHtcbiAgICBzY29wZVRhcmdldCA9IGVsLnBhcmVudE5vZGU7XG4gIH1cbiAgbGV0IGV2YWx1YXRlR2V0ID0gZXZhbHVhdGVMYXRlcihzY29wZVRhcmdldCwgZXhwcmVzc2lvbik7XG4gIGxldCBldmFsdWF0ZVNldDtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgZXZhbHVhdGVTZXQgPSBldmFsdWF0ZUxhdGVyKHNjb3BlVGFyZ2V0LCBgJHtleHByZXNzaW9ufSA9IF9fcGxhY2Vob2xkZXJgKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBleHByZXNzaW9uKCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICBldmFsdWF0ZVNldCA9IGV2YWx1YXRlTGF0ZXIoc2NvcGVUYXJnZXQsIGAke2V4cHJlc3Npb24oKX0gPSBfX3BsYWNlaG9sZGVyYCk7XG4gIH0gZWxzZSB7XG4gICAgZXZhbHVhdGVTZXQgPSAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBsZXQgZ2V0VmFsdWUgPSAoKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBldmFsdWF0ZUdldCgodmFsdWUpID0+IHJlc3VsdCA9IHZhbHVlKTtcbiAgICByZXR1cm4gaXNHZXR0ZXJTZXR0ZXIocmVzdWx0KSA/IHJlc3VsdC5nZXQoKSA6IHJlc3VsdDtcbiAgfTtcbiAgbGV0IHNldFZhbHVlID0gKHZhbHVlKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBldmFsdWF0ZUdldCgodmFsdWUyKSA9PiByZXN1bHQgPSB2YWx1ZTIpO1xuICAgIGlmIChpc0dldHRlclNldHRlcihyZXN1bHQpKSB7XG4gICAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZhbHVhdGVTZXQoKCkgPT4ge1xuICAgICAgfSwge1xuICAgICAgICBzY29wZTogeyBcIl9fcGxhY2Vob2xkZXJcIjogdmFsdWUgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIgJiYgZWwudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKFwibmFtZVwiKSlcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBleHByZXNzaW9uKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgZXZlbnQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgfHwgW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXS5pbmNsdWRlcyhlbC50eXBlKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoXCJsYXp5XCIpID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIjtcbiAgbGV0IHJlbW92ZUxpc3RlbmVyID0gaXNDbG9uaW5nID8gKCkgPT4ge1xuICB9IDogb24oZWwsIGV2ZW50LCBtb2RpZmllcnMsIChlKSA9PiB7XG4gICAgc2V0VmFsdWUoZ2V0SW5wdXRWYWx1ZShlbCwgbW9kaWZpZXJzLCBlLCBnZXRWYWx1ZSgpKSk7XG4gIH0pO1xuICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwiZmlsbFwiKSkge1xuICAgIGlmIChbdm9pZCAwLCBudWxsLCBcIlwiXS5pbmNsdWRlcyhnZXRWYWx1ZSgpKSB8fCBpc0NoZWNrYm94KGVsKSAmJiBBcnJheS5pc0FycmF5KGdldFZhbHVlKCkpIHx8IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzZWxlY3RcIiAmJiBlbC5tdWx0aXBsZSkge1xuICAgICAgc2V0VmFsdWUoXG4gICAgICAgIGdldElucHV0VmFsdWUoZWwsIG1vZGlmaWVycywgeyB0YXJnZXQ6IGVsIH0sIGdldFZhbHVlKCkpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoIWVsLl94X3JlbW92ZU1vZGVsTGlzdGVuZXJzKVxuICAgIGVsLl94X3JlbW92ZU1vZGVsTGlzdGVuZXJzID0ge307XG4gIGVsLl94X3JlbW92ZU1vZGVsTGlzdGVuZXJzW1wiZGVmYXVsdFwiXSA9IHJlbW92ZUxpc3RlbmVyO1xuICBjbGVhbnVwMigoKSA9PiBlbC5feF9yZW1vdmVNb2RlbExpc3RlbmVyc1tcImRlZmF1bHRcIl0oKSk7XG4gIGlmIChlbC5mb3JtKSB7XG4gICAgbGV0IHJlbW92ZVJlc2V0TGlzdGVuZXIgPSBvbihlbC5mb3JtLCBcInJlc2V0XCIsIFtdLCAoZSkgPT4ge1xuICAgICAgbmV4dFRpY2soKCkgPT4gZWwuX3hfbW9kZWwgJiYgZWwuX3hfbW9kZWwuc2V0KGdldElucHV0VmFsdWUoZWwsIG1vZGlmaWVycywgeyB0YXJnZXQ6IGVsIH0sIGdldFZhbHVlKCkpKSk7XG4gICAgfSk7XG4gICAgY2xlYW51cDIoKCkgPT4gcmVtb3ZlUmVzZXRMaXN0ZW5lcigpKTtcbiAgfVxuICBlbC5feF9tb2RlbCA9IHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2V0VmFsdWUoKTtcbiAgICB9LFxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZWwuX3hfZm9yY2VNb2RlbFVwZGF0ZSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwICYmIHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiICYmIGV4cHJlc3Npb24ubWF0Y2goL1xcLi8pKVxuICAgICAgdmFsdWUgPSBcIlwiO1xuICAgIHdpbmRvdy5mcm9tTW9kZWwgPSB0cnVlO1xuICAgIG11dGF0ZURvbSgoKSA9PiBiaW5kKGVsLCBcInZhbHVlXCIsIHZhbHVlKSk7XG4gICAgZGVsZXRlIHdpbmRvdy5mcm9tTW9kZWw7XG4gIH07XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKCk7XG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcInVuaW50cnVzaXZlXCIpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShlbCkpXG4gICAgICByZXR1cm47XG4gICAgZWwuX3hfZm9yY2VNb2RlbFVwZGF0ZSh2YWx1ZSk7XG4gIH0pO1xufSk7XG5mdW5jdGlvbiBnZXRJbnB1dFZhbHVlKGVsLCBtb2RpZmllcnMsIGV2ZW50LCBjdXJyZW50VmFsdWUpIHtcbiAgcmV0dXJuIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQgJiYgZXZlbnQuZGV0YWlsICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gZXZlbnQuZGV0YWlsICE9PSBudWxsICYmIGV2ZW50LmRldGFpbCAhPT0gdm9pZCAwID8gZXZlbnQuZGV0YWlsIDogZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgIGVsc2UgaWYgKGlzQ2hlY2tib3goZWwpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNhZmVQYXJzZU51bWJlcihldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vZGlmaWVycy5pbmNsdWRlcyhcImJvb2xlYW5cIikpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNhZmVQYXJzZUJvb2xlYW4oZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBjdXJyZW50VmFsdWUuaW5jbHVkZXMobmV3VmFsdWUpID8gY3VycmVudFZhbHVlIDogY3VycmVudFZhbHVlLmNvbmNhdChbbmV3VmFsdWVdKSA6IGN1cnJlbnRWYWx1ZS5maWx0ZXIoKGVsMikgPT4gIWNoZWNrZWRBdHRyTG9vc2VDb21wYXJlMihlbDIsIG5ld1ZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgJiYgZWwubXVsdGlwbGUpIHtcbiAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJudW1iZXJcIikpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgICBsZXQgcmF3VmFsdWUgPSBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gICAgICAgICAgcmV0dXJuIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJib29sZWFuXCIpKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcCgob3B0aW9uKSA9PiB7XG4gICAgICAgICAgbGV0IHJhd1ZhbHVlID0gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgICAgIHJldHVybiBzYWZlUGFyc2VCb29sZWFuKHJhd1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuZXdWYWx1ZTtcbiAgICAgIGlmIChpc1JhZGlvKGVsKSkge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwibnVtYmVyXCIpKSB7XG4gICAgICAgIHJldHVybiBzYWZlUGFyc2VOdW1iZXIobmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJib29sZWFuXCIpKSB7XG4gICAgICAgIHJldHVybiBzYWZlUGFyc2VCb29sZWFuKG5ld1ZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKFwidHJpbVwiKSkge1xuICAgICAgICByZXR1cm4gbmV3VmFsdWUudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIHtcbiAgbGV0IG51bWJlciA9IHJhd1ZhbHVlID8gcGFyc2VGbG9hdChyYXdWYWx1ZSkgOiBudWxsO1xuICByZXR1cm4gaXNOdW1lcmljMihudW1iZXIpID8gbnVtYmVyIDogcmF3VmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZTIodmFsdWVBLCB2YWx1ZUIpIHtcbiAgcmV0dXJuIHZhbHVlQSA9PSB2YWx1ZUI7XG59XG5mdW5jdGlvbiBpc051bWVyaWMyKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cbmZ1bmN0aW9uIGlzR2V0dGVyU2V0dGVyKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB2YWx1ZS5zZXQgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1jbG9hay5qc1xuZGlyZWN0aXZlKFwiY2xvYWtcIiwgKGVsKSA9PiBxdWV1ZU1pY3JvdGFzaygoKSA9PiBtdXRhdGVEb20oKCkgPT4gZWwucmVtb3ZlQXR0cmlidXRlKHByZWZpeChcImNsb2FrXCIpKSkpKTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1pbml0LmpzXG5hZGRJbml0U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImluaXRcIil9XWApO1xuZGlyZWN0aXZlKFwiaW5pdFwiLCBza2lwRHVyaW5nQ2xvbmUoKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBldmFsdWF0ZTogZXZhbHVhdGUyIH0pID0+IHtcbiAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICEhZXhwcmVzc2lvbi50cmltKCkgJiYgZXZhbHVhdGUyKGV4cHJlc3Npb24sIHt9LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIGV2YWx1YXRlMihleHByZXNzaW9uLCB7fSwgZmFsc2UpO1xufSkpO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LXRleHQuanNcbmRpcmVjdGl2ZShcInRleHRcIiwgKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMsIGV2YWx1YXRlTGF0ZXI6IGV2YWx1YXRlTGF0ZXIyIH0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV2YWx1YXRlTGF0ZXIyKGV4cHJlc3Npb24pO1xuICBlZmZlY3QzKCgpID0+IHtcbiAgICBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaHRtbC5qc1xuZGlyZWN0aXZlKFwiaHRtbFwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MywgZXZhbHVhdGVMYXRlcjogZXZhbHVhdGVMYXRlcjIgfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcjIoZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4ge1xuICAgIGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICBlbC5feF9pZ25vcmVTZWxmID0gdHJ1ZTtcbiAgICAgICAgaW5pdFRyZWUoZWwpO1xuICAgICAgICBkZWxldGUgZWwuX3hfaWdub3JlU2VsZjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vLyBwYWNrYWdlcy9hbHBpbmVqcy9zcmMvZGlyZWN0aXZlcy94LWJpbmQuanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiOlwiLCBpbnRvKHByZWZpeChcImJpbmQ6XCIpKSkpO1xudmFyIGhhbmRsZXIyID0gKGVsLCB7IHZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIG9yaWdpbmFsIH0sIHsgZWZmZWN0OiBlZmZlY3QzLCBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBsZXQgYmluZGluZ1Byb3ZpZGVycyA9IHt9O1xuICAgIGluamVjdEJpbmRpbmdQcm92aWRlcnMoYmluZGluZ1Byb3ZpZGVycyk7XG4gICAgbGV0IGdldEJpbmRpbmdzID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gICAgZ2V0QmluZGluZ3MoKGJpbmRpbmdzKSA9PiB7XG4gICAgICBhcHBseUJpbmRpbmdzT2JqZWN0KGVsLCBiaW5kaW5ncywgb3JpZ2luYWwpO1xuICAgIH0sIHsgc2NvcGU6IGJpbmRpbmdQcm92aWRlcnMgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gXCJrZXlcIilcbiAgICByZXR1cm4gc3RvcmVLZXlGb3JYRm9yKGVsLCBleHByZXNzaW9uKTtcbiAgaWYgKGVsLl94X2lubGluZUJpbmRpbmdzICYmIGVsLl94X2lubGluZUJpbmRpbmdzW3ZhbHVlXSAmJiBlbC5feF9pbmxpbmVCaW5kaW5nc1t2YWx1ZV0uZXh0cmFjdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGVmZmVjdDMoKCkgPT4gZXZhbHVhdGUyKChyZXN1bHQpID0+IHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDAgJiYgdHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIgJiYgZXhwcmVzc2lvbi5tYXRjaCgvXFwuLykpIHtcbiAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgfVxuICAgIG11dGF0ZURvbSgoKSA9PiBiaW5kKGVsLCB2YWx1ZSwgcmVzdWx0LCBtb2RpZmllcnMpKTtcbiAgfSkpO1xuICBjbGVhbnVwMigoKSA9PiB7XG4gICAgZWwuX3hfdW5kb0FkZGVkQ2xhc3NlcyAmJiBlbC5feF91bmRvQWRkZWRDbGFzc2VzKCk7XG4gICAgZWwuX3hfdW5kb0FkZGVkU3R5bGVzICYmIGVsLl94X3VuZG9BZGRlZFN0eWxlcygpO1xuICB9KTtcbn07XG5oYW5kbGVyMi5pbmxpbmUgPSAoZWwsIHsgdmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiB9KSA9PiB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuO1xuICBpZiAoIWVsLl94X2lubGluZUJpbmRpbmdzKVxuICAgIGVsLl94X2lubGluZUJpbmRpbmdzID0ge307XG4gIGVsLl94X2lubGluZUJpbmRpbmdzW3ZhbHVlXSA9IHsgZXhwcmVzc2lvbiwgZXh0cmFjdDogZmFsc2UgfTtcbn07XG5kaXJlY3RpdmUoXCJiaW5kXCIsIGhhbmRsZXIyKTtcbmZ1bmN0aW9uIHN0b3JlS2V5Rm9yWEZvcihlbCwgZXhwcmVzc2lvbikge1xuICBlbC5feF9rZXlFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1kYXRhLmpzXG5hZGRSb290U2VsZWN0b3IoKCkgPT4gYFske3ByZWZpeChcImRhdGFcIil9XWApO1xuZGlyZWN0aXZlKFwiZGF0YVwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcbiAgaWYgKHNob3VsZFNraXBSZWdpc3RlcmluZ0RhdGFEdXJpbmdDbG9uZShlbCkpXG4gICAgcmV0dXJuO1xuICBleHByZXNzaW9uID0gZXhwcmVzc2lvbiA9PT0gXCJcIiA/IFwie31cIiA6IGV4cHJlc3Npb247XG4gIGxldCBtYWdpY0NvbnRleHQgPSB7fTtcbiAgaW5qZWN0TWFnaWNzKG1hZ2ljQ29udGV4dCwgZWwpO1xuICBsZXQgZGF0YVByb3ZpZGVyQ29udGV4dCA9IHt9O1xuICBpbmplY3REYXRhUHJvdmlkZXJzKGRhdGFQcm92aWRlckNvbnRleHQsIG1hZ2ljQ29udGV4dCk7XG4gIGxldCBkYXRhMiA9IGV2YWx1YXRlKGVsLCBleHByZXNzaW9uLCB7IHNjb3BlOiBkYXRhUHJvdmlkZXJDb250ZXh0IH0pO1xuICBpZiAoZGF0YTIgPT09IHZvaWQgMCB8fCBkYXRhMiA9PT0gdHJ1ZSlcbiAgICBkYXRhMiA9IHt9O1xuICBpbmplY3RNYWdpY3MoZGF0YTIsIGVsKTtcbiAgbGV0IHJlYWN0aXZlRGF0YSA9IHJlYWN0aXZlKGRhdGEyKTtcbiAgaW5pdEludGVyY2VwdG9ycyhyZWFjdGl2ZURhdGEpO1xuICBsZXQgdW5kbyA9IGFkZFNjb3BlVG9Ob2RlKGVsLCByZWFjdGl2ZURhdGEpO1xuICByZWFjdGl2ZURhdGFbXCJpbml0XCJdICYmIGV2YWx1YXRlKGVsLCByZWFjdGl2ZURhdGFbXCJpbml0XCJdKTtcbiAgY2xlYW51cDIoKCkgPT4ge1xuICAgIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0gJiYgZXZhbHVhdGUoZWwsIHJlYWN0aXZlRGF0YVtcImRlc3Ryb3lcIl0pO1xuICAgIHVuZG8oKTtcbiAgfSk7XG59KTtcbmludGVyY2VwdENsb25lKChmcm9tLCB0bykgPT4ge1xuICBpZiAoZnJvbS5feF9kYXRhU3RhY2spIHtcbiAgICB0by5feF9kYXRhU3RhY2sgPSBmcm9tLl94X2RhdGFTdGFjaztcbiAgICB0by5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhhcy1hbHBpbmUtc3RhdGVcIiwgdHJ1ZSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gc2hvdWxkU2tpcFJlZ2lzdGVyaW5nRGF0YUR1cmluZ0Nsb25lKGVsKSB7XG4gIGlmICghaXNDbG9uaW5nKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGlzQ2xvbmluZ0xlZ2FjeSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZShcImRhdGEtaGFzLWFscGluZS1zdGF0ZVwiKTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1zaG93LmpzXG5kaXJlY3RpdmUoXCJzaG93XCIsIChlbCwgeyBtb2RpZmllcnMsIGV4cHJlc3Npb24gfSwgeyBlZmZlY3Q6IGVmZmVjdDMgfSkgPT4ge1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGlmICghZWwuX3hfZG9IaWRlKVxuICAgIGVsLl94X2RvSGlkZSA9ICgpID0+IHtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcIm5vbmVcIiwgbW9kaWZpZXJzLmluY2x1ZGVzKFwiaW1wb3J0YW50XCIpID8gXCJpbXBvcnRhbnRcIiA6IHZvaWQgMCk7XG4gICAgICB9KTtcbiAgICB9O1xuICBpZiAoIWVsLl94X2RvU2hvdylcbiAgICBlbC5feF9kb1Nob3cgPSAoKSA9PiB7XG4gICAgICBtdXRhdGVEb20oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuc3R5bGUubGVuZ3RoID09PSAxICYmIGVsLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJkaXNwbGF5XCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICBsZXQgaGlkZSA9ICgpID0+IHtcbiAgICBlbC5feF9kb0hpZGUoKTtcbiAgICBlbC5feF9pc1Nob3duID0gZmFsc2U7XG4gIH07XG4gIGxldCBzaG93ID0gKCkgPT4ge1xuICAgIGVsLl94X2RvU2hvdygpO1xuICAgIGVsLl94X2lzU2hvd24gPSB0cnVlO1xuICB9O1xuICBsZXQgY2xpY2tBd2F5Q29tcGF0aWJsZVNob3cgPSAoKSA9PiBzZXRUaW1lb3V0KHNob3cpO1xuICBsZXQgdG9nZ2xlID0gb25jZShcbiAgICAodmFsdWUpID0+IHZhbHVlID8gc2hvdygpIDogaGlkZSgpLFxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBlbC5feF90b2dnbGVBbmRDYXNjYWRlV2l0aFRyYW5zaXRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZWwuX3hfdG9nZ2xlQW5kQ2FzY2FkZVdpdGhUcmFuc2l0aW9ucyhlbCwgdmFsdWUsIHNob3csIGhpZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPyBjbGlja0F3YXlDb21wYXRpYmxlU2hvdygpIDogaGlkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgbGV0IG9sZFZhbHVlO1xuICBsZXQgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgZWZmZWN0MygoKSA9PiBldmFsdWF0ZTIoKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFmaXJzdFRpbWUgJiYgdmFsdWUgPT09IG9sZFZhbHVlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoXCJpbW1lZGlhdGVcIikpXG4gICAgICB2YWx1ZSA/IGNsaWNrQXdheUNvbXBhdGlibGVTaG93KCkgOiBoaWRlKCk7XG4gICAgdG9nZ2xlKHZhbHVlKTtcbiAgICBvbGRWYWx1ZSA9IHZhbHVlO1xuICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICB9KSk7XG59KTtcblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1mb3IuanNcbmRpcmVjdGl2ZShcImZvclwiLCAoZWwsIHsgZXhwcmVzc2lvbiB9LCB7IGVmZmVjdDogZWZmZWN0MywgY2xlYW51cDogY2xlYW51cDIgfSkgPT4ge1xuICBsZXQgaXRlcmF0b3JOYW1lcyA9IHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgbGV0IGV2YWx1YXRlSXRlbXMgPSBldmFsdWF0ZUxhdGVyKGVsLCBpdGVyYXRvck5hbWVzLml0ZW1zKTtcbiAgbGV0IGV2YWx1YXRlS2V5ID0gZXZhbHVhdGVMYXRlcihcbiAgICBlbCxcbiAgICAvLyB0aGUgeC1iaW5kOmtleSBleHByZXNzaW9uIGlzIHN0b3JlZCBmb3Igb3VyIHVzZSBpbnN0ZWFkIG9mIGV2YWx1YXRlZC5cbiAgICBlbC5feF9rZXlFeHByZXNzaW9uIHx8IFwiaW5kZXhcIlxuICApO1xuICBlbC5feF9wcmV2S2V5cyA9IFtdO1xuICBlbC5feF9sb29rdXAgPSB7fTtcbiAgZWZmZWN0MygoKSA9PiBsb29wKGVsLCBpdGVyYXRvck5hbWVzLCBldmFsdWF0ZUl0ZW1zLCBldmFsdWF0ZUtleSkpO1xuICBjbGVhbnVwMigoKSA9PiB7XG4gICAgT2JqZWN0LnZhbHVlcyhlbC5feF9sb29rdXApLmZvckVhY2goKGVsMikgPT4gbXV0YXRlRG9tKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBkZXN0cm95VHJlZShlbDIpO1xuICAgICAgICBlbDIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgKSk7XG4gICAgZGVsZXRlIGVsLl94X3ByZXZLZXlzO1xuICAgIGRlbGV0ZSBlbC5feF9sb29rdXA7XG4gIH0pO1xufSk7XG5mdW5jdGlvbiBsb29wKGVsLCBpdGVyYXRvck5hbWVzLCBldmFsdWF0ZUl0ZW1zLCBldmFsdWF0ZUtleSkge1xuICBsZXQgaXNPYmplY3QyID0gKGkpID0+IHR5cGVvZiBpID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGkpO1xuICBsZXQgdGVtcGxhdGVFbCA9IGVsO1xuICBldmFsdWF0ZUl0ZW1zKChpdGVtcykgPT4ge1xuICAgIGlmIChpc051bWVyaWMzKGl0ZW1zKSAmJiBpdGVtcyA+PSAwKSB7XG4gICAgICBpdGVtcyA9IEFycmF5LmZyb20oQXJyYXkoaXRlbXMpLmtleXMoKSwgKGkpID0+IGkgKyAxKTtcbiAgICB9XG4gICAgaWYgKGl0ZW1zID09PSB2b2lkIDApXG4gICAgICBpdGVtcyA9IFtdO1xuICAgIGxldCBsb29rdXAgPSBlbC5feF9sb29rdXA7XG4gICAgbGV0IHByZXZLZXlzID0gZWwuX3hfcHJldktleXM7XG4gICAgbGV0IHNjb3BlcyA9IFtdO1xuICAgIGxldCBrZXlzID0gW107XG4gICAgaWYgKGlzT2JqZWN0MihpdGVtcykpIHtcbiAgICAgIGl0ZW1zID0gT2JqZWN0LmVudHJpZXMoaXRlbXMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxldCBzY29wZTIgPSBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCB2YWx1ZSwga2V5LCBpdGVtcyk7XG4gICAgICAgIGV2YWx1YXRlS2V5KCh2YWx1ZTIpID0+IHtcbiAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyh2YWx1ZTIpKVxuICAgICAgICAgICAgd2FybihcIkR1cGxpY2F0ZSBrZXkgb24geC1mb3JcIiwgZWwpO1xuICAgICAgICAgIGtleXMucHVzaCh2YWx1ZTIpO1xuICAgICAgICB9LCB7IHNjb3BlOiB7IGluZGV4OiBrZXksIC4uLnNjb3BlMiB9IH0pO1xuICAgICAgICBzY29wZXMucHVzaChzY29wZTIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNjb3BlMiA9IGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW1zW2ldLCBpLCBpdGVtcyk7XG4gICAgICAgIGV2YWx1YXRlS2V5KCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGlmIChrZXlzLmluY2x1ZGVzKHZhbHVlKSlcbiAgICAgICAgICAgIHdhcm4oXCJEdXBsaWNhdGUga2V5IG9uIHgtZm9yXCIsIGVsKTtcbiAgICAgICAgICBrZXlzLnB1c2godmFsdWUpO1xuICAgICAgICB9LCB7IHNjb3BlOiB7IGluZGV4OiBpLCAuLi5zY29wZTIgfSB9KTtcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGFkZHMgPSBbXTtcbiAgICBsZXQgbW92ZXMgPSBbXTtcbiAgICBsZXQgcmVtb3ZlcyA9IFtdO1xuICAgIGxldCBzYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBwcmV2S2V5c1tpXTtcbiAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpXG4gICAgICAgIHJlbW92ZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBwcmV2S2V5cyA9IHByZXZLZXlzLmZpbHRlcigoa2V5KSA9PiAhcmVtb3Zlcy5pbmNsdWRlcyhrZXkpKTtcbiAgICBsZXQgbGFzdEtleSA9IFwidGVtcGxhdGVcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2ldO1xuICAgICAgbGV0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShpLCAwLCBrZXkpO1xuICAgICAgICBhZGRzLnB1c2goW2xhc3RLZXksIGldKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldkluZGV4ICE9PSBpKSB7XG4gICAgICAgIGxldCBrZXlJblNwb3QgPSBwcmV2S2V5cy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgIGxldCBrZXlGb3JTcG90ID0gcHJldktleXMuc3BsaWNlKHByZXZJbmRleCAtIDEsIDEpWzBdO1xuICAgICAgICBwcmV2S2V5cy5zcGxpY2UoaSwgMCwga2V5Rm9yU3BvdCk7XG4gICAgICAgIHByZXZLZXlzLnNwbGljZShwcmV2SW5kZXgsIDAsIGtleUluU3BvdCk7XG4gICAgICAgIG1vdmVzLnB1c2goW2tleUluU3BvdCwga2V5Rm9yU3BvdF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgbGFzdEtleSA9IGtleTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2V5ID0gcmVtb3Zlc1tpXTtcbiAgICAgIGlmICghKGtleSBpbiBsb29rdXApKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGRlc3Ryb3lUcmVlKGxvb2t1cFtrZXldKTtcbiAgICAgICAgbG9va3VwW2tleV0ucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBsb29rdXBba2V5XTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IFtrZXlJblNwb3QsIGtleUZvclNwb3RdID0gbW92ZXNbaV07XG4gICAgICBsZXQgZWxJblNwb3QgPSBsb29rdXBba2V5SW5TcG90XTtcbiAgICAgIGxldCBlbEZvclNwb3QgPSBsb29rdXBba2V5Rm9yU3BvdF07XG4gICAgICBsZXQgbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGlmICghZWxGb3JTcG90KVxuICAgICAgICAgIHdhcm4oYHgtZm9yIFwiOmtleVwiIGlzIHVuZGVmaW5lZCBvciBpbnZhbGlkYCwgdGVtcGxhdGVFbCwga2V5Rm9yU3BvdCwgbG9va3VwKTtcbiAgICAgICAgZWxGb3JTcG90LmFmdGVyKG1hcmtlcik7XG4gICAgICAgIGVsSW5TcG90LmFmdGVyKGVsRm9yU3BvdCk7XG4gICAgICAgIGVsRm9yU3BvdC5feF9jdXJyZW50SWZFbCAmJiBlbEZvclNwb3QuYWZ0ZXIoZWxGb3JTcG90Ll94X2N1cnJlbnRJZkVsKTtcbiAgICAgICAgbWFya2VyLmJlZm9yZShlbEluU3BvdCk7XG4gICAgICAgIGVsSW5TcG90Ll94X2N1cnJlbnRJZkVsICYmIGVsSW5TcG90LmFmdGVyKGVsSW5TcG90Ll94X2N1cnJlbnRJZkVsKTtcbiAgICAgICAgbWFya2VyLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBlbEZvclNwb3QuX3hfcmVmcmVzaFhGb3JTY29wZShzY29wZXNba2V5cy5pbmRleE9mKGtleUZvclNwb3QpXSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IFtsYXN0S2V5MiwgaW5kZXhdID0gYWRkc1tpXTtcbiAgICAgIGxldCBsYXN0RWwgPSBsYXN0S2V5MiA9PT0gXCJ0ZW1wbGF0ZVwiID8gdGVtcGxhdGVFbCA6IGxvb2t1cFtsYXN0S2V5Ml07XG4gICAgICBpZiAobGFzdEVsLl94X2N1cnJlbnRJZkVsKVxuICAgICAgICBsYXN0RWwgPSBsYXN0RWwuX3hfY3VycmVudElmRWw7XG4gICAgICBsZXQgc2NvcGUyID0gc2NvcGVzW2luZGV4XTtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIGxldCBjbG9uZTIgPSBkb2N1bWVudC5pbXBvcnROb2RlKHRlbXBsYXRlRWwuY29udGVudCwgdHJ1ZSkuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICBsZXQgcmVhY3RpdmVTY29wZSA9IHJlYWN0aXZlKHNjb3BlMik7XG4gICAgICBhZGRTY29wZVRvTm9kZShjbG9uZTIsIHJlYWN0aXZlU2NvcGUsIHRlbXBsYXRlRWwpO1xuICAgICAgY2xvbmUyLl94X3JlZnJlc2hYRm9yU2NvcGUgPSAobmV3U2NvcGUpID0+IHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobmV3U2NvcGUpLmZvckVhY2goKFtrZXkyLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICByZWFjdGl2ZVNjb3BlW2tleTJdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICAgIGxhc3RFbC5hZnRlcihjbG9uZTIpO1xuICAgICAgICBza2lwRHVyaW5nQ2xvbmUoKCkgPT4gaW5pdFRyZWUoY2xvbmUyKSkoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgd2FybihcIngtZm9yIGtleSBjYW5ub3QgYmUgYW4gb2JqZWN0LCBpdCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGludGVnZXJcIiwgdGVtcGxhdGVFbCk7XG4gICAgICB9XG4gICAgICBsb29rdXBba2V5XSA9IGNsb25lMjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9va3VwW3NhbWVzW2ldXS5feF9yZWZyZXNoWEZvclNjb3BlKHNjb3Blc1trZXlzLmluZGV4T2Yoc2FtZXNbaV0pXSk7XG4gICAgfVxuICAgIHRlbXBsYXRlRWwuX3hfcHJldktleXMgPSBrZXlzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIGxldCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuICBsZXQgc3RyaXBQYXJlbnNSRSA9IC9eXFxzKlxcKHxcXClcXHMqJC9nO1xuICBsZXQgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbiAgbGV0IGluTWF0Y2ggPSBleHByZXNzaW9uLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpXG4gICAgcmV0dXJuO1xuICBsZXQgcmVzID0ge307XG4gIHJlcy5pdGVtcyA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICBsZXQgaXRlbSA9IGluTWF0Y2hbMV0ucmVwbGFjZShzdHJpcFBhcmVuc1JFLCBcIlwiKS50cmltKCk7XG4gIGxldCBpdGVyYXRvck1hdGNoID0gaXRlbS5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuaXRlbSA9IGl0ZW0ucmVwbGFjZShmb3JJdGVyYXRvclJFLCBcIlwiKS50cmltKCk7XG4gICAgcmVzLmluZGV4ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5jb2xsZWN0aW9uID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5pdGVtID0gaXRlbTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbSwgaW5kZXgsIGl0ZW1zKSB7XG4gIGxldCBzY29wZVZhcmlhYmxlcyA9IHt9O1xuICBpZiAoL15cXFsuKlxcXSQvLnRlc3QoaXRlcmF0b3JOYW1lcy5pdGVtKSAmJiBBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgbGV0IG5hbWVzID0gaXRlcmF0b3JOYW1lcy5pdGVtLnJlcGxhY2UoXCJbXCIsIFwiXCIpLnJlcGxhY2UoXCJdXCIsIFwiXCIpLnNwbGl0KFwiLFwiKS5tYXAoKGkpID0+IGkudHJpbSgpKTtcbiAgICBuYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBzY29wZVZhcmlhYmxlc1tuYW1lXSA9IGl0ZW1baV07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoL15cXHsuKlxcfSQvLnRlc3QoaXRlcmF0b3JOYW1lcy5pdGVtKSAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIikge1xuICAgIGxldCBuYW1lcyA9IGl0ZXJhdG9yTmFtZXMuaXRlbS5yZXBsYWNlKFwie1wiLCBcIlwiKS5yZXBsYWNlKFwifVwiLCBcIlwiKS5zcGxpdChcIixcIikubWFwKChpKSA9PiBpLnRyaW0oKSk7XG4gICAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgc2NvcGVWYXJpYWJsZXNbbmFtZV0gPSBpdGVtW25hbWVdO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaXRlbV0gPSBpdGVtO1xuICB9XG4gIGlmIChpdGVyYXRvck5hbWVzLmluZGV4KVxuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaW5kZXhdID0gaW5kZXg7XG4gIGlmIChpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb24pXG4gICAgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uXSA9IGl0ZW1zO1xuICByZXR1cm4gc2NvcGVWYXJpYWJsZXM7XG59XG5mdW5jdGlvbiBpc051bWVyaWMzKHN1YmplY3QpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbn1cblxuLy8gcGFja2FnZXMvYWxwaW5lanMvc3JjL2RpcmVjdGl2ZXMveC1yZWYuanNcbmZ1bmN0aW9uIGhhbmRsZXIzKCkge1xufVxuaGFuZGxlcjMuaW5saW5lID0gKGVsLCB7IGV4cHJlc3Npb24gfSwgeyBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XG4gIGxldCByb290ID0gY2xvc2VzdFJvb3QoZWwpO1xuICBpZiAoIXJvb3QuX3hfcmVmcylcbiAgICByb290Ll94X3JlZnMgPSB7fTtcbiAgcm9vdC5feF9yZWZzW2V4cHJlc3Npb25dID0gZWw7XG4gIGNsZWFudXAyKCgpID0+IGRlbGV0ZSByb290Ll94X3JlZnNbZXhwcmVzc2lvbl0pO1xufTtcbmRpcmVjdGl2ZShcInJlZlwiLCBoYW5kbGVyMyk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaWYuanNcbmRpcmVjdGl2ZShcImlmXCIsIChlbCwgeyBleHByZXNzaW9uIH0sIHsgZWZmZWN0OiBlZmZlY3QzLCBjbGVhbnVwOiBjbGVhbnVwMiB9KSA9PiB7XG4gIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwidGVtcGxhdGVcIilcbiAgICB3YXJuKFwieC1pZiBjYW4gb25seSBiZSB1c2VkIG9uIGEgPHRlbXBsYXRlPiB0YWdcIiwgZWwpO1xuICBsZXQgZXZhbHVhdGUyID0gZXZhbHVhdGVMYXRlcihlbCwgZXhwcmVzc2lvbik7XG4gIGxldCBzaG93ID0gKCkgPT4ge1xuICAgIGlmIChlbC5feF9jdXJyZW50SWZFbClcbiAgICAgIHJldHVybiBlbC5feF9jdXJyZW50SWZFbDtcbiAgICBsZXQgY2xvbmUyID0gZWwuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgYWRkU2NvcGVUb05vZGUoY2xvbmUyLCB7fSwgZWwpO1xuICAgIG11dGF0ZURvbSgoKSA9PiB7XG4gICAgICBlbC5hZnRlcihjbG9uZTIpO1xuICAgICAgc2tpcER1cmluZ0Nsb25lKCgpID0+IGluaXRUcmVlKGNsb25lMikpKCk7XG4gICAgfSk7XG4gICAgZWwuX3hfY3VycmVudElmRWwgPSBjbG9uZTI7XG4gICAgZWwuX3hfdW5kb0lmID0gKCkgPT4ge1xuICAgICAgbXV0YXRlRG9tKCgpID0+IHtcbiAgICAgICAgZGVzdHJveVRyZWUoY2xvbmUyKTtcbiAgICAgICAgY2xvbmUyLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgZWwuX3hfY3VycmVudElmRWw7XG4gICAgfTtcbiAgICByZXR1cm4gY2xvbmUyO1xuICB9O1xuICBsZXQgaGlkZSA9ICgpID0+IHtcbiAgICBpZiAoIWVsLl94X3VuZG9JZilcbiAgICAgIHJldHVybjtcbiAgICBlbC5feF91bmRvSWYoKTtcbiAgICBkZWxldGUgZWwuX3hfdW5kb0lmO1xuICB9O1xuICBlZmZlY3QzKCgpID0+IGV2YWx1YXRlMigodmFsdWUpID0+IHtcbiAgICB2YWx1ZSA/IHNob3coKSA6IGhpZGUoKTtcbiAgfSkpO1xuICBjbGVhbnVwMigoKSA9PiBlbC5feF91bmRvSWYgJiYgZWwuX3hfdW5kb0lmKCkpO1xufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtaWQuanNcbmRpcmVjdGl2ZShcImlkXCIsIChlbCwgeyBleHByZXNzaW9uIH0sIHsgZXZhbHVhdGU6IGV2YWx1YXRlMiB9KSA9PiB7XG4gIGxldCBuYW1lcyA9IGV2YWx1YXRlMihleHByZXNzaW9uKTtcbiAgbmFtZXMuZm9yRWFjaCgobmFtZSkgPT4gc2V0SWRSb290KGVsLCBuYW1lKSk7XG59KTtcbmludGVyY2VwdENsb25lKChmcm9tLCB0bykgPT4ge1xuICBpZiAoZnJvbS5feF9pZHMpIHtcbiAgICB0by5feF9pZHMgPSBmcm9tLl94X2lkcztcbiAgfVxufSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL3gtb24uanNcbm1hcEF0dHJpYnV0ZXMoc3RhcnRpbmdXaXRoKFwiQFwiLCBpbnRvKHByZWZpeChcIm9uOlwiKSkpKTtcbmRpcmVjdGl2ZShcIm9uXCIsIHNraXBEdXJpbmdDbG9uZSgoZWwsIHsgdmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiB9LCB7IGNsZWFudXA6IGNsZWFudXAyIH0pID0+IHtcbiAgbGV0IGV2YWx1YXRlMiA9IGV4cHJlc3Npb24gPyBldmFsdWF0ZUxhdGVyKGVsLCBleHByZXNzaW9uKSA6ICgpID0+IHtcbiAgfTtcbiAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgaWYgKCFlbC5feF9mb3J3YXJkRXZlbnRzKVxuICAgICAgZWwuX3hfZm9yd2FyZEV2ZW50cyA9IFtdO1xuICAgIGlmICghZWwuX3hfZm9yd2FyZEV2ZW50cy5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICBlbC5feF9mb3J3YXJkRXZlbnRzLnB1c2godmFsdWUpO1xuICB9XG4gIGxldCByZW1vdmVMaXN0ZW5lciA9IG9uKGVsLCB2YWx1ZSwgbW9kaWZpZXJzLCAoZSkgPT4ge1xuICAgIGV2YWx1YXRlMigoKSA9PiB7XG4gICAgfSwgeyBzY29wZTogeyBcIiRldmVudFwiOiBlIH0sIHBhcmFtczogW2VdIH0pO1xuICB9KTtcbiAgY2xlYW51cDIoKCkgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG59KSk7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9kaXJlY3RpdmVzL2luZGV4LmpzXG53YXJuTWlzc2luZ1BsdWdpbkRpcmVjdGl2ZShcIkNvbGxhcHNlXCIsIFwiY29sbGFwc2VcIiwgXCJjb2xsYXBzZVwiKTtcbndhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKFwiSW50ZXJzZWN0XCIsIFwiaW50ZXJzZWN0XCIsIFwiaW50ZXJzZWN0XCIpO1xud2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUoXCJGb2N1c1wiLCBcInRyYXBcIiwgXCJmb2N1c1wiKTtcbndhcm5NaXNzaW5nUGx1Z2luRGlyZWN0aXZlKFwiTWFza1wiLCBcIm1hc2tcIiwgXCJtYXNrXCIpO1xuZnVuY3Rpb24gd2Fybk1pc3NpbmdQbHVnaW5EaXJlY3RpdmUobmFtZSwgZGlyZWN0aXZlTmFtZSwgc2x1Zykge1xuICBkaXJlY3RpdmUoZGlyZWN0aXZlTmFtZSwgKGVsKSA9PiB3YXJuKGBZb3UgY2FuJ3QgdXNlIFt4LSR7ZGlyZWN0aXZlTmFtZX1dIHdpdGhvdXQgZmlyc3QgaW5zdGFsbGluZyB0aGUgXCIke25hbWV9XCIgcGx1Z2luIGhlcmU6IGh0dHBzOi8vYWxwaW5lanMuZGV2L3BsdWdpbnMvJHtzbHVnfWAsIGVsKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL3NyYy9pbmRleC5qc1xuYWxwaW5lX2RlZmF1bHQuc2V0RXZhbHVhdG9yKG5vcm1hbEV2YWx1YXRvcik7XG5hbHBpbmVfZGVmYXVsdC5zZXRSZWFjdGl2aXR5RW5naW5lKHsgcmVhY3RpdmU6IHJlYWN0aXZlMiwgZWZmZWN0OiBlZmZlY3QyLCByZWxlYXNlOiBzdG9wLCByYXc6IHRvUmF3IH0pO1xudmFyIHNyY19kZWZhdWx0ID0gYWxwaW5lX2RlZmF1bHQ7XG5cbi8vIHBhY2thZ2VzL2FscGluZWpzL2J1aWxkcy9tb2R1bGUuanNcbnZhciBtb2R1bGVfZGVmYXVsdCA9IHNyY19kZWZhdWx0O1xuZXhwb3J0IHtcbiAgc3JjX2RlZmF1bHQgYXMgQWxwaW5lLFxuICBtb2R1bGVfZGVmYXVsdCBhcyBkZWZhdWx0XG59O1xuIiwiaW1wb3J0IEFscGluZSBmcm9tICdhbHBpbmVqcyc7XG53aW5kb3cuQWxwaW5lID0gQWxwaW5lO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgQWxwaW5lLnN0YXJ0KCk7XG59KTsiLCJ2YXIgRXZlbnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50cyhldmVudFR5cGUsIGV2ZW50RnVuY3Rpb25zKSB7XG4gICAgICAgIGlmIChldmVudEZ1bmN0aW9ucyA9PT0gdm9pZCAwKSB7IGV2ZW50RnVuY3Rpb25zID0gW107IH1cbiAgICAgICAgdGhpcy5fZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICAgICAgICB0aGlzLl9ldmVudEZ1bmN0aW9ucyA9IGV2ZW50RnVuY3Rpb25zO1xuICAgIH1cbiAgICBFdmVudHMucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKF90aGlzLl9ldmVudFR5cGUsIGV2ZW50RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudHM7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgRXZlbnRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzLmpzLm1hcCIsInZhciBJbnN0YW5jZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5zdGFuY2VzKCkge1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXMgPSB7XG4gICAgICAgICAgICBBY2NvcmRpb246IHt9LFxuICAgICAgICAgICAgQ2Fyb3VzZWw6IHt9LFxuICAgICAgICAgICAgQ29sbGFwc2U6IHt9LFxuICAgICAgICAgICAgRGlhbDoge30sXG4gICAgICAgICAgICBEaXNtaXNzOiB7fSxcbiAgICAgICAgICAgIERyYXdlcjoge30sXG4gICAgICAgICAgICBEcm9wZG93bjoge30sXG4gICAgICAgICAgICBNb2RhbDoge30sXG4gICAgICAgICAgICBQb3BvdmVyOiB7fSxcbiAgICAgICAgICAgIFRhYnM6IHt9LFxuICAgICAgICAgICAgVG9vbHRpcDoge30sXG4gICAgICAgICAgICBJbnB1dENvdW50ZXI6IHt9LFxuICAgICAgICAgICAgQ29weUNsaXBib2FyZDoge30sXG4gICAgICAgICAgICBEYXRlcGlja2VyOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgSW5zdGFuY2VzLnByb3RvdHlwZS5hZGRJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGluc3RhbmNlLCBpZCwgb3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlID09PSB2b2lkIDApIHsgb3ZlcnJpZGUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlc1tjb21wb25lbnRdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGbG93Yml0ZTogQ29tcG9uZW50IFwiLmNvbmNhdChjb21wb25lbnQsIFwiIGRvZXMgbm90IGV4aXN0LlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlc1tjb21wb25lbnRdW2lkXSAmJiAhb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZsb3diaXRlOiBJbnN0YW5jZSB3aXRoIElEIFwiLmNvbmNhdChpZCwgXCIgYWxyZWFkeSBleGlzdHMuXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcnJpZGUgJiYgdGhpcy5faW5zdGFuY2VzW2NvbXBvbmVudF1baWRdKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNbY29tcG9uZW50XVtpZF0uZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5zdGFuY2VzW2NvbXBvbmVudF1baWQgPyBpZCA6IHRoaXMuX2dlbmVyYXRlUmFuZG9tSWQoKV0gPVxuICAgICAgICAgICAgaW5zdGFuY2U7XG4gICAgfTtcbiAgICBJbnN0YW5jZXMucHJvdG90eXBlLmdldEFsbEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlcztcbiAgICB9O1xuICAgIEluc3RhbmNlcy5wcm90b3R5cGUuZ2V0SW5zdGFuY2VzID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlc1tjb21wb25lbnRdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGbG93Yml0ZTogQ29tcG9uZW50IFwiLmNvbmNhdChjb21wb25lbnQsIFwiIGRvZXMgbm90IGV4aXN0LlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlc1tjb21wb25lbnRdO1xuICAgIH07XG4gICAgSW5zdGFuY2VzLnByb3RvdHlwZS5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb21wb25lbnQsIGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcG9uZW50QW5kSW5zdGFuY2VDaGVjayhjb21wb25lbnQsIGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2VzW2NvbXBvbmVudF1baWRdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGbG93Yml0ZTogSW5zdGFuY2Ugd2l0aCBJRCBcIi5jb25jYXQoaWQsIFwiIGRvZXMgbm90IGV4aXN0LlwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlc1tjb21wb25lbnRdW2lkXTtcbiAgICB9O1xuICAgIEluc3RhbmNlcy5wcm90b3R5cGUuZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRBbmRJbnN0YW5jZUNoZWNrKGNvbXBvbmVudCwgaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95SW5zdGFuY2VPYmplY3QoY29tcG9uZW50LCBpZCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSW5zdGFuY2UoY29tcG9uZW50LCBpZCk7XG4gICAgfTtcbiAgICBJbnN0YW5jZXMucHJvdG90eXBlLnJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRBbmRJbnN0YW5jZUNoZWNrKGNvbXBvbmVudCwgaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX2luc3RhbmNlc1tjb21wb25lbnRdW2lkXTtcbiAgICB9O1xuICAgIEluc3RhbmNlcy5wcm90b3R5cGUuZGVzdHJveUluc3RhbmNlT2JqZWN0ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRBbmRJbnN0YW5jZUNoZWNrKGNvbXBvbmVudCwgaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5zdGFuY2VzW2NvbXBvbmVudF1baWRdLmRlc3Ryb3koKTtcbiAgICB9O1xuICAgIEluc3RhbmNlcy5wcm90b3R5cGUuaW5zdGFuY2VFeGlzdHMgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBpZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlc1tjb21wb25lbnRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZXNbY29tcG9uZW50XVtpZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEluc3RhbmNlcy5wcm90b3R5cGUuX2dlbmVyYXRlUmFuZG9tSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSk7XG4gICAgfTtcbiAgICBJbnN0YW5jZXMucHJvdG90eXBlLl9jb21wb25lbnRBbmRJbnN0YW5jZUNoZWNrID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZXNbY29tcG9uZW50XSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmxvd2JpdGU6IENvbXBvbmVudCBcIi5jb25jYXQoY29tcG9uZW50LCBcIiBkb2VzIG5vdCBleGlzdC5cIikpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5zdGFuY2VzW2NvbXBvbmVudF1baWRdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGbG93Yml0ZTogSW5zdGFuY2Ugd2l0aCBJRCBcIi5jb25jYXQoaWQsIFwiIGRvZXMgbm90IGV4aXN0LlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zdGFuY2VzO1xufSgpKTtcbnZhciBpbnN0YW5jZXMgPSBuZXcgSW5zdGFuY2VzKCk7XG5leHBvcnQgZGVmYXVsdCBpbnN0YW5jZXM7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuRmxvd2JpdGVJbnN0YW5jZXMgPSBpbnN0YW5jZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnN0YW5jZXMuanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCBpbnN0YW5jZXMgZnJvbSAnLi4vLi4vZG9tL2luc3RhbmNlcyc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBhbHdheXNPcGVuOiBmYWxzZSxcbiAgICBhY3RpdmVDbGFzc2VzOiAnYmctZ3JheS0xMDAgZGFyazpiZy1ncmF5LTgwMCB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZScsXG4gICAgaW5hY3RpdmVDbGFzc2VzOiAndGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtZ3JheS00MDAnLFxuICAgIG9uT3BlbjogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEZWZhdWx0SW5zdGFuY2VPcHRpb25zID0ge1xuICAgIGlkOiBudWxsLFxuICAgIG92ZXJyaWRlOiB0cnVlLFxufTtcbnZhciBBY2NvcmRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWNjb3JkaW9uKGFjY29yZGlvbkVsLCBpdGVtcywgb3B0aW9ucywgaW5zdGFuY2VPcHRpb25zKSB7XG4gICAgICAgIGlmIChhY2NvcmRpb25FbCA9PT0gdm9pZCAwKSB7IGFjY29yZGlvbkVsID0gbnVsbDsgfVxuICAgICAgICBpZiAoaXRlbXMgPT09IHZvaWQgMCkgeyBpdGVtcyA9IFtdOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgaWYgKGluc3RhbmNlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGluc3RhbmNlT3B0aW9ucyA9IERlZmF1bHRJbnN0YW5jZU9wdGlvbnM7IH1cbiAgICAgICAgdGhpcy5faW5zdGFuY2VJZCA9IGluc3RhbmNlT3B0aW9ucy5pZFxuICAgICAgICAgICAgPyBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgIDogYWNjb3JkaW9uRWwuaWQ7XG4gICAgICAgIHRoaXMuX2FjY29yZGlvbkVsID0gYWNjb3JkaW9uRWw7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaW5zdGFuY2VzLmFkZEluc3RhbmNlKCdBY2NvcmRpb24nLCB0aGlzLCB0aGlzLl9pbnN0YW5jZUlkLCBpbnN0YW5jZU9wdGlvbnMub3ZlcnJpZGUpO1xuICAgIH1cbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBzaG93IGFjY29yZGlvbiBpdGVtIGJhc2VkIG9uIGNsaWNrXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oaXRlbS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZShpdGVtLmlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGl0ZW0udHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2xpY2tIYW5kbGVyIGluIGEgcHJvcGVydHkgb2YgdGhlIGl0ZW0gZm9yIHJlbW92YWwgbGF0ZXJcbiAgICAgICAgICAgICAgICBpdGVtLmNsaWNrSGFuZGxlciA9IGNsaWNrSGFuZGxlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpdGVtLnRyaWdnZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGl0ZW0uY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCBieSBkZWxldGluZyB0aGUgY2xpY2tIYW5kbGVyIHByb3BlcnR5IGZyb20gdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5jbGlja0hhbmRsZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFjY29yZGlvbi5wcm90b3R5cGUucmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlcy5yZW1vdmVJbnN0YW5jZSgnQWNjb3JkaW9uJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLmRlc3Ryb3lBbmRSZW1vdmVJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSW5zdGFuY2UoKTtcbiAgICB9O1xuICAgIEFjY29yZGlvbi5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmlkID09PSBpZDsgfSlbMF07XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oaWQpO1xuICAgICAgICAvLyBkb24ndCBoaWRlIG90aGVyIGFjY29yZGlvbnMgaWYgYWx3YXlzIG9wZW5cbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmFsd2F5c09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaS50cmlnZ2VyRWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2EsIF90aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IGkudHJpZ2dlckVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9iLCBfdGhpcy5fb3B0aW9ucy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgICAgIGkudGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIGkudHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICAgICAgICAgICAgICBpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyByb3RhdGUgaWNvbiBpZiBzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkuaWNvbkVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLmljb25FbC5jbGFzc0xpc3QuYWRkKCdyb3RhdGUtMTgwJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaG93IGFjdGl2ZSBpdGVtXG4gICAgICAgIChfYSA9IGl0ZW0udHJpZ2dlckVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9hLCB0aGlzLl9vcHRpb25zLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgIChfYiA9IGl0ZW0udHJpZ2dlckVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9iLCB0aGlzLl9vcHRpb25zLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgaXRlbS50cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgICAgaXRlbS50YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgaXRlbS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAvLyByb3RhdGUgaWNvbiBpZiBzZXRcbiAgICAgICAgaWYgKGl0ZW0uaWNvbkVsKSB7XG4gICAgICAgICAgICBpdGVtLmljb25FbC5jbGFzc0xpc3QucmVtb3ZlKCdyb3RhdGUtMTgwJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbk9wZW4odGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMuZ2V0SXRlbShpZCk7XG4gICAgICAgIGlmIChpdGVtLmFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oaWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Ub2dnbGUodGhpcywgaXRlbSk7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGlkKTtcbiAgICAgICAgKF9hID0gaXRlbS50cmlnZ2VyRWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2EsIHRoaXMuX29wdGlvbnMuYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgKF9iID0gaXRlbS50cmlnZ2VyRWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2IsIHRoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICBpdGVtLnRhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBpdGVtLnRyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgaXRlbS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLy8gcm90YXRlIGljb24gaWYgc2V0XG4gICAgICAgIGlmIChpdGVtLmljb25FbCkge1xuICAgICAgICAgICAgaXRlbS5pY29uRWwuY2xhc3NMaXN0LmFkZCgncm90YXRlLTE4MCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25DbG9zZSh0aGlzLCBpdGVtKTtcbiAgICB9O1xuICAgIEFjY29yZGlvbi5wcm90b3R5cGUudXBkYXRlT25PcGVuID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25PcGVuID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLnVwZGF0ZU9uQ2xvc2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkNsb3NlID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBBY2NvcmRpb24ucHJvdG90eXBlLnVwZGF0ZU9uVG9nZ2xlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Ub2dnbGUgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIHJldHVybiBBY2NvcmRpb247XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRBY2NvcmRpb25zKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWFjY29yZGlvbl0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkYWNjb3JkaW9uRWwpIHtcbiAgICAgICAgdmFyIGFsd2F5c09wZW4gPSAkYWNjb3JkaW9uRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWFjY29yZGlvbicpO1xuICAgICAgICB2YXIgYWN0aXZlQ2xhc3NlcyA9ICRhY2NvcmRpb25FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aXZlLWNsYXNzZXMnKTtcbiAgICAgICAgdmFyIGluYWN0aXZlQ2xhc3NlcyA9ICRhY2NvcmRpb25FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5hY3RpdmUtY2xhc3NlcycpO1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgJGFjY29yZGlvbkVsXG4gICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtYWNjb3JkaW9uLXRhcmdldF0nKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIC8vIENvbnNpZGVyIG9ubHkgaXRlbXMgdGhhdCBkaXJlY3RseSBiZWxvbmcgdG8gJGFjY29yZGlvbkVsXG4gICAgICAgICAgICAvLyAodG8gbWFrZSBuZXN0ZWQgYWNjb3JkaW9ucyB3b3JrKS5cbiAgICAgICAgICAgIGlmICgkdHJpZ2dlckVsLmNsb3Nlc3QoJ1tkYXRhLWFjY29yZGlvbl0nKSA9PT0gJGFjY29yZGlvbkVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1hY2NvcmRpb24tdGFyZ2V0JyksXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFbDogJHRyaWdnZXJFbCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWw6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWNjb3JkaW9uLXRhcmdldCcpKSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkVsOiAkdHJpZ2dlckVsLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWFjY29yZGlvbi1pY29uXScpLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJykgPT09ICd0cnVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ldyBBY2NvcmRpb24oJGFjY29yZGlvbkVsLCBpdGVtcywge1xuICAgICAgICAgICAgYWx3YXlzT3BlbjogYWx3YXlzT3BlbiA9PT0gJ29wZW4nID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgYWN0aXZlQ2xhc3NlczogYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgID8gYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgIDogRGVmYXVsdC5hY3RpdmVDbGFzc2VzLFxuICAgICAgICAgICAgaW5hY3RpdmVDbGFzc2VzOiBpbmFjdGl2ZUNsYXNzZXNcbiAgICAgICAgICAgICAgICA/IGluYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgIDogRGVmYXVsdC5pbmFjdGl2ZUNsYXNzZXMsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkFjY29yZGlvbiA9IEFjY29yZGlvbjtcbiAgICB3aW5kb3cuaW5pdEFjY29yZGlvbnMgPSBpbml0QWNjb3JkaW9ucztcbn1cbmV4cG9ydCBkZWZhdWx0IEFjY29yZGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgaW5zdGFuY2VzIGZyb20gJy4uLy4uL2RvbS9pbnN0YW5jZXMnO1xudmFyIERlZmF1bHQgPSB7XG4gICAgb25Db2xsYXBzZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uRXhwYW5kOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25Ub2dnbGU6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgRGVmYXVsdEluc3RhbmNlT3B0aW9ucyA9IHtcbiAgICBpZDogbnVsbCxcbiAgICBvdmVycmlkZTogdHJ1ZSxcbn07XG52YXIgQ29sbGFwc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sbGFwc2UodGFyZ2V0RWwsIHRyaWdnZXJFbCwgb3B0aW9ucywgaW5zdGFuY2VPcHRpb25zKSB7XG4gICAgICAgIGlmICh0YXJnZXRFbCA9PT0gdm9pZCAwKSB7IHRhcmdldEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodHJpZ2dlckVsID09PSB2b2lkIDApIHsgdHJpZ2dlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIGlmIChpbnN0YW5jZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW5jZU9wdGlvbnMgPSBEZWZhdWx0SW5zdGFuY2VPcHRpb25zOyB9XG4gICAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgID8gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA6IHRhcmdldEVsLmlkO1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICBpbnN0YW5jZXMuYWRkSW5zdGFuY2UoJ0NvbGxhcHNlJywgdGhpcywgdGhpcy5faW5zdGFuY2VJZCwgaW5zdGFuY2VPcHRpb25zLm92ZXJyaWRlKTtcbiAgICB9XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwgJiYgdGhpcy5fdGFyZ2V0RWwgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKSA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZml4IHVudGlsIHYyIG5vdCB0byBicmVhayBwcmV2aW91cyBzaW5nbGUgY29sbGFwc2VzIHdoaWNoIGJlY2FtZSBkaXNtaXNzXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9ICF0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbGxhcHNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsICYmIHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZXMucmVtb3ZlSW5zdGFuY2UoJ0NvbGxhcHNlJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBDb2xsYXBzZS5wcm90b3R5cGUuZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbnN0YW5jZSgpO1xuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkNvbGxhcHNlKHRoaXMpO1xuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uRXhwYW5kKHRoaXMpO1xuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSh0aGlzKTtcbiAgICB9O1xuICAgIENvbGxhcHNlLnByb3RvdHlwZS51cGRhdGVPbkNvbGxhcHNlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Db2xsYXBzZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgQ29sbGFwc2UucHJvdG90eXBlLnVwZGF0ZU9uRXhwYW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25FeHBhbmQgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIENvbGxhcHNlLnByb3RvdHlwZS51cGRhdGVPblRvZ2dsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gQ29sbGFwc2U7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRDb2xsYXBzZXMoKSB7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNvbGxhcHNlLXRvZ2dsZV0nKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgdGFyZ2V0SWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsYXBzZS10b2dnbGUnKTtcbiAgICAgICAgdmFyICR0YXJnZXRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldElkKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHRhcmdldCBlbGVtZW50IGV4aXN0c1xuICAgICAgICBpZiAoJHRhcmdldEVsKSB7XG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlcy5pbnN0YW5jZUV4aXN0cygnQ29sbGFwc2UnLCAkdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdpZCcpKSkge1xuICAgICAgICAgICAgICAgIG5ldyBDb2xsYXBzZSgkdGFyZ2V0RWwsICR0cmlnZ2VyRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaW5zdGFuY2UgZXhpc3RzIGFscmVhZHkgZm9yIHRoZSBzYW1lIHRhcmdldCBlbGVtZW50IHRoZW4gY3JlYXRlIGEgbmV3IG9uZSB3aXRoIGEgZGlmZmVyZW50IHRyaWdnZXIgZWxlbWVudFxuICAgICAgICAgICAgICAgIG5ldyBDb2xsYXBzZSgkdGFyZ2V0RWwsICR0cmlnZ2VyRWwsIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAkdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdpZCcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdfJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXMuX2dlbmVyYXRlUmFuZG9tSWQoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgdGFyZ2V0IGVsZW1lbnQgd2l0aCBpZCBcXFwiXCIuY29uY2F0KHRhcmdldElkLCBcIlxcXCIgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBjaGVjayB0aGUgZGF0YS1jb2xsYXBzZS10b2dnbGUgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5Db2xsYXBzZSA9IENvbGxhcHNlO1xuICAgIHdpbmRvdy5pbml0Q29sbGFwc2VzID0gaW5pdENvbGxhcHNlcztcbn1cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCBpbnN0YW5jZXMgZnJvbSAnLi4vLi4vZG9tL2luc3RhbmNlcyc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBkZWZhdWx0UG9zaXRpb246IDAsXG4gICAgaW5kaWNhdG9yczoge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGFjdGl2ZUNsYXNzZXM6ICdiZy13aGl0ZSBkYXJrOmJnLWdyYXktODAwJyxcbiAgICAgICAgaW5hY3RpdmVDbGFzc2VzOiAnYmctd2hpdGUvNTAgZGFyazpiZy1ncmF5LTgwMC81MCBob3ZlcjpiZy13aGl0ZSBkYXJrOmhvdmVyOmJnLWdyYXktODAwJyxcbiAgICB9LFxuICAgIGludGVydmFsOiAzMDAwLFxuICAgIG9uTmV4dDogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uUHJldjogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERlZmF1bHRJbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgb3ZlcnJpZGU6IHRydWUsXG59O1xudmFyIENhcm91c2VsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhcm91c2VsKGNhcm91c2VsRWwsIGl0ZW1zLCBvcHRpb25zLCBpbnN0YW5jZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGNhcm91c2VsRWwgPT09IHZvaWQgMCkgeyBjYXJvdXNlbEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAoaXRlbXMgPT09IHZvaWQgMCkgeyBpdGVtcyA9IFtdOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgaWYgKGluc3RhbmNlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGluc3RhbmNlT3B0aW9ucyA9IERlZmF1bHRJbnN0YW5jZU9wdGlvbnM7IH1cbiAgICAgICAgdGhpcy5faW5zdGFuY2VJZCA9IGluc3RhbmNlT3B0aW9ucy5pZFxuICAgICAgICAgICAgPyBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgIDogY2Fyb3VzZWxFbC5pZDtcbiAgICAgICAgdGhpcy5fY2Fyb3VzZWxFbCA9IGNhcm91c2VsRWw7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpLCB7IGluZGljYXRvcnM6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0LmluZGljYXRvcnMpLCBvcHRpb25zLmluZGljYXRvcnMpIH0pO1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtID0gdGhpcy5nZXRJdGVtKHRoaXMuX29wdGlvbnMuZGVmYXVsdFBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5faW5kaWNhdG9ycyA9IHRoaXMuX29wdGlvbnMuaW5kaWNhdG9ycy5pdGVtcztcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxEdXJhdGlvbiA9IHRoaXMuX29wdGlvbnMuaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX2ludGVydmFsSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaW5zdGFuY2VzLmFkZEluc3RhbmNlKCdDYXJvdXNlbCcsIHRoaXMsIHRoaXMuX2luc3RhbmNlSWQsIGluc3RhbmNlT3B0aW9ucy5vdmVycmlkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemUgY2Fyb3VzZWwgYW5kIGl0ZW1zIGJhc2VkIG9uIGFjdGl2ZSBvbmVcbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCAmJiAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uZWwuY2xhc3NMaXN0LmFkZCgnYWJzb2x1dGUnLCAnaW5zZXQtMCcsICd0cmFuc2l0aW9uLXRyYW5zZm9ybScsICd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgbm8gYWN0aXZlIGl0ZW0gaXMgc2V0IHRoZW4gZmlyc3QgcG9zaXRpb24gaXMgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QWN0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGlkZVRvKHRoaXMuZ2V0QWN0aXZlSXRlbSgpLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVUbygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luZGljYXRvcnMubWFwKGZ1bmN0aW9uIChpbmRpY2F0b3IsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zbGlkZVRvKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUucmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlcy5yZW1vdmVJbnN0YW5jZSgnQ2Fyb3VzZWwnLCB0aGlzLl9pbnN0YW5jZUlkKTtcbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5kZXN0cm95QW5kUmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbcG9zaXRpb25dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2xpZGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb24gaWRcbiAgICAgKiBAcGFyYW0geyp9IHBvc2l0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnNsaWRlVG8gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIG5leHRJdGVtID0gdGhpcy5faXRlbXNbcG9zaXRpb25dO1xuICAgICAgICB2YXIgcm90YXRpb25JdGVtcyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG5leHRJdGVtLnBvc2l0aW9uID09PSAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgIDogdGhpcy5faXRlbXNbbmV4dEl0ZW0ucG9zaXRpb24gLSAxXSxcbiAgICAgICAgICAgIG1pZGRsZTogbmV4dEl0ZW0sXG4gICAgICAgICAgICByaWdodDogbmV4dEl0ZW0ucG9zaXRpb24gPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2l0ZW1zWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9pdGVtc1tuZXh0SXRlbS5wb3NpdGlvbiArIDFdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yb3RhdGUocm90YXRpb25JdGVtcyk7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW0obmV4dEl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25DaGFuZ2UodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtIGl0IHdpbGwgZ28gdG8gdGhlIG5leHQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUl0ZW0gPSB0aGlzLmdldEFjdGl2ZUl0ZW0oKTtcbiAgICAgICAgdmFyIG5leHRJdGVtID0gbnVsbDtcbiAgICAgICAgLy8gY2hlY2sgaWYgbGFzdCBpdGVtXG4gICAgICAgIGlmIChhY3RpdmVJdGVtLnBvc2l0aW9uID09PSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBuZXh0SXRlbSA9IHRoaXMuX2l0ZW1zWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV4dEl0ZW0gPSB0aGlzLl9pdGVtc1thY3RpdmVJdGVtLnBvc2l0aW9uICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zbGlkZVRvKG5leHRJdGVtLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbk5leHQodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtIGl0IHdpbGwgZ28gdG8gdGhlIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmVJdGVtID0gdGhpcy5nZXRBY3RpdmVJdGVtKCk7XG4gICAgICAgIHZhciBwcmV2SXRlbSA9IG51bGw7XG4gICAgICAgIC8vIGNoZWNrIGlmIGZpcnN0IGl0ZW1cbiAgICAgICAgaWYgKGFjdGl2ZUl0ZW0ucG9zaXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IHRoaXMuX2l0ZW1zW2FjdGl2ZUl0ZW0ucG9zaXRpb24gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNsaWRlVG8ocHJldkl0ZW0ucG9zaXRpb24pO1xuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uUHJldih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGFwcGxpZXMgdGhlIHRyYW5zZm9ybSBjbGFzc2VzIGJhc2VkIG9uIHRoZSBsZWZ0LCBtaWRkbGUsIGFuZCByaWdodCByb3RhdGlvbiBjYXJvdXNlbCBpdGVtc1xuICAgICAqIEBwYXJhbSB7Kn0gcm90YXRpb25JdGVtc1xuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fcm90YXRlID0gZnVuY3Rpb24gKHJvdGF0aW9uSXRlbXMpIHtcbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgdGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSBpdGVtXG4gICAgICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJvdGF0aW9uSXRlbXMubWlkZGxlLmVsLmNsYXNzTGlzdC5yZW1vdmUoJy10cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtMCcsICdoaWRkZW4nLCAnei0xMCcpO1xuICAgICAgICAgICAgcm90YXRpb25JdGVtcy5taWRkbGUuZWwuY2xhc3NMaXN0LmFkZCgndHJhbnNsYXRlLXgtMCcsICd6LTIwJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGVmdCBpdGVtIChwcmV2aW91c2x5IGFjdGl2ZSlcbiAgICAgICAgcm90YXRpb25JdGVtcy5sZWZ0LmVsLmNsYXNzTGlzdC5yZW1vdmUoJy10cmFuc2xhdGUteC1mdWxsJywgJ3RyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtMCcsICdoaWRkZW4nLCAnei0yMCcpO1xuICAgICAgICByb3RhdGlvbkl0ZW1zLmxlZnQuZWwuY2xhc3NMaXN0LmFkZCgnLXRyYW5zbGF0ZS14LWZ1bGwnLCAnei0xMCcpO1xuICAgICAgICAvLyBjdXJyZW50bHkgYWN0aXZlIGl0ZW1cbiAgICAgICAgcm90YXRpb25JdGVtcy5taWRkbGUuZWwuY2xhc3NMaXN0LnJlbW92ZSgnLXRyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC0wJywgJ2hpZGRlbicsICd6LTEwJyk7XG4gICAgICAgIHJvdGF0aW9uSXRlbXMubWlkZGxlLmVsLmNsYXNzTGlzdC5hZGQoJ3RyYW5zbGF0ZS14LTAnLCAnei0zMCcpO1xuICAgICAgICAvLyByaWdodCBpdGVtICh1cGNvbWluZyBhY3RpdmUpXG4gICAgICAgIHJvdGF0aW9uSXRlbXMucmlnaHQuZWwuY2xhc3NMaXN0LnJlbW92ZSgnLXRyYW5zbGF0ZS14LWZ1bGwnLCAndHJhbnNsYXRlLXgtZnVsbCcsICd0cmFuc2xhdGUteC0wJywgJ2hpZGRlbicsICd6LTMwJyk7XG4gICAgICAgIHJvdGF0aW9uSXRlbXMucmlnaHQuZWwuY2xhc3NMaXN0LmFkZCgndHJhbnNsYXRlLXgtZnVsbCcsICd6LTIwJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYW4gaW50ZXJ2YWwgdG8gY3ljbGUgdGhyb3VnaCB0aGUgY2Fyb3VzZWwgaXRlbXNcbiAgICAgKi9cbiAgICBDYXJvdXNlbC5wcm90b3R5cGUuY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJbnN0YW5jZSA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubmV4dCgpO1xuICAgICAgICAgICAgfSwgdGhpcy5faW50ZXJ2YWxEdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY3ljbGluZyBpbnRlcnZhbFxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbEluc3RhbmNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtXG4gICAgICovXG4gICAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVJdGVtO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGl0ZW0gYW5kIGRhdGEgYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHsqfSBwb3NpdGlvblxuICAgICAqL1xuICAgIENhcm91c2VsLnByb3RvdHlwZS5fc2V0QWN0aXZlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW0gPSBpdGVtO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGluZGljYXRvcnMgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faW5kaWNhdG9ycy5tYXAoZnVuY3Rpb24gKGluZGljYXRvcikge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaW5kaWNhdG9yLmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgKF9hID0gaW5kaWNhdG9yLmVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9hLCBfdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICAgICAgKF9iID0gaW5kaWNhdG9yLmVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9iLCBfdGhpcy5fb3B0aW9ucy5pbmRpY2F0b3JzLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5faW5kaWNhdG9yc1twb3NpdGlvbl0uZWwuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIHRoaXMuX29wdGlvbnMuaW5kaWNhdG9ycy5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5faW5kaWNhdG9yc1twb3NpdGlvbl0uZWwuY2xhc3NMaXN0KS5yZW1vdmUuYXBwbHkoX2IsIHRoaXMuX29wdGlvbnMuaW5kaWNhdG9ycy5pbmFjdGl2ZUNsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzW3Bvc2l0aW9uXS5lbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS51cGRhdGVPbk5leHQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbk5leHQgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS51cGRhdGVPblByZXYgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblByZXYgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIENhcm91c2VsLnByb3RvdHlwZS51cGRhdGVPbkNoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uQ2hhbmdlID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gQ2Fyb3VzZWw7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRDYXJvdXNlbHMoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWxdJykuZm9yRWFjaChmdW5jdGlvbiAoJGNhcm91c2VsRWwpIHtcbiAgICAgICAgdmFyIGludGVydmFsID0gJGNhcm91c2VsRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLWludGVydmFsJyk7XG4gICAgICAgIHZhciBzbGlkZSA9ICRjYXJvdXNlbEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jYXJvdXNlbCcpID09PSAnc2xpZGUnXG4gICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICB2YXIgZGVmYXVsdFBvc2l0aW9uID0gMDtcbiAgICAgICAgaWYgKCRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLWl0ZW1dJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKCRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLWl0ZW1dJykpLm1hcChmdW5jdGlvbiAoJGNhcm91c2VsSXRlbUVsLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVsOiAkY2Fyb3VzZWxJdGVtRWwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCRjYXJvdXNlbEl0ZW1FbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2Fyb3VzZWwtaXRlbScpID09PVxuICAgICAgICAgICAgICAgICAgICAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kaWNhdG9ycyA9IFtdO1xuICAgICAgICBpZiAoJGNhcm91c2VsRWwucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY2Fyb3VzZWwtc2xpZGUtdG9dJykubGVuZ3RoKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKCRjYXJvdXNlbEVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNhcm91c2VsLXNsaWRlLXRvXScpKS5tYXAoZnVuY3Rpb24gKCRpbmRpY2F0b3JFbCkge1xuICAgICAgICAgICAgICAgIGluZGljYXRvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwYXJzZUludCgkaW5kaWNhdG9yRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNhcm91c2VsLXNsaWRlLXRvJykpLFxuICAgICAgICAgICAgICAgICAgICBlbDogJGluZGljYXRvckVsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhcm91c2VsID0gbmV3IENhcm91c2VsKCRjYXJvdXNlbEVsLCBpdGVtcywge1xuICAgICAgICAgICAgZGVmYXVsdFBvc2l0aW9uOiBkZWZhdWx0UG9zaXRpb24sXG4gICAgICAgICAgICBpbmRpY2F0b3JzOiB7XG4gICAgICAgICAgICAgICAgaXRlbXM6IGluZGljYXRvcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IGludGVydmFsID8gaW50ZXJ2YWwgOiBEZWZhdWx0LmludGVydmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgICAgICBjYXJvdXNlbC5jeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBjb250cm9sc1xuICAgICAgICB2YXIgY2Fyb3VzZWxOZXh0RWwgPSAkY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jYXJvdXNlbC1uZXh0XScpO1xuICAgICAgICB2YXIgY2Fyb3VzZWxQcmV2RWwgPSAkY2Fyb3VzZWxFbC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jYXJvdXNlbC1wcmV2XScpO1xuICAgICAgICBpZiAoY2Fyb3VzZWxOZXh0RWwpIHtcbiAgICAgICAgICAgIGNhcm91c2VsTmV4dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhcm91c2VsLm5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYXJvdXNlbFByZXZFbCkge1xuICAgICAgICAgICAgY2Fyb3VzZWxQcmV2RWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2Fyb3VzZWwucHJldigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5DYXJvdXNlbCA9IENhcm91c2VsO1xuICAgIHdpbmRvdy5pbml0Q2Fyb3VzZWxzID0gaW5pdENhcm91c2Vscztcbn1cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCBpbnN0YW5jZXMgZnJvbSAnLi4vLi4vZG9tL2luc3RhbmNlcyc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNpdGlvbi1vcGFjaXR5JyxcbiAgICBkdXJhdGlvbjogMzAwLFxuICAgIHRpbWluZzogJ2Vhc2Utb3V0JyxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgRGVmYXVsdEluc3RhbmNlT3B0aW9ucyA9IHtcbiAgICBpZDogbnVsbCxcbiAgICBvdmVycmlkZTogdHJ1ZSxcbn07XG52YXIgRGlzbWlzcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXNtaXNzKHRhcmdldEVsLCB0cmlnZ2VyRWwsIG9wdGlvbnMsIGluc3RhbmNlT3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRyaWdnZXJFbCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICBpZiAoaW5zdGFuY2VPcHRpb25zID09PSB2b2lkIDApIHsgaW5zdGFuY2VPcHRpb25zID0gRGVmYXVsdEluc3RhbmNlT3B0aW9uczsgfVxuICAgICAgICB0aGlzLl9pbnN0YW5jZUlkID0gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA/IGluc3RhbmNlT3B0aW9ucy5pZFxuICAgICAgICAgICAgOiB0YXJnZXRFbC5pZDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gdHJpZ2dlckVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGluc3RhbmNlcy5hZGRJbnN0YW5jZSgnRGlzbWlzcycsIHRoaXMsIHRoaXMuX2luc3RhbmNlSWQsIGluc3RhbmNlT3B0aW9ucy5vdmVycmlkZSk7XG4gICAgfVxuICAgIERpc21pc3MucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwgJiYgdGhpcy5fdGFyZ2V0RWwgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpc21pc3MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXNtaXNzLnByb3RvdHlwZS5yZW1vdmVJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2VzLnJlbW92ZUluc3RhbmNlKCdEaXNtaXNzJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBEaXNtaXNzLnByb3RvdHlwZS5kZXN0cm95QW5kUmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBEaXNtaXNzLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKHRoaXMuX29wdGlvbnMudHJhbnNpdGlvbiwgXCJkdXJhdGlvbi1cIi5jb25jYXQodGhpcy5fb3B0aW9ucy5kdXJhdGlvbiksIHRoaXMuX29wdGlvbnMudGltaW5nLCAnb3BhY2l0eS0wJyk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICB9LCB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcywgdGhpcy5fdGFyZ2V0RWwpO1xuICAgIH07XG4gICAgRGlzbWlzcy5wcm90b3R5cGUudXBkYXRlT25IaWRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzbWlzcztcbn0oKSk7XG5leHBvcnQgZnVuY3Rpb24gaW5pdERpc21pc3NlcygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kaXNtaXNzLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc21pc3MtdGFyZ2V0Jyk7XG4gICAgICAgIHZhciAkZGlzbWlzc0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRJZCk7XG4gICAgICAgIGlmICgkZGlzbWlzc0VsKSB7XG4gICAgICAgICAgICBuZXcgRGlzbWlzcygkZGlzbWlzc0VsLCAkdHJpZ2dlckVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgZGlzbWlzcyBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdCh0YXJnZXRJZCwgXCJcXFwiIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgY2hlY2sgdGhlIGRhdGEtZGlzbWlzcy10YXJnZXQgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5EaXNtaXNzID0gRGlzbWlzcztcbiAgICB3aW5kb3cuaW5pdERpc21pc3NlcyA9IGluaXREaXNtaXNzZXM7XG59XG5leHBvcnQgZGVmYXVsdCBEaXNtaXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFVBU3RyaW5nKCkge1xuICB2YXIgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG5cbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn0iLCJpbXBvcnQgZ2V0VUFTdHJpbmcgZnJvbSBcIi4uL3V0aWxzL3VzZXJBZ2VudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufSIsImltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCwgaXNGaXhlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFVBU3RyaW5nIGZyb20gXCIuLi91dGlscy91c2VyQWdlbnQuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJ2YXIgaGFzaCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBmYWxzZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59IiwiaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBjbGlwcGluZ1BhcmVudHMsIHJlZmVyZW5jZSwgcG9wcGVyLCBib3R0b20sIHRvcCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi9leHBhbmRUb0hhc2hNYXAuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIHN0cmF0ZWd5ID0gX29wdGlvbnMkc3RyYXRlZ3kgPT09IHZvaWQgMCA/IHN0YXRlLnN0cmF0ZWd5IDogX29wdGlvbnMkc3RyYXRlZ3ksXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufSIsImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB7IHdpdGhpbiwgd2l0aGluTWF4Q2xhbXAgfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtaW4gYXMgbWF0aE1pbiwgbWF4IGFzIG1hdGhNYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHRldGhlck9mZnNldFZhbHVlKTtcbiAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHdpdGhpbiB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbmltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCBpbnN0YW5jZXMgZnJvbSAnLi4vLi4vZG9tL2luc3RhbmNlcyc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgIHRyaWdnZXJUeXBlOiAnY2xpY2snLFxuICAgIG9mZnNldFNraWRkaW5nOiAwLFxuICAgIG9mZnNldERpc3RhbmNlOiAxMCxcbiAgICBkZWxheTogMzAwLFxuICAgIGlnbm9yZUNsaWNrT3V0c2lkZUNsYXNzOiBmYWxzZSxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEZWZhdWx0SW5zdGFuY2VPcHRpb25zID0ge1xuICAgIGlkOiBudWxsLFxuICAgIG92ZXJyaWRlOiB0cnVlLFxufTtcbnZhciBEcm9wZG93biA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcm9wZG93bih0YXJnZXRFbGVtZW50LCB0cmlnZ2VyRWxlbWVudCwgb3B0aW9ucywgaW5zdGFuY2VPcHRpb25zKSB7XG4gICAgICAgIGlmICh0YXJnZXRFbGVtZW50ID09PSB2b2lkIDApIHsgdGFyZ2V0RWxlbWVudCA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRyaWdnZXJFbGVtZW50ID09PSB2b2lkIDApIHsgdHJpZ2dlckVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgaWYgKGluc3RhbmNlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGluc3RhbmNlT3B0aW9ucyA9IERlZmF1bHRJbnN0YW5jZU9wdGlvbnM7IH1cbiAgICAgICAgdGhpcy5faW5zdGFuY2VJZCA9IGluc3RhbmNlT3B0aW9ucy5pZFxuICAgICAgICAgICAgPyBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgIDogdGFyZ2V0RWxlbWVudC5pZDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwgPSB0YXJnZXRFbGVtZW50O1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWxlbWVudDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaW5zdGFuY2VzLmFkZEluc3RhbmNlKCdEcm9wZG93bicsIHRoaXMsIHRoaXMuX2luc3RhbmNlSWQsIGluc3RhbmNlT3B0aW9ucy5vdmVycmlkZSk7XG4gICAgfVxuICAgIERyb3Bkb3duLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsICYmIHRoaXMuX3RhcmdldEVsICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRyaWdnZXJFdmVudHMgPSB0aGlzLl9nZXRUcmlnZ2VyRXZlbnRzKCk7XG4gICAgICAgIC8vIFJlbW92ZSBjbGljayBldmVudCBsaXN0ZW5lcnMgZm9yIHRyaWdnZXIgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5zaG93RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5fY2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBob3ZlciBldmVudCBsaXN0ZW5lcnMgZm9yIHRyaWdnZXIgYW5kIHRhcmdldCBlbGVtZW50c1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5zaG93RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5faG92ZXJTaG93VHJpZ2dlckVsSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXYsIF90aGlzLl9ob3ZlclNob3dUYXJnZXRFbEhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzLmhpZGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdHJpZ2dlckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXYsIF90aGlzLl9ob3ZlckhpZGVIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX2hvdmVySGlkZUhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLnJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZXMucmVtb3ZlSW5zdGFuY2UoJ0Ryb3Bkb3duJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbnN0YW5jZSgpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9zZXR1cEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHJpZ2dlckV2ZW50cyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNsaWNrIGV2ZW50IGhhbmRsaW5nIGZvciB0cmlnZ2VyIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX2NsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ob3ZlclNob3dUcmlnZ2VyRWxIYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcy5fb3B0aW9ucy5kZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hvdmVyU2hvd1RhcmdldEVsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faG92ZXJIaWRlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3RhcmdldEVsLm1hdGNoZXMoJzpob3ZlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfdGhpcy5fb3B0aW9ucy5kZWxheSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGhvdmVyIGV2ZW50IGhhbmRsaW5nIGZvciB0cmlnZ2VyIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUgPT09ICdob3ZlcicpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX2hvdmVyU2hvd1RyaWdnZXJFbEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5faG92ZXJTaG93VGFyZ2V0RWxIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5faG92ZXJIaWRlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIF90aGlzLl9ob3ZlckhpZGVIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuX2NyZWF0ZVBvcHBlckluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9wcGVyKHRoaXMuX3RyaWdnZXJFbCwgdGhpcy5fdGFyZ2V0RWwsIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9mZnNldFNraWRkaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub2Zmc2V0RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERyb3Bkb3duLnByb3RvdHlwZS5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUNsaWNrT3V0c2lkZShldiwgX3RoaXMuX3RhcmdldEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9yZW1vdmVDbGlja091dHNpZGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoZXYsIHRhcmdldEVsKSB7XG4gICAgICAgIHZhciBjbGlja2VkRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIC8vIElnbm9yZSBjbGlja3Mgb24gdGhlIHRyaWdnZXIgZWxlbWVudCAoaWUuIGEgZGF0ZXBpY2tlciBpbnB1dClcbiAgICAgICAgdmFyIGlnbm9yZUNsaWNrT3V0c2lkZUNsYXNzID0gdGhpcy5fb3B0aW9ucy5pZ25vcmVDbGlja091dHNpZGVDbGFzcztcbiAgICAgICAgdmFyIGlzSWdub3JlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoaWdub3JlQ2xpY2tPdXRzaWRlQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBpZ25vcmVkQ2xpY2tPdXRzaWRlRWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5cIi5jb25jYXQoaWdub3JlQ2xpY2tPdXRzaWRlQ2xhc3MpKTtcbiAgICAgICAgICAgIGlnbm9yZWRDbGlja091dHNpZGVFbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuY29udGFpbnMoY2xpY2tlZEVsKSkge1xuICAgICAgICAgICAgICAgICAgICBpc0lnbm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGNsaWNrcyBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQgKGllLiBkcm9wZG93biBpdHNlbGYpXG4gICAgICAgIGlmIChjbGlja2VkRWwgIT09IHRhcmdldEVsICYmXG4gICAgICAgICAgICAhdGFyZ2V0RWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJlxuICAgICAgICAgICAgIXRoaXMuX3RyaWdnZXJFbC5jb250YWlucyhjbGlja2VkRWwpICYmXG4gICAgICAgICAgICAhaXNJZ25vcmVkICYmXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLl9nZXRUcmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ21vdXNlZW50ZXInLCAnY2xpY2snXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogWydtb3VzZWxlYXZlJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydjbGljayddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlKHRoaXMpO1xuICAgIH07XG4gICAgRHJvcGRvd24ucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2Jsb2NrJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtb2RpZmllcnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy5tb2RpZmllcnMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiB0cnVlIH0sXG4gICAgICAgICAgICBdLCBmYWxzZSkgfSkpOyB9KTtcbiAgICAgICAgdGhpcy5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBVcGRhdGUgaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnYmxvY2snKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtb2RpZmllcnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy5tb2RpZmllcnMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgXSwgZmFsc2UpIH0pKTsgfSk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tPdXRzaWRlTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUudXBkYXRlT25TaG93ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93ID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUudXBkYXRlT25IaWRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBEcm9wZG93bi5wcm90b3R5cGUudXBkYXRlT25Ub2dnbGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIERyb3Bkb3duO1xufSgpKTtcbmV4cG9ydCBmdW5jdGlvbiBpbml0RHJvcGRvd25zKCkge1xuICAgIGRvY3VtZW50XG4gICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kcm9wZG93bi10b2dnbGVdJylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duSWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi10b2dnbGUnKTtcbiAgICAgICAgdmFyICRkcm9wZG93bkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcGRvd25JZCk7XG4gICAgICAgIGlmICgkZHJvcGRvd25FbCkge1xuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgdmFyIG9mZnNldFNraWRkaW5nID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJvcGRvd24tb2Zmc2V0LXNraWRkaW5nJyk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0RGlzdGFuY2UgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi1vZmZzZXQtZGlzdGFuY2UnKTtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyVHlwZSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLXRyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBkZWxheSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyb3Bkb3duLWRlbGF5Jyk7XG4gICAgICAgICAgICB2YXIgaWdub3JlQ2xpY2tPdXRzaWRlQ2xhc3MgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcm9wZG93bi1pZ25vcmUtY2xpY2stb3V0c2lkZS1jbGFzcycpO1xuICAgICAgICAgICAgbmV3IERyb3Bkb3duKCRkcm9wZG93bkVsLCAkdHJpZ2dlckVsLCB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiBEZWZhdWx0LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTogdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQudHJpZ2dlclR5cGUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2tpZGRpbmc6IG9mZnNldFNraWRkaW5nXG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQob2Zmc2V0U2tpZGRpbmcpXG4gICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC5vZmZzZXRTa2lkZGluZyxcbiAgICAgICAgICAgICAgICBvZmZzZXREaXN0YW5jZTogb2Zmc2V0RGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChvZmZzZXREaXN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0Lm9mZnNldERpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSA/IHBhcnNlSW50KGRlbGF5KSA6IERlZmF1bHQuZGVsYXksXG4gICAgICAgICAgICAgICAgaWdub3JlQ2xpY2tPdXRzaWRlQ2xhc3M6IGlnbm9yZUNsaWNrT3V0c2lkZUNsYXNzXG4gICAgICAgICAgICAgICAgICAgID8gaWdub3JlQ2xpY2tPdXRzaWRlQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0Lmlnbm9yZUNsaWNrT3V0c2lkZUNsYXNzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIGRyb3Bkb3duIGVsZW1lbnQgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGRyb3Bkb3duSWQsIFwiXFxcIiBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRhLWRyb3Bkb3duLXRvZ2dsZSBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkRyb3Bkb3duID0gRHJvcGRvd247XG4gICAgd2luZG93LmluaXREcm9wZG93bnMgPSBpbml0RHJvcGRvd25zO1xufVxuZXhwb3J0IGRlZmF1bHQgRHJvcGRvd247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0IGluc3RhbmNlcyBmcm9tICcuLi8uLi9kb20vaW5zdGFuY2VzJztcbnZhciBEZWZhdWx0ID0ge1xuICAgIHBsYWNlbWVudDogJ2NlbnRlcicsXG4gICAgYmFja2Ryb3BDbGFzc2VzOiAnYmctZ3JheS05MDAvNTAgZGFyazpiZy1ncmF5LTkwMC84MCBmaXhlZCBpbnNldC0wIHotNDAnLFxuICAgIGJhY2tkcm9wOiAnZHluYW1pYycsXG4gICAgY2xvc2FibGU6IHRydWUsXG4gICAgb25IaWRlOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25Ub2dnbGU6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgRGVmYXVsdEluc3RhbmNlT3B0aW9ucyA9IHtcbiAgICBpZDogbnVsbCxcbiAgICBvdmVycmlkZTogdHJ1ZSxcbn07XG52YXIgTW9kYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9kYWwodGFyZ2V0RWwsIG9wdGlvbnMsIGluc3RhbmNlT3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICBpZiAoaW5zdGFuY2VPcHRpb25zID09PSB2b2lkIDApIHsgaW5zdGFuY2VPcHRpb25zID0gRGVmYXVsdEluc3RhbmNlT3B0aW9uczsgfVxuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVySW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgID8gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA6IHRhcmdldEVsLmlkO1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGluc3RhbmNlcy5hZGRJbnN0YW5jZSgnTW9kYWwnLCB0aGlzLCB0aGlzLl9pbnN0YW5jZUlkLCBpbnN0YW5jZU9wdGlvbnMub3ZlcnJpZGUpO1xuICAgIH1cbiAgICBNb2RhbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldEVsICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3NlcygpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lckluc3RhbmNlcygpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUJhY2tkcm9wRWwoKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2VzLnJlbW92ZUluc3RhbmNlKCdNb2RhbCcsIHRoaXMuX2luc3RhbmNlSWQpO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLmRlc3Ryb3lBbmRSZW1vdmVJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSW5zdGFuY2UoKTtcbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5fY3JlYXRlQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2lzSGlkZGVuKSB7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3BFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgKF9hID0gYmFja2Ryb3BFbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgdGhpcy5fb3B0aW9ucy5iYWNrZHJvcENsYXNzZXMuc3BsaXQoJyAnKSk7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYXBwZW5kKGJhY2tkcm9wRWwpO1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BFbCA9IGJhY2tkcm9wRWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGFsLnByb3RvdHlwZS5fZGVzdHJveUJhY2tkcm9wRWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNIaWRkZW4gJiYgdGhpcy5fYmFja2Ryb3BFbCkge1xuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BFbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wRWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuX3NldHVwTW9kYWxDbG9zZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5iYWNrZHJvcCA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZU91dHNpZGVDbGljayhldi50YXJnZXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuX3JlbW92ZU1vZGFsQ2xvc2VFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYmFja2Ryb3AgPT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuX2hhbmRsZU91dHNpZGVDbGljayA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fdGFyZ2V0RWwgfHxcbiAgICAgICAgICAgICh0YXJnZXQgPT09IHRoaXMuX2JhY2tkcm9wRWwgJiYgdGhpcy5pc1Zpc2libGUoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuX2dldFBsYWNlbWVudENsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHRvcFxuICAgICAgICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktc3RhcnQnLCAnaXRlbXMtc3RhcnQnXTtcbiAgICAgICAgICAgIGNhc2UgJ3RvcC1jZW50ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktY2VudGVyJywgJ2l0ZW1zLXN0YXJ0J107XG4gICAgICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktZW5kJywgJ2l0ZW1zLXN0YXJ0J107XG4gICAgICAgICAgICAvLyBjZW50ZXJcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlci1sZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LXN0YXJ0JywgJ2l0ZW1zLWNlbnRlciddO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWNlbnRlcicsICdpdGVtcy1jZW50ZXInXTtcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlci1yaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1lbmQnLCAnaXRlbXMtY2VudGVyJ107XG4gICAgICAgICAgICAvLyBib3R0b21cbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LXN0YXJ0JywgJ2l0ZW1zLWVuZCddO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tLWNlbnRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnanVzdGlmeS1jZW50ZXInLCAnaXRlbXMtZW5kJ107XG4gICAgICAgICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2p1c3RpZnktZW5kJywgJ2l0ZW1zLWVuZCddO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gWydqdXN0aWZ5LWNlbnRlcicsICdpdGVtcy1jZW50ZXInXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Ub2dnbGUodGhpcyk7XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ2ZsZXgnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgJ3RydWUnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUJhY2tkcm9wKCk7XG4gICAgICAgICAgICB0aGlzLl9pc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQWRkIGtleWJvYXJkIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuY2xvc2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR1cE1vZGFsQ2xvc2VFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJldmVudCBib2R5IHNjcm9sbFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdvdmVyZmxvdy1oaWRkZW4nKTtcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uU2hvdyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdmbGV4Jyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95QmFja2Ryb3BFbCgpO1xuICAgICAgICAgICAgdGhpcy5faXNIaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgLy8gcmUtYXBwbHkgYm9keSBzY3JvbGxcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnb3ZlcmZsb3ctaGlkZGVuJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5jbG9zYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZU1vZGFsQ2xvc2VFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2lzSGlkZGVuO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLmlzSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNIaWRkZW47XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lckluc3RhbmNlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lckluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNb2RhbC5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lckluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lckluc3RhbmNlcy5tYXAoZnVuY3Rpb24gKGV2ZW50TGlzdGVuZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lckluc3RhbmNlLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudExpc3RlbmVySW5zdGFuY2UudHlwZSwgZXZlbnRMaXN0ZW5lckluc3RhbmNlLmhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lckluc3RhbmNlcyA9IFtdO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLmdldEFsbEV2ZW50TGlzdGVuZXJJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudExpc3RlbmVySW5zdGFuY2VzO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLnVwZGF0ZU9uU2hvdyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uU2hvdyA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLnVwZGF0ZU9uSGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgTW9kYWwucHJvdG90eXBlLnVwZGF0ZU9uVG9nZ2xlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Ub2dnbGUgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIHJldHVybiBNb2RhbDtcbn0oKSk7XG5leHBvcnQgZnVuY3Rpb24gaW5pdE1vZGFscygpIHtcbiAgICAvLyBpbml0aWF0ZSBtb2RhbCBiYXNlZCBvbiBkYXRhLW1vZGFsLXRhcmdldFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBtb2RhbElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtdGFyZ2V0Jyk7XG4gICAgICAgIHZhciAkbW9kYWxFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG1vZGFsSWQpO1xuICAgICAgICBpZiAoJG1vZGFsRWwpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkbW9kYWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtcGxhY2VtZW50Jyk7XG4gICAgICAgICAgICB2YXIgYmFja2Ryb3AgPSAkbW9kYWxFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kYWwtYmFja2Ryb3AnKTtcbiAgICAgICAgICAgIG5ldyBNb2RhbCgkbW9kYWxFbCwge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50ID8gcGxhY2VtZW50IDogRGVmYXVsdC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgYmFja2Ryb3A6IGJhY2tkcm9wID8gYmFja2Ryb3AgOiBEZWZhdWx0LmJhY2tkcm9wLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWwgd2l0aCBpZCBcIi5jb25jYXQobW9kYWxJZCwgXCIgZG9lcyBub3QgZXhpc3QuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLW1vZGFsLXRhcmdldCBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkPy5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gdG9nZ2xlIG1vZGFsIHZpc2liaWxpdHlcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tb2RhbC10b2dnbGVdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgbW9kYWxJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLXRvZ2dsZScpO1xuICAgICAgICB2YXIgJG1vZGFsRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtb2RhbElkKTtcbiAgICAgICAgaWYgKCRtb2RhbEVsKSB7XG4gICAgICAgICAgICB2YXIgbW9kYWxfMSA9IGluc3RhbmNlcy5nZXRJbnN0YW5jZSgnTW9kYWwnLCBtb2RhbElkKTtcbiAgICAgICAgICAgIGlmIChtb2RhbF8xKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvZ2dsZU1vZGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RhbF8xLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZU1vZGFsKTtcbiAgICAgICAgICAgICAgICBtb2RhbF8xLmFkZEV2ZW50TGlzdGVuZXJJbnN0YW5jZSgkdHJpZ2dlckVsLCAnY2xpY2snLCB0b2dnbGVNb2RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWwgd2l0aCBpZCBcIi5jb25jYXQobW9kYWxJZCwgXCIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBQbGVhc2UgaW5pdGlhbGl6ZSBpdCB1c2luZyB0aGUgZGF0YS1tb2RhbC10YXJnZXQgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTW9kYWwgd2l0aCBpZCBcIi5jb25jYXQobW9kYWxJZCwgXCIgZG9lcyBub3QgZXhpc3QuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLW1vZGFsLXRvZ2dsZSBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBzaG93IG1vZGFsIG9uIGNsaWNrIGlmIGV4aXN0cyBiYXNlZCBvbiBpZFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLXNob3ddJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgbW9kYWxJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLXNob3cnKTtcbiAgICAgICAgdmFyICRtb2RhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJZCk7XG4gICAgICAgIGlmICgkbW9kYWxFbCkge1xuICAgICAgICAgICAgdmFyIG1vZGFsXzIgPSBpbnN0YW5jZXMuZ2V0SW5zdGFuY2UoJ01vZGFsJywgbW9kYWxJZCk7XG4gICAgICAgICAgICBpZiAobW9kYWxfMikge1xuICAgICAgICAgICAgICAgIHZhciBzaG93TW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsXzIuc2hvdygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNob3dNb2RhbCk7XG4gICAgICAgICAgICAgICAgbW9kYWxfMi5hZGRFdmVudExpc3RlbmVySW5zdGFuY2UoJHRyaWdnZXJFbCwgJ2NsaWNrJywgc2hvd01vZGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIFBsZWFzZSBpbml0aWFsaXplIGl0IHVzaW5nIHRoZSBkYXRhLW1vZGFsLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBkb2VzIG5vdCBleGlzdC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtbW9kYWwtc2hvdyBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBoaWRlIG1vZGFsIG9uIGNsaWNrIGlmIGV4aXN0cyBiYXNlZCBvbiBpZFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1vZGFsLWhpZGVdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRyaWdnZXJFbCkge1xuICAgICAgICB2YXIgbW9kYWxJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1vZGFsLWhpZGUnKTtcbiAgICAgICAgdmFyICRtb2RhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobW9kYWxJZCk7XG4gICAgICAgIGlmICgkbW9kYWxFbCkge1xuICAgICAgICAgICAgdmFyIG1vZGFsXzMgPSBpbnN0YW5jZXMuZ2V0SW5zdGFuY2UoJ01vZGFsJywgbW9kYWxJZCk7XG4gICAgICAgICAgICBpZiAobW9kYWxfMykge1xuICAgICAgICAgICAgICAgIHZhciBoaWRlTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsXzMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhpZGVNb2RhbCk7XG4gICAgICAgICAgICAgICAgbW9kYWxfMy5hZGRFdmVudExpc3RlbmVySW5zdGFuY2UoJHRyaWdnZXJFbCwgJ2NsaWNrJywgaGlkZU1vZGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIFBsZWFzZSBpbml0aWFsaXplIGl0IHVzaW5nIHRoZSBkYXRhLW1vZGFsLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb2RhbCB3aXRoIGlkIFwiLmNvbmNhdChtb2RhbElkLCBcIiBkb2VzIG5vdCBleGlzdC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtbW9kYWwtaGlkZSBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IG1vZGFsIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5Nb2RhbCA9IE1vZGFsO1xuICAgIHdpbmRvdy5pbml0TW9kYWxzID0gaW5pdE1vZGFscztcbn1cbmV4cG9ydCBkZWZhdWx0IE1vZGFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCBpbnN0YW5jZXMgZnJvbSAnLi4vLi4vZG9tL2luc3RhbmNlcyc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICdsZWZ0JyxcbiAgICBib2R5U2Nyb2xsaW5nOiBmYWxzZSxcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBlZGdlOiBmYWxzZSxcbiAgICBlZGdlT2Zmc2V0OiAnYm90dG9tLVs2MHB4XScsXG4gICAgYmFja2Ryb3BDbGFzc2VzOiAnYmctZ3JheS05MDAvNTAgZGFyazpiZy1ncmF5LTkwMC84MCBmaXhlZCBpbnNldC0wIHotMzAnLFxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERlZmF1bHRJbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgb3ZlcnJpZGU6IHRydWUsXG59O1xudmFyIERyYXdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEcmF3ZXIodGFyZ2V0RWwsIG9wdGlvbnMsIGluc3RhbmNlT3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICBpZiAoaW5zdGFuY2VPcHRpb25zID09PSB2b2lkIDApIHsgaW5zdGFuY2VPcHRpb25zID0gRGVmYXVsdEluc3RhbmNlT3B0aW9uczsgfVxuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVySW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgID8gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA6IHRhcmdldEVsLmlkO1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaW5zdGFuY2VzLmFkZEluc3RhbmNlKCdEcmF3ZXInLCB0aGlzLCB0aGlzLl9pbnN0YW5jZUlkLCBpbnN0YW5jZU9wdGlvbnMub3ZlcnJpZGUpO1xuICAgIH1cbiAgICBEcmF3ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIHNldCBpbml0aWFsIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0RWwgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ3RyYW5zaXRpb24tdHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAvLyBzZXQgYmFzZSBwbGFjZW1lbnQgY2xhc3Nlc1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCkuYmFzZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRXNjYXBlS2V5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgJ0VzY2FwZScga2V5IGlzIHByZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgRHJhd2VyIGlzIHZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTsgLy8gaGlkZSB0aGUgRHJhd2VyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gYWRkIGtleWJvYXJkIGV2ZW50IGxpc3RlbmVyIHRvIGRvY3VtZW50XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5faGFuZGxlRXNjYXBlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lckluc3RhbmNlcygpO1xuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUJhY2tkcm9wRWwoKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUga2V5Ym9hcmQgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVFc2NhcGVLZXkpO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5yZW1vdmVJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2VzLnJlbW92ZUluc3RhbmNlKCdEcmF3ZXInLCB0aGlzLl9pbnN0YW5jZUlkKTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbnN0YW5jZSgpO1xuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgZWRnZSBvcHRpb24gc2hvdyBwbGFjZW1lbnQgY2xhc3Nlc1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5lZGdlKSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50ICsgJy1lZGdlJykuYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50ICsgJy1lZGdlJykuaW5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQpLmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCkuaW5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgICAgIC8vIGVuYWJsZSBib2R5IHNjcm9sbFxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuYm9keVNjcm9sbGluZykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdvdmVyZmxvdy1oaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZXN0cm95IGJhY2tkcm9wXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJhY2tkcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95QmFja2Ryb3BFbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQgKyAnLWVkZ2UnKS5hY3RpdmUubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2dldFBsYWNlbWVudENsYXNzZXModGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQgKyAnLWVkZ2UnKS5pbmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2V0UGxhY2VtZW50Q2xhc3Nlcyh0aGlzLl9vcHRpb25zLnBsYWNlbWVudCkuYWN0aXZlLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKGMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9nZXRQbGFjZW1lbnRDbGFzc2VzKHRoaXMuX29wdGlvbnMucGxhY2VtZW50KS5pbmFjdGl2ZS5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIC8vIGRpc2FibGUgYm9keSBzY3JvbGxcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmJvZHlTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnb3ZlcmZsb3ctaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdyBiYWNrZHJvcFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlQmFja2Ryb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuX2NyZWF0ZUJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgdmFyIGJhY2tkcm9wRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJhY2tkcm9wRWwuc2V0QXR0cmlidXRlKCdkcmF3ZXItYmFja2Ryb3AnLCAnJyk7XG4gICAgICAgICAgICAoX2EgPSBiYWNrZHJvcEVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9hLCB0aGlzLl9vcHRpb25zLmJhY2tkcm9wQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5hcHBlbmQoYmFja2Ryb3BFbCk7XG4gICAgICAgICAgICBiYWNrZHJvcEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLl9kZXN0cm95QmFja2Ryb3BFbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUgJiZcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkcmF3ZXItYmFja2Ryb3BdJykgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkcmF3ZXItYmFja2Ryb3BdJykucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuX2dldFBsYWNlbWVudENsYXNzZXMgPSBmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IFsndG9wLTAnLCAnbGVmdC0wJywgJ3JpZ2h0LTAnXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBbJ3RyYW5zZm9ybS1ub25lJ10sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiBbJy10cmFuc2xhdGUteS1mdWxsJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXNlOiBbJ3JpZ2h0LTAnLCAndG9wLTAnXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBbJ3RyYW5zZm9ybS1ub25lJ10sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiBbJ3RyYW5zbGF0ZS14LWZ1bGwnXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXNlOiBbJ2JvdHRvbS0wJywgJ2xlZnQtMCcsICdyaWdodC0wJ10sXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogWyd0cmFuc2Zvcm0tbm9uZSddLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogWyd0cmFuc2xhdGUteS1mdWxsJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IFsnbGVmdC0wJywgJ3RvcC0wJ10sXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogWyd0cmFuc2Zvcm0tbm9uZSddLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogWyctdHJhbnNsYXRlLXgtZnVsbCddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdib3R0b20tZWRnZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogWydsZWZ0LTAnLCAndG9wLTAnXSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBbJ3RyYW5zZm9ybS1ub25lJ10sXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlOiBbJ3RyYW5zbGF0ZS15LWZ1bGwnLCB0aGlzLl9vcHRpb25zLmVkZ2VPZmZzZXRdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U6IFsnbGVmdC0wJywgJ3RvcC0wJ10sXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogWyd0cmFuc2Zvcm0tbm9uZSddLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogWyctdHJhbnNsYXRlLXgtZnVsbCddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lckluc3RhbmNlID0gZnVuY3Rpb24gKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lckluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJJbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChldmVudExpc3RlbmVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJJbnN0YW5jZS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRMaXN0ZW5lckluc3RhbmNlLnR5cGUsIGV2ZW50TGlzdGVuZXJJbnN0YW5jZS5oYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJJbnN0YW5jZXMgPSBbXTtcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUuZ2V0QWxsRXZlbnRMaXN0ZW5lckluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TGlzdGVuZXJJbnN0YW5jZXM7XG4gICAgfTtcbiAgICBEcmF3ZXIucHJvdG90eXBlLnVwZGF0ZU9uU2hvdyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uU2hvdyA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgRHJhd2VyLnByb3RvdHlwZS51cGRhdGVPbkhpZGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIERyYXdlci5wcm90b3R5cGUudXBkYXRlT25Ub2dnbGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIERyYXdlcjtcbn0oKSk7XG5leHBvcnQgZnVuY3Rpb24gaW5pdERyYXdlcnMoKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtZHJhd2VyLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIC8vIG1hbmRhdG9yeVxuICAgICAgICB2YXIgZHJhd2VySWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItdGFyZ2V0Jyk7XG4gICAgICAgIHZhciAkZHJhd2VyRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkcmF3ZXJJZCk7XG4gICAgICAgIGlmICgkZHJhd2VyRWwpIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItcGxhY2VtZW50Jyk7XG4gICAgICAgICAgICB2YXIgYm9keVNjcm9sbGluZyA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1ib2R5LXNjcm9sbGluZycpO1xuICAgICAgICAgICAgdmFyIGJhY2tkcm9wID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLWJhY2tkcm9wJyk7XG4gICAgICAgICAgICB2YXIgZWRnZSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1lZGdlJyk7XG4gICAgICAgICAgICB2YXIgZWRnZU9mZnNldCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1lZGdlLW9mZnNldCcpO1xuICAgICAgICAgICAgbmV3IERyYXdlcigkZHJhd2VyRWwsIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCA/IHBsYWNlbWVudCA6IERlZmF1bHQucGxhY2VtZW50LFxuICAgICAgICAgICAgICAgIGJvZHlTY3JvbGxpbmc6IGJvZHlTY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgPyBib2R5U2Nyb2xsaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQuYm9keVNjcm9sbGluZyxcbiAgICAgICAgICAgICAgICBiYWNrZHJvcDogYmFja2Ryb3BcbiAgICAgICAgICAgICAgICAgICAgPyBiYWNrZHJvcCA9PT0gJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LmJhY2tkcm9wLFxuICAgICAgICAgICAgICAgIGVkZ2U6IGVkZ2UgPyAoZWRnZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlKSA6IERlZmF1bHQuZWRnZSxcbiAgICAgICAgICAgICAgICBlZGdlT2Zmc2V0OiBlZGdlT2Zmc2V0ID8gZWRnZU9mZnNldCA6IERlZmF1bHQuZWRnZU9mZnNldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgZHJhd2VyIGlkP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kcmF3ZXItdG9nZ2xlXScpLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIGRyYXdlcklkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLXRvZ2dsZScpO1xuICAgICAgICB2YXIgJGRyYXdlckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJhd2VySWQpO1xuICAgICAgICBpZiAoJGRyYXdlckVsKSB7XG4gICAgICAgICAgICB2YXIgZHJhd2VyXzEgPSBpbnN0YW5jZXMuZ2V0SW5zdGFuY2UoJ0RyYXdlcicsIGRyYXdlcklkKTtcbiAgICAgICAgICAgIGlmIChkcmF3ZXJfMSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2dnbGVEcmF3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdlcl8xLnRvZ2dsZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRvZ2dsZURyYXdlcik7XG4gICAgICAgICAgICAgICAgZHJhd2VyXzEuYWRkRXZlbnRMaXN0ZW5lckluc3RhbmNlKCR0cmlnZ2VyRWwsICdjbGljaycsIHRvZ2dsZURyYXdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRHJhd2VyIHdpdGggaWQgXCIuY29uY2F0KGRyYXdlcklkLCBcIiBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIFBsZWFzZSBpbml0aWFsaXplIGl0IHVzaW5nIHRoZSBkYXRhLWRyYXdlci10YXJnZXQgYXR0cmlidXRlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRHJhd2VyIHdpdGggaWQgXCIuY29uY2F0KGRyYXdlcklkLCBcIiBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSB0aGF0IHRoZSBkYXRhLWRyYXdlci10YXJnZXQgYXR0cmlidXRlIHBvaW50cyB0byB0aGUgY29ycmVjdCBkcmF3ZXIgaWQ/XCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50XG4gICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1kcmF3ZXItZGlzbWlzc10sIFtkYXRhLWRyYXdlci1oaWRlXScpXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBkcmF3ZXJJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRyYXdlci1kaXNtaXNzJylcbiAgICAgICAgICAgID8gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLWRpc21pc3MnKVxuICAgICAgICAgICAgOiAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kcmF3ZXItaGlkZScpO1xuICAgICAgICB2YXIgJGRyYXdlckVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJhd2VySWQpO1xuICAgICAgICBpZiAoJGRyYXdlckVsKSB7XG4gICAgICAgICAgICB2YXIgZHJhd2VyXzIgPSBpbnN0YW5jZXMuZ2V0SW5zdGFuY2UoJ0RyYXdlcicsIGRyYXdlcklkKTtcbiAgICAgICAgICAgIGlmIChkcmF3ZXJfMikge1xuICAgICAgICAgICAgICAgIHZhciBoaWRlRHJhd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3ZXJfMi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAkdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGlkZURyYXdlcik7XG4gICAgICAgICAgICAgICAgZHJhd2VyXzIuYWRkRXZlbnRMaXN0ZW5lckluc3RhbmNlKCR0cmlnZ2VyRWwsICdjbGljaycsIGhpZGVEcmF3ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLiBQbGVhc2UgaW5pdGlhbGl6ZSBpdCB1c2luZyB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRyYXdlciB3aXRoIGlkIFwiLmNvbmNhdChkcmF3ZXJJZCwgXCIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kcmF3ZXItdGFyZ2V0IGF0dHJpYnV0ZSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgZHJhd2VyIGlkXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRyYXdlci1zaG93XScpLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgdmFyIGRyYXdlcklkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhd2VyLXNob3cnKTtcbiAgICAgICAgdmFyICRkcmF3ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyYXdlcklkKTtcbiAgICAgICAgaWYgKCRkcmF3ZXJFbCkge1xuICAgICAgICAgICAgdmFyIGRyYXdlcl8zID0gaW5zdGFuY2VzLmdldEluc3RhbmNlKCdEcmF3ZXInLCBkcmF3ZXJJZCk7XG4gICAgICAgICAgICBpZiAoZHJhd2VyXzMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hvd0RyYXdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyXzMuc2hvdygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgJHRyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNob3dEcmF3ZXIpO1xuICAgICAgICAgICAgICAgIGRyYXdlcl8zLmFkZEV2ZW50TGlzdGVuZXJJbnN0YW5jZSgkdHJpZ2dlckVsLCAnY2xpY2snLCBzaG93RHJhd2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGluaXRpYWxpemUgaXQgdXNpbmcgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEcmF3ZXIgd2l0aCBpZCBcIi5jb25jYXQoZHJhd2VySWQsIFwiIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtZHJhd2VyLXRhcmdldCBhdHRyaWJ1dGUgcG9pbnRzIHRvIHRoZSBjb3JyZWN0IGRyYXdlciBpZD9cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuRHJhd2VyID0gRHJhd2VyO1xuICAgIHdpbmRvdy5pbml0RHJhd2VycyA9IGluaXREcmF3ZXJzO1xufVxuZXhwb3J0IGRlZmF1bHQgRHJhd2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmltcG9ydCBpbnN0YW5jZXMgZnJvbSAnLi4vLi4vZG9tL2luc3RhbmNlcyc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBkZWZhdWx0VGFiSWQ6IG51bGwsXG4gICAgYWN0aXZlQ2xhc3NlczogJ3RleHQtYmx1ZS02MDAgaG92ZXI6dGV4dC1ibHVlLTYwMCBkYXJrOnRleHQtYmx1ZS01MDAgZGFyazpob3Zlcjp0ZXh0LWJsdWUtNTAwIGJvcmRlci1ibHVlLTYwMCBkYXJrOmJvcmRlci1ibHVlLTUwMCcsXG4gICAgaW5hY3RpdmVDbGFzc2VzOiAnZGFyazpib3JkZXItdHJhbnNwYXJlbnQgdGV4dC1ncmF5LTUwMCBob3Zlcjp0ZXh0LWdyYXktNjAwIGRhcms6dGV4dC1ncmF5LTQwMCBib3JkZXItZ3JheS0xMDAgaG92ZXI6Ym9yZGVyLWdyYXktMzAwIGRhcms6Ym9yZGVyLWdyYXktNzAwIGRhcms6aG92ZXI6dGV4dC1ncmF5LTMwMCcsXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERlZmF1bHRJbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgb3ZlcnJpZGU6IHRydWUsXG59O1xudmFyIFRhYnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFicyh0YWJzRWwsIGl0ZW1zLCBvcHRpb25zLCBpbnN0YW5jZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhYnNFbCA9PT0gdm9pZCAwKSB7IHRhYnNFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSBbXTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIGlmIChpbnN0YW5jZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW5jZU9wdGlvbnMgPSBEZWZhdWx0SW5zdGFuY2VPcHRpb25zOyB9XG4gICAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBpbnN0YW5jZU9wdGlvbnMuaWQgPyBpbnN0YW5jZU9wdGlvbnMuaWQgOiB0YWJzRWwuaWQ7XG4gICAgICAgIHRoaXMuX3RhYnNFbCA9IHRhYnNFbDtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFiID0gb3B0aW9ucyA/IHRoaXMuZ2V0VGFiKG9wdGlvbnMuZGVmYXVsdFRhYklkKSA6IG51bGw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaW5zdGFuY2VzLmFkZEluc3RhbmNlKCdUYWJzJywgdGhpcywgdGhpcy5faW5zdGFuY2VJZCwgaW5zdGFuY2VPcHRpb25zLm92ZXJyaWRlKTtcbiAgICB9XG4gICAgVGFicy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCAmJiAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCB0aGUgZmlyc3QgdGFiIGFzIGFjdGl2ZSBpZiBub3Qgc2V0IGJ5IGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVUYWIodGhpcy5faXRlbXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yY2Ugc2hvdyB0aGUgZmlyc3QgZGVmYXVsdCB0YWJcbiAgICAgICAgICAgIHRoaXMuc2hvdyh0aGlzLl9hY3RpdmVUYWIuaWQsIHRydWUpO1xuICAgICAgICAgICAgLy8gc2hvdyB0YWIgY29udGVudCBiYXNlZCBvbiBjbGlja1xuICAgICAgICAgICAgdGhpcy5faXRlbXMubWFwKGZ1bmN0aW9uICh0YWIpIHtcbiAgICAgICAgICAgICAgICB0YWIudHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3codGFiLmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhYnMucHJvdG90eXBlLnJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaW5zdGFuY2VzLnJlbW92ZUluc3RhbmNlKCdUYWJzJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5kZXN0cm95QW5kUmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5nZXRBY3RpdmVUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVUYWI7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5zZXRBY3RpdmVUYWIgPSBmdW5jdGlvbiAodGFiKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRhYiA9IHRhYjtcbiAgICB9O1xuICAgIFRhYnMucHJvdG90eXBlLmdldFRhYiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmlkID09PSBpZDsgfSlbMF07XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKGlkLCBmb3JjZVNob3cpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGZvcmNlU2hvdyA9PT0gdm9pZCAwKSB7IGZvcmNlU2hvdyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0YWIgPSB0aGlzLmdldFRhYihpZCk7XG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nIGlmIGFscmVhZHkgYWN0aXZlXG4gICAgICAgIGlmICh0YWIgPT09IHRoaXMuX2FjdGl2ZVRhYiAmJiAhZm9yY2VTaG93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGlkZSBvdGhlciB0YWJzXG4gICAgICAgIHRoaXMuX2l0ZW1zLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0ICE9PSB0YWIpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0LnRyaWdnZXJFbC5jbGFzc0xpc3QpLnJlbW92ZS5hcHBseShfYSwgX3RoaXMuX29wdGlvbnMuYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgICAgICAoX2IgPSB0LnRyaWdnZXJFbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYiwgX3RoaXMuX29wdGlvbnMuaW5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgICAgIHQudGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgdC50cmlnZ2VyRWwuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzaG93IGFjdGl2ZSB0YWJcbiAgICAgICAgKF9hID0gdGFiLnRyaWdnZXJFbC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgdGhpcy5fb3B0aW9ucy5hY3RpdmVDbGFzc2VzLnNwbGl0KCcgJykpO1xuICAgICAgICAoX2IgPSB0YWIudHJpZ2dlckVsLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9iLCB0aGlzLl9vcHRpb25zLmluYWN0aXZlQ2xhc3Nlcy5zcGxpdCgnICcpKTtcbiAgICAgICAgdGFiLnRyaWdnZXJFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICB0YWIudGFyZ2V0RWwuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiKHRhYik7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMsIHRhYik7XG4gICAgfTtcbiAgICBUYWJzLnByb3RvdHlwZS51cGRhdGVPblNob3cgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3cgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIHJldHVybiBUYWJzO1xufSgpKTtcbmV4cG9ydCBmdW5jdGlvbiBpbml0VGFicygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10YWJzLXRvZ2dsZV0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkcGFyZW50RWwpIHtcbiAgICAgICAgdmFyIHRhYkl0ZW1zID0gW107XG4gICAgICAgIHZhciBhY3RpdmVDbGFzc2VzID0gJHBhcmVudEVsLmdldEF0dHJpYnV0ZSgnZGF0YS10YWJzLWFjdGl2ZS1jbGFzc2VzJyk7XG4gICAgICAgIHZhciBpbmFjdGl2ZUNsYXNzZXMgPSAkcGFyZW50RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYnMtaW5hY3RpdmUtY2xhc3NlcycpO1xuICAgICAgICB2YXIgZGVmYXVsdFRhYklkID0gbnVsbDtcbiAgICAgICAgJHBhcmVudEVsXG4gICAgICAgICAgICAucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKCR0cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJykgPT09ICd0cnVlJztcbiAgICAgICAgICAgIHZhciB0YWIgPSB7XG4gICAgICAgICAgICAgICAgaWQ6ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYnMtdGFyZ2V0JyksXG4gICAgICAgICAgICAgICAgdHJpZ2dlckVsOiAkdHJpZ2dlckVsLFxuICAgICAgICAgICAgICAgIHRhcmdldEVsOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYnMtdGFyZ2V0JykpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhYkl0ZW1zLnB1c2godGFiKTtcbiAgICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRUYWJJZCA9IHRhYi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ldyBUYWJzKCRwYXJlbnRFbCwgdGFiSXRlbXMsIHtcbiAgICAgICAgICAgIGRlZmF1bHRUYWJJZDogZGVmYXVsdFRhYklkLFxuICAgICAgICAgICAgYWN0aXZlQ2xhc3NlczogYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgID8gYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgIDogRGVmYXVsdC5hY3RpdmVDbGFzc2VzLFxuICAgICAgICAgICAgaW5hY3RpdmVDbGFzc2VzOiBpbmFjdGl2ZUNsYXNzZXNcbiAgICAgICAgICAgICAgICA/IGluYWN0aXZlQ2xhc3Nlc1xuICAgICAgICAgICAgICAgIDogRGVmYXVsdC5pbmFjdGl2ZUNsYXNzZXMsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LlRhYnMgPSBUYWJzO1xuICAgIHdpbmRvdy5pbml0VGFicyA9IGluaXRUYWJzO1xufVxuZXhwb3J0IGRlZmF1bHQgVGFicztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbmltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCBpbnN0YW5jZXMgZnJvbSAnLi4vLi4vZG9tL2luc3RhbmNlcyc7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHRyaWdnZXJUeXBlOiAnaG92ZXInLFxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERlZmF1bHRJbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgb3ZlcnJpZGU6IHRydWUsXG59O1xudmFyIFRvb2x0aXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9vbHRpcCh0YXJnZXRFbCwgdHJpZ2dlckVsLCBvcHRpb25zLCBpbnN0YW5jZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRhcmdldEVsID09PSB2b2lkIDApIHsgdGFyZ2V0RWwgPSBudWxsOyB9XG4gICAgICAgIGlmICh0cmlnZ2VyRWwgPT09IHZvaWQgMCkgeyB0cmlnZ2VyRWwgPSBudWxsOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IERlZmF1bHQ7IH1cbiAgICAgICAgaWYgKGluc3RhbmNlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGluc3RhbmNlT3B0aW9ucyA9IERlZmF1bHRJbnN0YW5jZU9wdGlvbnM7IH1cbiAgICAgICAgdGhpcy5faW5zdGFuY2VJZCA9IGluc3RhbmNlT3B0aW9ucy5pZFxuICAgICAgICAgICAgPyBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgIDogdGFyZ2V0RWwuaWQ7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsID0gdGFyZ2V0RWw7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJFbCA9IHRyaWdnZXJFbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBEZWZhdWx0KSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaW5zdGFuY2VzLmFkZEluc3RhbmNlKCdUb29sdGlwJywgdGhpcywgdGhpcy5faW5zdGFuY2VJZCwgaW5zdGFuY2VPcHRpb25zLm92ZXJyaWRlKTtcbiAgICB9XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCAmJiB0aGlzLl90YXJnZXRFbCAmJiAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlID0gdGhpcy5fY3JlYXRlUG9wcGVySW5zdGFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJpZ2dlciBlbGVtZW50XG4gICAgICAgICAgICB2YXIgdHJpZ2dlckV2ZW50cyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudHMoKTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX3Nob3dIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5faGlkZUhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBrZXlkb3duXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVLZXlkb3duTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGNsaWNrIG91dHNpZGVcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsaWNrT3V0c2lkZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAvLyBkZXN0cm95IHRoZSBQb3BwZXIgaW5zdGFuY2UgaWYgeW91IGhhdmUgb25lIChhc3N1bWluZyB0aGlzLl9wb3BwZXJJbnN0YW5jZSBpcyB0aGUgUG9wcGVyIGluc3RhbmNlKVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BvcHBlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUucmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlcy5yZW1vdmVJbnN0YW5jZSgnVG9vbHRpcCcsIHRoaXMuX2luc3RhbmNlSWQpO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbnN0YW5jZSgpO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX3NldHVwRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0cmlnZ2VyRXZlbnRzID0gdGhpcy5fZ2V0VHJpZ2dlckV2ZW50cygpO1xuICAgICAgICB0aGlzLl9zaG93SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGlkZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5fc2hvd0hhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJpZ2dlckV2ZW50cy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5fdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIF90aGlzLl9oaWRlSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX2NyZWF0ZVBvcHBlckluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9wcGVyKHRoaXMuX3RyaWdnZXJFbCwgdGhpcy5fdGFyZ2V0RWwsIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IFswLCA4XSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5fZ2V0VHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLnRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdob3Zlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbJ2NsaWNrJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnZm9jdXNvdXQnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaG93RXZlbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgaGlkZUV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydtb3VzZWVudGVyJywgJ2ZvY3VzJ10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFsnbW91c2VsZWF2ZScsICdibHVyJ10sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX3NldHVwS2V5ZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9yZW1vdmVLZXlkb3duTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleWRvd25FdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9zZXR1cENsaWNrT3V0c2lkZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlQ2xpY2tPdXRzaWRlKGV2LCBfdGhpcy5fdGFyZ2V0RWwpO1xuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5fcmVtb3ZlQ2xpY2tPdXRzaWRlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jbGlja091dHNpZGVFdmVudExpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9oYW5kbGVDbGlja091dHNpZGUgPSBmdW5jdGlvbiAoZXYsIHRhcmdldEVsKSB7XG4gICAgICAgIHZhciBjbGlja2VkRWwgPSBldi50YXJnZXQ7XG4gICAgICAgIGlmIChjbGlja2VkRWwgIT09IHRhcmdldEVsICYmXG4gICAgICAgICAgICAhdGFyZ2V0RWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJlxuICAgICAgICAgICAgIXRoaXMuX3RyaWdnZXJFbC5jb250YWlucyhjbGlja2VkRWwpICYmXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5yZW1vdmUoJ29wYWNpdHktMCcsICdpbnZpc2libGUnKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0RWwuY2xhc3NMaXN0LmFkZCgnb3BhY2l0eS0xMDAnLCAndmlzaWJsZScpO1xuICAgICAgICAvLyBFbmFibGUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS5zZXRPcHRpb25zKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1vZGlmaWVyczogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBvcHRpb25zLm1vZGlmaWVycywgdHJ1ZSksIFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdldmVudExpc3RlbmVycycsIGVuYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIF0sIGZhbHNlKSB9KSk7IH0pO1xuICAgICAgICAvLyBoYW5kbGUgY2xpY2sgb3V0c2lkZVxuICAgICAgICB0aGlzLl9zZXR1cENsaWNrT3V0c2lkZUxpc3RlbmVyKCk7XG4gICAgICAgIC8vIGhhbmRsZSBlc2Mga2V5ZG93blxuICAgICAgICB0aGlzLl9zZXR1cEtleWRvd25MaXN0ZW5lcigpO1xuICAgICAgICAvLyBVcGRhdGUgaXRzIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICAvLyBzZXQgdmlzaWJpbGl0eVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdvcGFjaXR5LTEwMCcsICd2aXNpYmxlJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ29wYWNpdHktMCcsICdpbnZpc2libGUnKTtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnNldE9wdGlvbnMoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgbW9kaWZpZXJzOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG9wdGlvbnMubW9kaWZpZXJzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIF0sIGZhbHNlKSB9KSk7IH0pO1xuICAgICAgICAvLyBoYW5kbGUgY2xpY2sgb3V0c2lkZVxuICAgICAgICB0aGlzLl9yZW1vdmVDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBoYW5kbGUgZXNjIGtleWRvd25cbiAgICAgICAgdGhpcy5fcmVtb3ZlS2V5ZG93bkxpc3RlbmVyKCk7XG4gICAgICAgIC8vIHNldCB2aXNpYmlsaXR5XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgfTtcbiAgICBUb29sdGlwLnByb3RvdHlwZS51cGRhdGVPblNob3cgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3cgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIFRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZU9uSGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgVG9vbHRpcC5wcm90b3R5cGUudXBkYXRlT25Ub2dnbGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIFRvb2x0aXA7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRUb29sdGlwcygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b29sdGlwLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciB0b29sdGlwSWQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXRhcmdldCcpO1xuICAgICAgICB2YXIgJHRvb2x0aXBFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRvb2x0aXBJZCk7XG4gICAgICAgIGlmICgkdG9vbHRpcEVsKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlclR5cGUgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXRyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgbmV3IFRvb2x0aXAoJHRvb2x0aXBFbCwgJHRyaWdnZXJFbCwge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50ID8gcGxhY2VtZW50IDogRGVmYXVsdC5wbGFjZW1lbnQsXG4gICAgICAgICAgICAgICAgdHJpZ2dlclR5cGU6IHRyaWdnZXJUeXBlXG4gICAgICAgICAgICAgICAgICAgID8gdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LnRyaWdnZXJUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHRvb2x0aXAgZWxlbWVudCB3aXRoIGlkIFxcXCJcIi5jb25jYXQodG9vbHRpcElkLCBcIlxcXCIgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBjaGVjayB0aGUgZGF0YS10b29sdGlwLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LlRvb2x0aXAgPSBUb29sdGlwO1xuICAgIHdpbmRvdy5pbml0VG9vbHRpcHMgPSBpbml0VG9vbHRpcHM7XG59XG5leHBvcnQgZGVmYXVsdCBUb29sdGlwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbiAqL1xuaW1wb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSAnQHBvcHBlcmpzL2NvcmUnO1xuaW1wb3J0IGluc3RhbmNlcyBmcm9tICcuLi8uLi9kb20vaW5zdGFuY2VzJztcbnZhciBEZWZhdWx0ID0ge1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgb2Zmc2V0OiAxMCxcbiAgICB0cmlnZ2VyVHlwZTogJ2hvdmVyJyxcbiAgICBvblNob3c6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvblRvZ2dsZTogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEZWZhdWx0SW5zdGFuY2VPcHRpb25zID0ge1xuICAgIGlkOiBudWxsLFxuICAgIG92ZXJyaWRlOiB0cnVlLFxufTtcbnZhciBQb3BvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvcG92ZXIodGFyZ2V0RWwsIHRyaWdnZXJFbCwgb3B0aW9ucywgaW5zdGFuY2VPcHRpb25zKSB7XG4gICAgICAgIGlmICh0YXJnZXRFbCA9PT0gdm9pZCAwKSB7IHRhcmdldEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodHJpZ2dlckVsID09PSB2b2lkIDApIHsgdHJpZ2dlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIGlmIChpbnN0YW5jZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW5jZU9wdGlvbnMgPSBEZWZhdWx0SW5zdGFuY2VPcHRpb25zOyB9XG4gICAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgID8gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA6IHRhcmdldEVsLmlkO1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl90cmlnZ2VyRWwgPSB0cmlnZ2VyRWw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgRGVmYXVsdCksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGluc3RhbmNlcy5hZGRJbnN0YW5jZSgnUG9wb3ZlcicsIHRoaXMsIGluc3RhbmNlT3B0aW9ucy5pZCA/IGluc3RhbmNlT3B0aW9ucy5pZCA6IHRoaXMuX3RhcmdldEVsLmlkLCBpbnN0YW5jZU9wdGlvbnMub3ZlcnJpZGUpO1xuICAgIH1cbiAgICBQb3BvdmVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsICYmIHRoaXMuX3RhcmdldEVsICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UgPSB0aGlzLl9jcmVhdGVQb3BwZXJJbnN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0cmlnZ2VyIGVsZW1lbnQgYW5kIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgICB2YXIgdHJpZ2dlckV2ZW50cyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudHMoKTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX3Nob3dIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX3Nob3dIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5faGlkZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5faGlkZUhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciBrZXlkb3duXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVLZXlkb3duTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGNsaWNrIG91dHNpZGVcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsaWNrT3V0c2lkZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICAvLyBkZXN0cm95IHRoZSBQb3BwZXIgaW5zdGFuY2UgaWYgeW91IGhhdmUgb25lIChhc3N1bWluZyB0aGlzLl9wb3BwZXJJbnN0YW5jZSBpcyB0aGUgUG9wcGVyIGluc3RhbmNlKVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BvcHBlckluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUucmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlcy5yZW1vdmVJbnN0YW5jZSgnUG9wb3ZlcicsIHRoaXMuX2luc3RhbmNlSWQpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbnN0YW5jZSgpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX3NldHVwRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0cmlnZ2VyRXZlbnRzID0gdGhpcy5fZ2V0VHJpZ2dlckV2ZW50cygpO1xuICAgICAgICB0aGlzLl9zaG93SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faGlkZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl90YXJnZXRFbC5tYXRjaGVzKCc6aG92ZXInKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJpZ2dlckV2ZW50cy5zaG93RXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBfdGhpcy5fdHJpZ2dlckVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIF90aGlzLl9zaG93SGFuZGxlcik7XG4gICAgICAgICAgICBfdGhpcy5fdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX3Nob3dIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyaWdnZXJFdmVudHMuaGlkZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5faGlkZUhhbmRsZXIpO1xuICAgICAgICAgICAgX3RoaXMuX3RhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIF90aGlzLl9oaWRlSGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2NyZWF0ZVBvcHBlckluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUG9wcGVyKHRoaXMuX3RyaWdnZXJFbCwgdGhpcy5fdGFyZ2V0RWwsIHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IFswLCB0aGlzLl9vcHRpb25zLm9mZnNldF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX2dldFRyaWdnZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy50cmlnZ2VyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnbW91c2VlbnRlcicsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ21vdXNlbGVhdmUnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydjbGljaycsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ2ZvY3Vzb3V0JywgJ2JsdXInXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnbW91c2VlbnRlcicsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ21vdXNlbGVhdmUnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLl9zZXR1cEtleWRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fa2V5ZG93bkV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fcmVtb3ZlS2V5ZG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUNsaWNrT3V0c2lkZShldiwgX3RoaXMuX3RhcmdldEVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrT3V0c2lkZUV2ZW50TGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuX3JlbW92ZUNsaWNrT3V0c2lkZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2xpY2tPdXRzaWRlRXZlbnRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5faGFuZGxlQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gKGV2LCB0YXJnZXRFbCkge1xuICAgICAgICB2YXIgY2xpY2tlZEVsID0gZXYudGFyZ2V0O1xuICAgICAgICBpZiAoY2xpY2tlZEVsICE9PSB0YXJnZXRFbCAmJlxuICAgICAgICAgICAgIXRhcmdldEVsLmNvbnRhaW5zKGNsaWNrZWRFbCkgJiZcbiAgICAgICAgICAgICF0aGlzLl90cmlnZ2VyRWwuY29udGFpbnMoY2xpY2tlZEVsKSAmJlxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Ub2dnbGUodGhpcyk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdvcGFjaXR5LTAnLCAnaW52aXNpYmxlJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ29wYWNpdHktMTAwJywgJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fcG9wcGVySW5zdGFuY2Uuc2V0T3B0aW9ucyhmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBtb2RpZmllcnM6IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgb3B0aW9ucy5tb2RpZmllcnMsIHRydWUpLCBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLCBlbmFibGVkOiB0cnVlIH0sXG4gICAgICAgICAgICBdLCBmYWxzZSkgfSkpOyB9KTtcbiAgICAgICAgLy8gaGFuZGxlIGNsaWNrIG91dHNpZGVcbiAgICAgICAgdGhpcy5fc2V0dXBDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBoYW5kbGUgZXNjIGtleWRvd25cbiAgICAgICAgdGhpcy5fc2V0dXBLZXlkb3duTGlzdGVuZXIoKTtcbiAgICAgICAgLy8gVXBkYXRlIGl0cyBwb3NpdGlvblxuICAgICAgICB0aGlzLl9wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgLy8gc2V0IHZpc2liaWxpdHkgdG8gdHJ1ZVxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdvcGFjaXR5LTEwMCcsICd2aXNpYmxlJyk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLmNsYXNzTGlzdC5hZGQoJ29wYWNpdHktMCcsICdpbnZpc2libGUnKTtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX3BvcHBlckluc3RhbmNlLnNldE9wdGlvbnMoZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgbW9kaWZpZXJzOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG9wdGlvbnMubW9kaWZpZXJzLCB0cnVlKSwgW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJywgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIF0sIGZhbHNlKSB9KSk7IH0pO1xuICAgICAgICAvLyBoYW5kbGUgY2xpY2sgb3V0c2lkZVxuICAgICAgICB0aGlzLl9yZW1vdmVDbGlja091dHNpZGVMaXN0ZW5lcigpO1xuICAgICAgICAvLyBoYW5kbGUgZXNjIGtleWRvd25cbiAgICAgICAgdGhpcy5fcmVtb3ZlS2V5ZG93bkxpc3RlbmVyKCk7XG4gICAgICAgIC8vIHNldCB2aXNpYmlsaXR5IHRvIGZhbHNlXG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgfTtcbiAgICBQb3BvdmVyLnByb3RvdHlwZS51cGRhdGVPblNob3cgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3cgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLnVwZGF0ZU9uSGlkZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUudXBkYXRlT25Ub2dnbGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblRvZ2dsZSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcG92ZXI7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRQb3BvdmVycygpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1wb3BvdmVyLXRhcmdldF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciBwb3BvdmVySUQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3BvdmVyLXRhcmdldCcpO1xuICAgICAgICB2YXIgJHBvcG92ZXJFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvcG92ZXJJRCk7XG4gICAgICAgIGlmICgkcG9wb3ZlckVsKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlclR5cGUgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3BvdmVyLXRyaWdnZXInKTtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wb3BvdmVyLXBsYWNlbWVudCcpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXBvcG92ZXItb2Zmc2V0Jyk7XG4gICAgICAgICAgICBuZXcgUG9wb3ZlcigkcG9wb3ZlckVsLCAkdHJpZ2dlckVsLCB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQgPyBwbGFjZW1lbnQgOiBEZWZhdWx0LnBsYWNlbWVudCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCA/IHBhcnNlSW50KG9mZnNldCkgOiBEZWZhdWx0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyVHlwZTogdHJpZ2dlclR5cGVcbiAgICAgICAgICAgICAgICAgICAgPyB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHQudHJpZ2dlclR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgcG9wb3ZlciBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChwb3BvdmVySUQsIFwiXFxcIiBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRhLXBvcG92ZXItdGFyZ2V0IGF0dHJpYnV0ZS5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuUG9wb3ZlciA9IFBvcG92ZXI7XG4gICAgd2luZG93LmluaXRQb3BvdmVycyA9IGluaXRQb3BvdmVycztcbn1cbmV4cG9ydCBkZWZhdWx0IFBvcG92ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0IGluc3RhbmNlcyBmcm9tICcuLi8uLi9kb20vaW5zdGFuY2VzJztcbnZhciBEZWZhdWx0ID0ge1xuICAgIHRyaWdnZXJUeXBlOiAnaG92ZXInLFxuICAgIG9uU2hvdzogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIG9uVG9nZ2xlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERlZmF1bHRJbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgb3ZlcnJpZGU6IHRydWUsXG59O1xudmFyIERpYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlhbChwYXJlbnRFbCwgdHJpZ2dlckVsLCB0YXJnZXRFbCwgb3B0aW9ucywgaW5zdGFuY2VPcHRpb25zKSB7XG4gICAgICAgIGlmIChwYXJlbnRFbCA9PT0gdm9pZCAwKSB7IHBhcmVudEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodHJpZ2dlckVsID09PSB2b2lkIDApIHsgdHJpZ2dlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICBpZiAoaW5zdGFuY2VPcHRpb25zID09PSB2b2lkIDApIHsgaW5zdGFuY2VPcHRpb25zID0gRGVmYXVsdEluc3RhbmNlT3B0aW9uczsgfVxuICAgICAgICB0aGlzLl9pbnN0YW5jZUlkID0gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA/IGluc3RhbmNlT3B0aW9ucy5pZFxuICAgICAgICAgICAgOiB0YXJnZXRFbC5pZDtcbiAgICAgICAgdGhpcy5fcGFyZW50RWwgPSBwYXJlbnRFbDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gdHJpZ2dlckVsO1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaW5zdGFuY2VzLmFkZEluc3RhbmNlKCdEaWFsJywgdGhpcywgdGhpcy5faW5zdGFuY2VJZCwgaW5zdGFuY2VPcHRpb25zLm92ZXJyaWRlKTtcbiAgICB9XG4gICAgRGlhbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCAmJiB0aGlzLl90YXJnZXRFbCAmJiAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyRXZlbnRUeXBlcyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudFR5cGVzKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUpO1xuICAgICAgICAgICAgdGhpcy5fc2hvd0V2ZW50SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50VHlwZXMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX3Nob3dFdmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5fc2hvd0V2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcGFyZW50RWwubWF0Y2hlcygnOmhvdmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRUeXBlcy5oaWRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3BhcmVudEVsLmFkZEV2ZW50TGlzdGVuZXIoZXYsIF90aGlzLl9oaWRlRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyRXZlbnRUeXBlcyA9IHRoaXMuX2dldFRyaWdnZXJFdmVudFR5cGVzKHRoaXMuX29wdGlvbnMudHJpZ2dlclR5cGUpO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50VHlwZXMuc2hvd0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX3Nob3dFdmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLl90YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBfdGhpcy5fc2hvd0V2ZW50SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudFR5cGVzLmhpZGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcGFyZW50RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgX3RoaXMuX2hpZGVFdmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5yZW1vdmVJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2VzLnJlbW92ZUluc3RhbmNlKCdEaWFsJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5kZXN0cm95QW5kUmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUodGhpcyk7XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckVsLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93KHRoaXMpO1xuICAgIH07XG4gICAgRGlhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlhbC5wcm90b3R5cGUuaXNIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fdmlzaWJsZTtcbiAgICB9O1xuICAgIERpYWwucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS5fZ2V0VHJpZ2dlckV2ZW50VHlwZXMgPSBmdW5jdGlvbiAodHJpZ2dlclR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0cmlnZ2VyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnbW91c2VlbnRlcicsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ21vdXNlbGVhdmUnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogWydjbGljaycsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ2ZvY3Vzb3V0JywgJ2JsdXInXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0V2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIGhpZGVFdmVudHM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFdmVudHM6IFsnbW91c2VlbnRlcicsICdmb2N1cyddLFxuICAgICAgICAgICAgICAgICAgICBoaWRlRXZlbnRzOiBbJ21vdXNlbGVhdmUnLCAnYmx1ciddLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpYWwucHJvdG90eXBlLnVwZGF0ZU9uU2hvdyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uU2hvdyA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgRGlhbC5wcm90b3R5cGUudXBkYXRlT25IaWRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25IaWRlID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBEaWFsLnByb3RvdHlwZS51cGRhdGVPblRvZ2dsZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uVG9nZ2xlID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gRGlhbDtcbn0oKSk7XG5leHBvcnQgZnVuY3Rpb24gaW5pdERpYWxzKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWRpYWwtaW5pdF0nKS5mb3JFYWNoKGZ1bmN0aW9uICgkcGFyZW50RWwpIHtcbiAgICAgICAgdmFyICR0cmlnZ2VyRWwgPSAkcGFyZW50RWwucXVlcnlTZWxlY3RvcignW2RhdGEtZGlhbC10b2dnbGVdJyk7XG4gICAgICAgIGlmICgkdHJpZ2dlckVsKSB7XG4gICAgICAgICAgICB2YXIgZGlhbElkID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlhbC10b2dnbGUnKTtcbiAgICAgICAgICAgIHZhciAkZGlhbEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGlhbElkKTtcbiAgICAgICAgICAgIGlmICgkZGlhbEVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJUeXBlID0gJHRyaWdnZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlhbC10cmlnZ2VyJyk7XG4gICAgICAgICAgICAgICAgbmV3IERpYWwoJHBhcmVudEVsLCAkdHJpZ2dlckVsLCAkZGlhbEVsLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJUeXBlOiB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmlnZ2VyVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LnRyaWdnZXJUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRpYWwgd2l0aCBpZCBcIi5jb25jYXQoZGlhbElkLCBcIiBkb2VzIG5vdCBleGlzdC4gQXJlIHlvdSBzdXJlIHRoYXQgdGhlIGRhdGEtZGlhbC10b2dnbGUgYXR0cmlidXRlIHBvaW50cyB0byB0aGUgY29ycmVjdCBtb2RhbCBpZD9cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRpYWwgd2l0aCBpZCBcIi5jb25jYXQoJHBhcmVudEVsLmlkLCBcIiBkb2VzIG5vdCBoYXZlIGEgdHJpZ2dlciBlbGVtZW50LiBBcmUgeW91IHN1cmUgdGhhdCB0aGUgZGF0YS1kaWFsLXRvZ2dsZSBhdHRyaWJ1dGUgZXhpc3RzP1wiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5EaWFsID0gRGlhbDtcbiAgICB3aW5kb3cuaW5pdERpYWxzID0gaW5pdERpYWxzO1xufVxuZXhwb3J0IGRlZmF1bHQgRGlhbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgaW5zdGFuY2VzIGZyb20gJy4uLy4uL2RvbS9pbnN0YW5jZXMnO1xudmFyIERlZmF1bHQgPSB7XG4gICAgbWluVmFsdWU6IG51bGwsXG4gICAgbWF4VmFsdWU6IG51bGwsXG4gICAgb25JbmNyZW1lbnQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBvbkRlY3JlbWVudDogZnVuY3Rpb24gKCkgeyB9LFxufTtcbnZhciBEZWZhdWx0SW5zdGFuY2VPcHRpb25zID0ge1xuICAgIGlkOiBudWxsLFxuICAgIG92ZXJyaWRlOiB0cnVlLFxufTtcbnZhciBJbnB1dENvdW50ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5wdXRDb3VudGVyKHRhcmdldEVsLCBpbmNyZW1lbnRFbCwgZGVjcmVtZW50RWwsIG9wdGlvbnMsIGluc3RhbmNlT3B0aW9ucykge1xuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKGluY3JlbWVudEVsID09PSB2b2lkIDApIHsgaW5jcmVtZW50RWwgPSBudWxsOyB9XG4gICAgICAgIGlmIChkZWNyZW1lbnRFbCA9PT0gdm9pZCAwKSB7IGRlY3JlbWVudEVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIGlmIChpbnN0YW5jZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW5jZU9wdGlvbnMgPSBEZWZhdWx0SW5zdGFuY2VPcHRpb25zOyB9XG4gICAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgID8gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA6IHRhcmdldEVsLmlkO1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl9pbmNyZW1lbnRFbCA9IGluY3JlbWVudEVsO1xuICAgICAgICB0aGlzLl9kZWNyZW1lbnRFbCA9IGRlY3JlbWVudEVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGluc3RhbmNlcy5hZGRJbnN0YW5jZSgnSW5wdXRDb3VudGVyJywgdGhpcywgdGhpcy5faW5zdGFuY2VJZCwgaW5zdGFuY2VPcHRpb25zLm92ZXJyaWRlKTtcbiAgICB9XG4gICAgSW5wdXRDb3VudGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0RWwgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljXG4gICAgICAgICAgICAgICAgICAgIGlmICghL15cXGQqJC8udGVzdCh0YXJnZXQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWdleCB0byBjaGVjayBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpY1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gdGFyZ2V0LnZhbHVlLnJlcGxhY2UoL1teXFxkXS9nLCAnJyk7IC8vIFJlbW92ZSBub24tbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIG1heCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29wdGlvbnMubWF4VmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHRhcmdldC52YWx1ZSkgPiBfdGhpcy5fb3B0aW9ucy5tYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gX3RoaXMuX29wdGlvbnMubWF4VmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgbWluIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fb3B0aW9ucy5taW5WYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQodGFyZ2V0LnZhbHVlKSA8IF90aGlzLl9vcHRpb25zLm1pblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBfdGhpcy5fb3B0aW9ucy5taW5WYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNyZW1lbnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9kZWNyZW1lbnRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVjcmVtZW50KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyIHRvIHJlc3RyaWN0IGlucHV0IHRvIG51bWVyaWMgdmFsdWVzIG9ubHlcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faW5wdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmNyZW1lbnRFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faW5jcmVtZW50Q2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWNyZW1lbnRFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY3JlbWVudEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fZGVjcmVtZW50Q2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5wdXRDb3VudGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0RWwgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faW5wdXRIYW5kbGVyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmNyZW1lbnRFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faW5jcmVtZW50Q2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWNyZW1lbnRFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY3JlbWVudEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fZGVjcmVtZW50Q2xpY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIElucHV0Q291bnRlci5wcm90b3R5cGUucmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlcy5yZW1vdmVJbnN0YW5jZSgnSW5wdXRDb3VudGVyJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBJbnB1dENvdW50ZXIucHJvdG90eXBlLmRlc3Ryb3lBbmRSZW1vdmVJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSW5zdGFuY2UoKTtcbiAgICB9O1xuICAgIElucHV0Q291bnRlci5wcm90b3R5cGUuZ2V0Q3VycmVudFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5fdGFyZ2V0RWwudmFsdWUpIHx8IDA7XG4gICAgfTtcbiAgICBJbnB1dENvdW50ZXIucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZG9uJ3QgaW5jcmVtZW50IGlmIHRoZSB2YWx1ZSBpcyBhbHJlYWR5IGF0IHRoZSBtYXhpbXVtIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLm1heFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmdldEN1cnJlbnRWYWx1ZSgpID49IHRoaXMuX29wdGlvbnMubWF4VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YXJnZXRFbC52YWx1ZSA9ICh0aGlzLmdldEN1cnJlbnRWYWx1ZSgpICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkluY3JlbWVudCh0aGlzKTtcbiAgICB9O1xuICAgIElucHV0Q291bnRlci5wcm90b3R5cGUuZGVjcmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBkb24ndCBkZWNyZW1lbnQgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgYXQgdGhlIG1pbmltdW0gdmFsdWVcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubWluVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3VycmVudFZhbHVlKCkgPD0gdGhpcy5fb3B0aW9ucy5taW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVsLnZhbHVlID0gKHRoaXMuZ2V0Q3VycmVudFZhbHVlKCkgLSAxKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uRGVjcmVtZW50KHRoaXMpO1xuICAgIH07XG4gICAgSW5wdXRDb3VudGVyLnByb3RvdHlwZS51cGRhdGVPbkluY3JlbWVudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSW5jcmVtZW50ID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBJbnB1dENvdW50ZXIucHJvdG90eXBlLnVwZGF0ZU9uRGVjcmVtZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25EZWNyZW1lbnQgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIHJldHVybiBJbnB1dENvdW50ZXI7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnB1dENvdW50ZXJzKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWlucHV0LWNvdW50ZXJdJykuZm9yRWFjaChmdW5jdGlvbiAoJHRhcmdldEVsKSB7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9ICR0YXJnZXRFbC5pZDtcbiAgICAgICAgdmFyICRpbmNyZW1lbnRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlucHV0LWNvdW50ZXItaW5jcmVtZW50PVwiJyArIHRhcmdldElkICsgJ1wiXScpO1xuICAgICAgICB2YXIgJGRlY3JlbWVudEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtaW5wdXQtY291bnRlci1kZWNyZW1lbnQ9XCInICsgdGFyZ2V0SWQgKyAnXCJdJyk7XG4gICAgICAgIHZhciBtaW5WYWx1ZSA9ICR0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5wdXQtY291bnRlci1taW4nKTtcbiAgICAgICAgdmFyIG1heFZhbHVlID0gJHRhcmdldEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1pbnB1dC1jb3VudGVyLW1heCcpO1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgZXhpc3RzXG4gICAgICAgIGlmICgkdGFyZ2V0RWwpIHtcbiAgICAgICAgICAgIGlmICghaW5zdGFuY2VzLmluc3RhbmNlRXhpc3RzKCdJbnB1dENvdW50ZXInLCAkdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdpZCcpKSkge1xuICAgICAgICAgICAgICAgIG5ldyBJbnB1dENvdW50ZXIoJHRhcmdldEVsLCAkaW5jcmVtZW50RWwgPyAkaW5jcmVtZW50RWwgOiBudWxsLCAkZGVjcmVtZW50RWwgPyAkZGVjcmVtZW50RWwgOiBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlOiBtaW5WYWx1ZSA/IHBhcnNlSW50KG1pblZhbHVlKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlOiBtYXhWYWx1ZSA/IHBhcnNlSW50KG1heFZhbHVlKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIHRhcmdldCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdCh0YXJnZXRJZCwgXCJcXFwiIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgY2hlY2sgdGhlIGRhdGEtaW5wdXQtY291bnRlciBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LklucHV0Q291bnRlciA9IElucHV0Q291bnRlcjtcbiAgICB3aW5kb3cuaW5pdElucHV0Q291bnRlcnMgPSBpbml0SW5wdXRDb3VudGVycztcbn1cbmV4cG9ydCBkZWZhdWx0IElucHV0Q291bnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5pbXBvcnQgaW5zdGFuY2VzIGZyb20gJy4uLy4uL2RvbS9pbnN0YW5jZXMnO1xudmFyIERlZmF1bHQgPSB7XG4gICAgaHRtbEVudGl0aWVzOiBmYWxzZSxcbiAgICBjb250ZW50VHlwZTogJ2lucHV0JyxcbiAgICBvbkNvcHk6IGZ1bmN0aW9uICgpIHsgfSxcbn07XG52YXIgRGVmYXVsdEluc3RhbmNlT3B0aW9ucyA9IHtcbiAgICBpZDogbnVsbCxcbiAgICBvdmVycmlkZTogdHJ1ZSxcbn07XG52YXIgQ29weUNsaXBib2FyZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb3B5Q2xpcGJvYXJkKHRyaWdnZXJFbCwgdGFyZ2V0RWwsIG9wdGlvbnMsIGluc3RhbmNlT3B0aW9ucykge1xuICAgICAgICBpZiAodHJpZ2dlckVsID09PSB2b2lkIDApIHsgdHJpZ2dlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAodGFyZ2V0RWwgPT09IHZvaWQgMCkgeyB0YXJnZXRFbCA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gRGVmYXVsdDsgfVxuICAgICAgICBpZiAoaW5zdGFuY2VPcHRpb25zID09PSB2b2lkIDApIHsgaW5zdGFuY2VPcHRpb25zID0gRGVmYXVsdEluc3RhbmNlT3B0aW9uczsgfVxuICAgICAgICB0aGlzLl9pbnN0YW5jZUlkID0gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA/IGluc3RhbmNlT3B0aW9ucy5pZFxuICAgICAgICAgICAgOiB0YXJnZXRFbC5pZDtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsID0gdHJpZ2dlckVsO1xuICAgICAgICB0aGlzLl90YXJnZXRFbCA9IHRhcmdldEVsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGluc3RhbmNlcy5hZGRJbnN0YW5jZSgnQ29weUNsaXBib2FyZCcsIHRoaXMsIHRoaXMuX2luc3RhbmNlSWQsIGluc3RhbmNlT3B0aW9ucy5vdmVycmlkZSk7XG4gICAgfVxuICAgIENvcHlDbGlwYm9hcmQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRFbCAmJiB0aGlzLl90cmlnZ2VyRWwgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWxDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29weSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNsaWNraW5nIG9uIHRoZSB0cmlnZ2VyIGVsZW1lbnQgc2hvdWxkIGNvcHkgdGhlIHZhbHVlIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX3RyaWdnZXJFbENsaWNrSGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvcHlDbGlwYm9hcmQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwgJiYgdGhpcy5fdGFyZ2V0RWwgJiYgdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl90cmlnZ2VyRWxDbGlja0hhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29weUNsaXBib2FyZC5wcm90b3R5cGUucmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlcy5yZW1vdmVJbnN0YW5jZSgnQ29weUNsaXBib2FyZCcsIHRoaXMuX2luc3RhbmNlSWQpO1xuICAgIH07XG4gICAgQ29weUNsaXBib2FyZC5wcm90b3R5cGUuZGVzdHJveUFuZFJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5yZW1vdmVJbnN0YW5jZSgpO1xuICAgIH07XG4gICAgQ29weUNsaXBib2FyZC5wcm90b3R5cGUuZ2V0VGFyZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNvbnRlbnRUeXBlID09PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWwudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuY29udGVudFR5cGUgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWwuaW5uZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNvbnRlbnRUeXBlID09PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWwudGV4dENvbnRlbnQucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29weUNsaXBib2FyZC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRleHRUb0NvcHkgPSB0aGlzLmdldFRhcmdldFZhbHVlKCk7XG4gICAgICAgIC8vIENoZWNrIGlmIEhUTUxFbnRpdGllcyBvcHRpb24gaXMgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5odG1sRW50aXRpZXMpIHtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgdGV4dCB1c2luZyBIVE1MIGVudGl0aWVzXG4gICAgICAgICAgICB0ZXh0VG9Db3B5ID0gdGhpcy5kZWNvZGVIVE1MKHRleHRUb0NvcHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSB0ZXh0YXJlYSBlbGVtZW50XG4gICAgICAgIHZhciB0ZW1wVGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB0ZW1wVGV4dEFyZWEudmFsdWUgPSB0ZXh0VG9Db3B5O1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBUZXh0QXJlYSk7XG4gICAgICAgIC8vIFNlbGVjdCB0aGUgdGV4dCBpbnNpZGUgdGhlIHRleHRhcmVhIGFuZCBjb3B5IGl0IHRvIHRoZSBjbGlwYm9hcmRcbiAgICAgICAgdGVtcFRleHRBcmVhLnNlbGVjdCgpO1xuICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHRlbXBvcmFyeSB0ZXh0YXJlYVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRlbXBUZXh0QXJlYSk7XG4gICAgICAgIC8vIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIHRoaXMuX29wdGlvbnMub25Db3B5KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGV4dFRvQ29weTtcbiAgICB9O1xuICAgIC8vIEZ1bmN0aW9uIHRvIGVuY29kZSB0ZXh0IGludG8gSFRNTCBlbnRpdGllc1xuICAgIENvcHlDbGlwYm9hcmQucHJvdG90eXBlLmRlY29kZUhUTUwgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICB2YXIgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB0ZXh0YXJlYS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXR1cm4gdGV4dGFyZWEudGV4dENvbnRlbnQ7XG4gICAgfTtcbiAgICBDb3B5Q2xpcGJvYXJkLnByb3RvdHlwZS51cGRhdGVPbkNvcHlDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uQ29weSA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgcmV0dXJuIENvcHlDbGlwYm9hcmQ7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRDb3B5Q2xpcGJvYXJkcygpIHtcbiAgICBkb2N1bWVudFxuICAgICAgICAucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtY29weS10by1jbGlwYm9hcmQtdGFyZ2V0XScpXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uICgkdHJpZ2dlckVsKSB7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNvcHktdG8tY2xpcGJvYXJkLXRhcmdldCcpO1xuICAgICAgICB2YXIgJHRhcmdldEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0SWQpO1xuICAgICAgICB2YXIgY29udGVudFR5cGUgPSAkdHJpZ2dlckVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3B5LXRvLWNsaXBib2FyZC1jb250ZW50LXR5cGUnKTtcbiAgICAgICAgdmFyIGh0bWxFbnRpdGllcyA9ICR0cmlnZ2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNvcHktdG8tY2xpcGJvYXJkLWh0bWwtZW50aXRpZXMnKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHRhcmdldCBlbGVtZW50IGV4aXN0c1xuICAgICAgICBpZiAoJHRhcmdldEVsKSB7XG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlcy5pbnN0YW5jZUV4aXN0cygnQ29weUNsaXBib2FyZCcsICR0YXJnZXRFbC5nZXRBdHRyaWJ1dGUoJ2lkJykpKSB7XG4gICAgICAgICAgICAgICAgbmV3IENvcHlDbGlwYm9hcmQoJHRyaWdnZXJFbCwgJHRhcmdldEVsLCB7XG4gICAgICAgICAgICAgICAgICAgIGh0bWxFbnRpdGllczogaHRtbEVudGl0aWVzICYmIGh0bWxFbnRpdGllcyA9PT0gJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogRGVmYXVsdC5odG1sRW50aXRpZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjb250ZW50VHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LmNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSB0YXJnZXQgZWxlbWVudCB3aXRoIGlkIFxcXCJcIi5jb25jYXQodGFyZ2V0SWQsIFwiXFxcIiBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRhLWNvcHktdG8tY2xpcGJvYXJkLXRhcmdldCBhdHRyaWJ1dGUuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LkNvcHlDbGlwYm9hcmQgPSBDb3B5Q2xpcGJvYXJkO1xuICAgIHdpbmRvdy5pbml0Q2xpcGJvYXJkcyA9IGluaXRDb3B5Q2xpcGJvYXJkcztcbn1cbmV4cG9ydCBkZWZhdWx0IENvcHlDbGlwYm9hcmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIHJldHVybiBfZ2V0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0LmJpbmQoKSA6IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgdmFyIHAgPSBfc3VwZXJQcm9wQmFzZShlLCB0KTtcbiAgICBpZiAocCkge1xuICAgICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIHQpO1xuICAgICAgcmV0dXJuIG4uZ2V0ID8gbi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IGUgOiByKSA6IG4udmFsdWU7XG4gICAgfVxuICB9LCBfZ2V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YodCwgZSkge1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fID0gZSwgdDtcbiAgfSwgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2UodCwgbykge1xuICBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSBfZ2V0UHJvdG90eXBlT2YodCkpOyk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuZnVuY3Rpb24gbGFzdEl0ZW1PZihhcnIpIHtcbiAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG59XG5cbi8vIHB1c2ggb25seSB0aGUgaXRlbXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheVxuZnVuY3Rpb24gcHVzaFVuaXF1ZShhcnIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBpdGVtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChhcnIuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXJyLnB1c2goaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHIsIHNlcGFyYXRvcikge1xuICAvLyBjb252ZXJ0IGVtcHR5IHN0cmluZyB0byBhbiBlbXB0eSBhcnJheVxuICByZXR1cm4gc3RyID8gc3RyLnNwbGl0KHNlcGFyYXRvcikgOiBbXTtcbn1cbmZ1bmN0aW9uIGlzSW5SYW5nZSh0ZXN0VmFsLCBtaW4sIG1heCkge1xuICB2YXIgbWluT0sgPSBtaW4gPT09IHVuZGVmaW5lZCB8fCB0ZXN0VmFsID49IG1pbjtcbiAgdmFyIG1heE9LID0gbWF4ID09PSB1bmRlZmluZWQgfHwgdGVzdFZhbCA8PSBtYXg7XG4gIHJldHVybiBtaW5PSyAmJiBtYXhPSztcbn1cbmZ1bmN0aW9uIGxpbWl0VG9SYW5nZSh2YWwsIG1pbiwgbWF4KSB7XG4gIGlmICh2YWwgPCBtaW4pIHtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGlmICh2YWwgPiBtYXgpIHtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWdSZXBlYXQodGFnTmFtZSwgcmVwZWF0KSB7XG4gIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICB2YXIgaHRtbCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJyc7XG4gIHZhciBvcGVuVGFnU3JjID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykucmVkdWNlKGZ1bmN0aW9uIChzcmMsIGF0dHIpIHtcbiAgICB2YXIgdmFsID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsID0gdmFsKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHNyYywgXCIgXCIpLmNvbmNhdChhdHRyLCBcIj1cXFwiXCIpLmNvbmNhdCh2YWwsIFwiXFxcIlwiKTtcbiAgfSwgdGFnTmFtZSk7XG4gIGh0bWwgKz0gXCI8XCIuY29uY2F0KG9wZW5UYWdTcmMsIFwiPjwvXCIpLmNvbmNhdCh0YWdOYW1lLCBcIj5cIik7XG4gIHZhciBuZXh0ID0gaW5kZXggKyAxO1xuICByZXR1cm4gbmV4dCA8IHJlcGVhdCA/IGNyZWF0ZVRhZ1JlcGVhdCh0YWdOYW1lLCByZXBlYXQsIGF0dHJpYnV0ZXMsIG5leHQsIGh0bWwpIDogaHRtbDtcbn1cblxuLy8gUmVtb3ZlIHRoZSBzcGFjaW5nIHN1cnJvdW5kaW5nIHRhZ3MgZm9yIEhUTUwgcGFyc2VyIG5vdCB0byBjcmVhdGUgdGV4dCBub2Rlc1xuLy8gYmVmb3JlL2FmdGVyIGVsZW1lbnRzXG5mdW5jdGlvbiBvcHRpbWl6ZVRlbXBsYXRlSFRNTChodG1sKSB7XG4gIHJldHVybiBodG1sLnJlcGxhY2UoLz5cXHMrL2csICc+JykucmVwbGFjZSgvXFxzKzwvLCAnPCcpO1xufVxuXG5mdW5jdGlvbiBzdHJpcFRpbWUodGltZVZhbHVlKSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lVmFsdWUpLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufVxuZnVuY3Rpb24gdG9kYXkoKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufVxuXG4vLyBHZXQgdGhlIHRpbWUgdmFsdWUgb2YgdGhlIHN0YXJ0IG9mIGdpdmVuIGRhdGUgb3IgeWVhciwgbW9udGggYW5kIGRheVxuZnVuY3Rpb24gZGF0ZVZhbHVlKCkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdG9kYXkoKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gc3RyaXBUaW1lKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gIH1cblxuICAvLyB1c2Ugc2V0RnVsbFllYXIoKSB0byBrZWVwIDItZGlnaXQgeWVhciBmcm9tIGJlaW5nIG1hcHBlZCB0byAxOTAwLTE5OTlcbiAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgbmV3RGF0ZS5zZXRGdWxsWWVhci5hcHBseShuZXdEYXRlLCBhcmd1bWVudHMpO1xuICByZXR1cm4gbmV3RGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn1cbmZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgYW1vdW50KSB7XG4gIHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIHJldHVybiBuZXdEYXRlLnNldERhdGUobmV3RGF0ZS5nZXREYXRlKCkgKyBhbW91bnQpO1xufVxuZnVuY3Rpb24gYWRkV2Vla3MoZGF0ZSwgYW1vdW50KSB7XG4gIHJldHVybiBhZGREYXlzKGRhdGUsIGFtb3VudCAqIDcpO1xufVxuZnVuY3Rpb24gYWRkTW9udGhzKGRhdGUsIGFtb3VudCkge1xuICAvLyBJZiB0aGUgZGF5IG9mIHRoZSBkYXRlIGlzIG5vdCBpbiB0aGUgbmV3IG1vbnRoLCB0aGUgbGFzdCBkYXkgb2YgdGhlIG5ld1xuICAvLyBtb250aCB3aWxsIGJlIHJldHVybmVkLiBlLmcuIEphbiAzMSArIDEgbW9udGgg4oaSIEZlYiAyOCAobm90IE1hciAwMylcbiAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgdmFyIG1vbnRoc1RvU2V0ID0gbmV3RGF0ZS5nZXRNb250aCgpICsgYW1vdW50O1xuICB2YXIgZXhwZWN0ZWRNb250aCA9IG1vbnRoc1RvU2V0ICUgMTI7XG4gIGlmIChleHBlY3RlZE1vbnRoIDwgMCkge1xuICAgIGV4cGVjdGVkTW9udGggKz0gMTI7XG4gIH1cbiAgdmFyIHRpbWUgPSBuZXdEYXRlLnNldE1vbnRoKG1vbnRoc1RvU2V0KTtcbiAgcmV0dXJuIG5ld0RhdGUuZ2V0TW9udGgoKSAhPT0gZXhwZWN0ZWRNb250aCA/IG5ld0RhdGUuc2V0RGF0ZSgwKSA6IHRpbWU7XG59XG5mdW5jdGlvbiBhZGRZZWFycyhkYXRlLCBhbW91bnQpIHtcbiAgLy8gSWYgdGhlIGRhdGUgaXMgRmViIDI5IGFuZCB0aGUgbmV3IHllYXIgaXMgbm90IGEgbGVhcCB5ZWFyLCBGZWIgMjggb2YgdGhlXG4gIC8vIG5ldyB5ZWFyIHdpbGwgYmUgcmV0dXJuZWQuXG4gIHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIHZhciBleHBlY3RlZE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xuICB2YXIgdGltZSA9IG5ld0RhdGUuc2V0RnVsbFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpICsgYW1vdW50KTtcbiAgcmV0dXJuIGV4cGVjdGVkTW9udGggPT09IDEgJiYgbmV3RGF0ZS5nZXRNb250aCgpID09PSAyID8gbmV3RGF0ZS5zZXREYXRlKDApIDogdGltZTtcbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR0d2VuIDIgZGF5cyBvZiB0aGUgd2Vla1xuZnVuY3Rpb24gZGF5RGlmZihkYXksIGZyb20pIHtcbiAgcmV0dXJuIChkYXkgLSBmcm9tICsgNykgJSA3O1xufVxuXG4vLyBHZXQgdGhlIGRhdGUgb2YgdGhlIHNwZWNpZmllZCBkYXkgb2YgdGhlIHdlZWsgb2YgZ2l2ZW4gYmFzZSBkYXRlXG5mdW5jdGlvbiBkYXlPZlRoZVdlZWtPZihiYXNlRGF0ZSwgZGF5T2ZXZWVrKSB7XG4gIHZhciB3ZWVrU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIHZhciBiYXNlRGF5ID0gbmV3IERhdGUoYmFzZURhdGUpLmdldERheSgpO1xuICByZXR1cm4gYWRkRGF5cyhiYXNlRGF0ZSwgZGF5RGlmZihkYXlPZldlZWssIHdlZWtTdGFydCkgLSBkYXlEaWZmKGJhc2VEYXksIHdlZWtTdGFydCkpO1xufVxuXG4vLyBHZXQgdGhlIElTTyB3ZWVrIG9mIGEgZGF0ZVxuZnVuY3Rpb24gZ2V0V2VlayhkYXRlKSB7XG4gIC8vIHN0YXJ0IG9mIElTTyB3ZWVrIGlzIE1vbmRheVxuICB2YXIgdGh1T2ZUaGVXZWVrID0gZGF5T2ZUaGVXZWVrT2YoZGF0ZSwgNCwgMSk7XG4gIC8vIDFzdCB3ZWVrID09IHRoZSB3ZWVrIHdoZXJlIHRoZSA0dGggb2YgSmFudWFyeSBpcyBpblxuICB2YXIgZmlyc3RUaHUgPSBkYXlPZlRoZVdlZWtPZihuZXcgRGF0ZSh0aHVPZlRoZVdlZWspLnNldE1vbnRoKDAsIDQpLCA0LCAxKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHRodU9mVGhlV2VlayAtIGZpcnN0VGh1KSAvIDYwNDgwMDAwMCkgKyAxO1xufVxuXG4vLyBHZXQgdGhlIHN0YXJ0IHllYXIgb2YgdGhlIHBlcmlvZCBvZiB5ZWFycyB0aGF0IGluY2x1ZGVzIGdpdmVuIGRhdGVcbi8vIHllYXJzOiBsZW5ndGggb2YgdGhlIHllYXIgcGVyaW9kXG5mdW5jdGlvbiBzdGFydE9mWWVhclBlcmlvZChkYXRlLCB5ZWFycykge1xuICAvKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1llYXJfemVybyNJU09fODYwMSAqL1xuICB2YXIgeWVhciA9IG5ldyBEYXRlKGRhdGUpLmdldEZ1bGxZZWFyKCk7XG4gIHJldHVybiBNYXRoLmZsb29yKHllYXIgLyB5ZWFycykgKiB5ZWFycztcbn1cblxuLy8gcGF0dGVybiBmb3IgZm9ybWF0IHBhcnRzXG52YXIgcmVGb3JtYXRUb2tlbnMgPSAvZGQ/fEREP3xtbT98TU0/fHl5Pyg/Onl5KT8vO1xuLy8gcGF0dGVybiBmb3Igbm9uIGRhdGUgcGFydHNcbnZhciByZU5vbkRhdGVQYXJ0cyA9IC9bXFxzIS0vOi1AWy1gey1+5bm05pyI5pelXSsvO1xuLy8gY2FjaGUgZm9yIHBlcnNlZCBmb3JtYXRzXG52YXIga25vd25Gb3JtYXRzID0ge307XG4vLyBwYXJzZSBmdW50aW9ucyBmb3IgZGF0ZSBwYXJ0c1xudmFyIHBhcnNlRm5zID0ge1xuICB5OiBmdW5jdGlvbiB5KGRhdGUsIHllYXIpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSkuc2V0RnVsbFllYXIocGFyc2VJbnQoeWVhciwgMTApKTtcbiAgfSxcbiAgbTogZnVuY3Rpb24gbShkYXRlLCBtb250aCwgbG9jYWxlKSB7XG4gICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICB2YXIgbW9udGhJbmRleCA9IHBhcnNlSW50KG1vbnRoLCAxMCkgLSAxO1xuICAgIGlmIChpc05hTihtb250aEluZGV4KSkge1xuICAgICAgaWYgKCFtb250aCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgdmFyIG1vbnRoTmFtZSA9IG1vbnRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgY29tcGFyZU5hbWVzID0gZnVuY3Rpb24gY29tcGFyZU5hbWVzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKG1vbnRoTmFtZSk7XG4gICAgICB9O1xuICAgICAgLy8gY29tcGFyZSB3aXRoIGJvdGggc2hvcnQgYW5kIGZ1bGwgbmFtZXMgYmVjYXVzZSBzb21lIGxvY2FsZXMgaGF2ZSBwZXJpb2RzXG4gICAgICAvLyBpbiB0aGUgc2hvcnQgbmFtZXMgKG5vdCBlcXVhbCB0byB0aGUgZmlyc3QgWCBsZXR0ZXJzIG9mIHRoZSBmdWxsIG5hbWVzKVxuICAgICAgbW9udGhJbmRleCA9IGxvY2FsZS5tb250aHNTaG9ydC5maW5kSW5kZXgoY29tcGFyZU5hbWVzKTtcbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xuICAgICAgICBtb250aEluZGV4ID0gbG9jYWxlLm1vbnRocy5maW5kSW5kZXgoY29tcGFyZU5hbWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb250aEluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgIH1cbiAgICBuZXdEYXRlLnNldE1vbnRoKG1vbnRoSW5kZXgpO1xuICAgIHJldHVybiBuZXdEYXRlLmdldE1vbnRoKCkgIT09IG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXgpID8gbmV3RGF0ZS5zZXREYXRlKDApIDogbmV3RGF0ZS5nZXRUaW1lKCk7XG4gIH0sXG4gIGQ6IGZ1bmN0aW9uIGQoZGF0ZSwgZGF5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpLnNldERhdGUocGFyc2VJbnQoZGF5LCAxMCkpO1xuICB9XG59O1xuLy8gZm9ybWF0IGZ1bmN0aW9ucyBmb3IgZGF0ZSBwYXJ0c1xudmFyIGZvcm1hdEZucyA9IHtcbiAgZDogZnVuY3Rpb24gZChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpO1xuICB9LFxuICBkZDogZnVuY3Rpb24gZGQoZGF0ZSkge1xuICAgIHJldHVybiBwYWRaZXJvKGRhdGUuZ2V0RGF0ZSgpLCAyKTtcbiAgfSxcbiAgRDogZnVuY3Rpb24gRChkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLmRheXNTaG9ydFtkYXRlLmdldERheSgpXTtcbiAgfSxcbiAgREQ6IGZ1bmN0aW9uIEREKGRhdGUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUuZGF5c1tkYXRlLmdldERheSgpXTtcbiAgfSxcbiAgbTogZnVuY3Rpb24gbShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gIH0sXG4gIG1tOiBmdW5jdGlvbiBtbShkYXRlKSB7XG4gICAgcmV0dXJuIHBhZFplcm8oZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gIH0sXG4gIE06IGZ1bmN0aW9uIE0oZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFtkYXRlLmdldE1vbnRoKCldO1xuICB9LFxuICBNTTogZnVuY3Rpb24gTU0oZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNbZGF0ZS5nZXRNb250aCgpXTtcbiAgfSxcbiAgeTogZnVuY3Rpb24geShkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfSxcbiAgeXk6IGZ1bmN0aW9uIHl5KGRhdGUpIHtcbiAgICByZXR1cm4gcGFkWmVybyhkYXRlLmdldEZ1bGxZZWFyKCksIDIpLnNsaWNlKC0yKTtcbiAgfSxcbiAgeXl5eTogZnVuY3Rpb24geXl5eShkYXRlKSB7XG4gICAgcmV0dXJuIHBhZFplcm8oZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTtcbiAgfVxufTtcblxuLy8gZ2V0IG1vbnRoIGluZGV4IGluIG5vcm1hbCByYW5nZSAoMCAtIDExKSBmcm9tIGFueSBudW1iZXJcbmZ1bmN0aW9uIG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXgpIHtcbiAgcmV0dXJuIG1vbnRoSW5kZXggPiAtMSA/IG1vbnRoSW5kZXggJSAxMiA6IG5vcm1hbGl6ZU1vbnRoKG1vbnRoSW5kZXggKyAxMik7XG59XG5mdW5jdGlvbiBwYWRaZXJvKG51bSwgbGVuZ3RoKSB7XG4gIHJldHVybiBudW0udG9TdHJpbmcoKS5wYWRTdGFydChsZW5ndGgsICcwJyk7XG59XG5mdW5jdGlvbiBwYXJzZUZvcm1hdFN0cmluZyhmb3JtYXQpIHtcbiAgaWYgKHR5cGVvZiBmb3JtYXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIGZvcm1hdC5cIik7XG4gIH1cbiAgaWYgKGZvcm1hdCBpbiBrbm93bkZvcm1hdHMpIHtcbiAgICByZXR1cm4ga25vd25Gb3JtYXRzW2Zvcm1hdF07XG4gIH1cblxuICAvLyBzcHJpdCB0aGUgZm9ybWF0IHN0cmluZyBpbnRvIHBhcnRzIGFuZCBzZXByYXRvcnNcbiAgdmFyIHNlcGFyYXRvcnMgPSBmb3JtYXQuc3BsaXQocmVGb3JtYXRUb2tlbnMpO1xuICB2YXIgcGFydHMgPSBmb3JtYXQubWF0Y2gobmV3IFJlZ0V4cChyZUZvcm1hdFRva2VucywgJ2cnKSk7XG4gIGlmIChzZXBhcmF0b3JzLmxlbmd0aCA9PT0gMCB8fCAhcGFydHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0LlwiKTtcbiAgfVxuXG4gIC8vIGNvbGxlY3QgZm9ybWF0IGZ1bmN0aW9ucyB1c2VkIGluIHRoZSBmb3JtYXRcbiAgdmFyIHBhcnRGb3JtYXR0ZXJzID0gcGFydHMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHJldHVybiBmb3JtYXRGbnNbdG9rZW5dO1xuICB9KTtcblxuICAvLyBjb2xsZWN0IHBhcnNlIGZ1bmN0aW9uIGtleXMgdXNlZCBpbiB0aGUgZm9ybWF0XG4gIC8vIGl0ZXJhdGUgb3ZlciBwYXJzZUZucycga2V5cyBpbiBvcmRlciB0byBrZWVwIHRoZSBvcmRlciBvZiB0aGUga2V5cy5cbiAgdmFyIHBhcnRQYXJzZXJLZXlzID0gT2JqZWN0LmtleXMocGFyc2VGbnMpLnJlZHVjZShmdW5jdGlvbiAoa2V5cywga2V5KSB7XG4gICAgdmFyIHRva2VuID0gcGFydHMuZmluZChmdW5jdGlvbiAocGFydCkge1xuICAgICAgcmV0dXJuIHBhcnRbMF0gIT09ICdEJyAmJiBwYXJ0WzBdLnRvTG93ZXJDYXNlKCkgPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbiAgfSwgW10pO1xuICByZXR1cm4ga25vd25Gb3JtYXRzW2Zvcm1hdF0gPSB7XG4gICAgcGFyc2VyOiBmdW5jdGlvbiBwYXJzZXIoZGF0ZVN0ciwgbG9jYWxlKSB7XG4gICAgICB2YXIgZGF0ZVBhcnRzID0gZGF0ZVN0ci5zcGxpdChyZU5vbkRhdGVQYXJ0cykucmVkdWNlKGZ1bmN0aW9uIChkdFBhcnRzLCBwYXJ0LCBpbmRleCkge1xuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwICYmIHBhcnRzW2luZGV4XSkge1xuICAgICAgICAgIHZhciB0b2tlbiA9IHBhcnRzW2luZGV4XVswXTtcbiAgICAgICAgICBpZiAodG9rZW4gPT09ICdNJykge1xuICAgICAgICAgICAgZHRQYXJ0cy5tID0gcGFydDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuICE9PSAnRCcpIHtcbiAgICAgICAgICAgIGR0UGFydHNbdG9rZW5dID0gcGFydDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR0UGFydHM7XG4gICAgICB9LCB7fSk7XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXJ0UGFyc2Vya2V5cyBzbyB0aGF0IHRoZSBwYXJzaW5nIGlzIG1hZGUgaW4gdGhlIG9kZXJcbiAgICAgIC8vIG9mIHllYXIsIG1vbnRoIGFuZCBkYXkgdG8gcHJldmVudCB0aGUgZGF5IHBhcnNlciBmcm9tIGNvcnJlY3RpbmcgbGFzdFxuICAgICAgLy8gZGF5IG9mIG1vbnRoIHdyb25nbHlcbiAgICAgIHJldHVybiBwYXJ0UGFyc2VyS2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG9yaWdEYXRlLCBrZXkpIHtcbiAgICAgICAgdmFyIG5ld0RhdGUgPSBwYXJzZUZuc1trZXldKG9yaWdEYXRlLCBkYXRlUGFydHNba2V5XSwgbG9jYWxlKTtcbiAgICAgICAgLy8gaW5nbm9yZSB0aGUgcGFydCBmYWlsZWQgdG8gcGFyc2VcbiAgICAgICAgcmV0dXJuIGlzTmFOKG5ld0RhdGUpID8gb3JpZ0RhdGUgOiBuZXdEYXRlO1xuICAgICAgfSwgdG9kYXkoKSk7XG4gICAgfSxcbiAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcihkYXRlLCBsb2NhbGUpIHtcbiAgICAgIHZhciBkYXRlU3RyID0gcGFydEZvcm1hdHRlcnMucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGZuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc3RyICs9IFwiXCIuY29uY2F0KHNlcGFyYXRvcnNbaW5kZXhdKS5jb25jYXQoZm4oZGF0ZSwgbG9jYWxlKSk7XG4gICAgICB9LCAnJyk7XG4gICAgICAvLyBzZXBhcmF0b3JzJyBsZW5ndGggaXMgYWx3YXlzIHBhcnRzJyBsZW5ndGggKyAxLFxuICAgICAgcmV0dXJuIGRhdGVTdHIgKz0gbGFzdEl0ZW1PZihzZXBhcmF0b3JzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0ciwgZm9ybWF0LCBsb2NhbGUpIHtcbiAgaWYgKGRhdGVTdHIgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBkYXRlU3RyID09PSAnbnVtYmVyJykge1xuICAgIHZhciBkYXRlID0gc3RyaXBUaW1lKGRhdGVTdHIpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IHVuZGVmaW5lZCA6IGRhdGU7XG4gIH1cbiAgaWYgKCFkYXRlU3RyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZGF0ZVN0ciA9PT0gJ3RvZGF5Jykge1xuICAgIHJldHVybiB0b2RheSgpO1xuICB9XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnRvVmFsdWUpIHtcbiAgICB2YXIgX2RhdGUgPSBmb3JtYXQudG9WYWx1ZShkYXRlU3RyLCBmb3JtYXQsIGxvY2FsZSk7XG4gICAgcmV0dXJuIGlzTmFOKF9kYXRlKSA/IHVuZGVmaW5lZCA6IHN0cmlwVGltZShfZGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlRm9ybWF0U3RyaW5nKGZvcm1hdCkucGFyc2VyKGRhdGVTdHIsIGxvY2FsZSk7XG59XG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgbG9jYWxlKSB7XG4gIGlmIChpc05hTihkYXRlKSB8fCAhZGF0ZSAmJiBkYXRlICE9PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBkYXRlT2JqID0gdHlwZW9mIGRhdGUgPT09ICdudW1iZXInID8gbmV3IERhdGUoZGF0ZSkgOiBkYXRlO1xuICBpZiAoZm9ybWF0LnRvRGlzcGxheSkge1xuICAgIHJldHVybiBmb3JtYXQudG9EaXNwbGF5KGRhdGVPYmosIGZvcm1hdCwgbG9jYWxlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0KS5mb3JtYXR0ZXIoZGF0ZU9iaiwgbG9jYWxlKTtcbn1cblxudmFyIGxpc3RlbmVyUmVnaXN0cnkgPSBuZXcgV2Vha01hcCgpO1xudmFyIF9FdmVudFRhcmdldCRwcm90b3R5cCA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZSxcbiAgYWRkRXZlbnRMaXN0ZW5lciA9IF9FdmVudFRhcmdldCRwcm90b3R5cC5hZGRFdmVudExpc3RlbmVyLFxuICByZW1vdmVFdmVudExpc3RlbmVyID0gX0V2ZW50VGFyZ2V0JHByb3RvdHlwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbi8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyB0byBhIGtleSBvYmplY3Rcbi8vIGxpc3RlbmVyczogYXJyYXkgb2YgbGlzdGVuZXIgZGVmaW5pdGlvbnM7XG4vLyAgIC0gZWFjaCBkZWZpbml0aW9uIG11c3QgYmUgYSBmbGF0IGFycmF5IG9mIGV2ZW50IHRhcmdldCBhbmQgdGhlIGFyZ3VtZW50c1xuLy8gICAgIHVzZWQgdG8gY2FsbCBhZGRFdmVudExpc3RlbmVyKCkgb24gdGhlIHRhcmdldFxuZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnMoa2V5T2JqLCBsaXN0ZW5lcnMpIHtcbiAgdmFyIHJlZ2lzdGVyZWQgPSBsaXN0ZW5lclJlZ2lzdHJ5LmdldChrZXlPYmopO1xuICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICByZWdpc3RlcmVkID0gW107XG4gICAgbGlzdGVuZXJSZWdpc3RyeS5zZXQoa2V5T2JqLCByZWdpc3RlcmVkKTtcbiAgfVxuICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICBhZGRFdmVudExpc3RlbmVyLmNhbGwuYXBwbHkoYWRkRXZlbnRMaXN0ZW5lciwgX3RvQ29uc3VtYWJsZUFycmF5KGxpc3RlbmVyKSk7XG4gICAgcmVnaXN0ZXJlZC5wdXNoKGxpc3RlbmVyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXJzKGtleU9iaikge1xuICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuZXJSZWdpc3RyeS5nZXQoa2V5T2JqKTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsLmFwcGx5KHJlbW92ZUV2ZW50TGlzdGVuZXIsIF90b0NvbnN1bWFibGVBcnJheShsaXN0ZW5lcikpO1xuICB9KTtcbiAgbGlzdGVuZXJSZWdpc3RyeVtcImRlbGV0ZVwiXShrZXlPYmopO1xufVxuXG4vLyBFdmVudC5jb21wb3NlZFBhdGgoKSBwb2x5ZmlsbCBmb3IgRWRnZVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20va2xlaW5mcmV1bmQvZTk3ODdkNzM3NzZjMGUzNzUwZGNmY2RjODlmMTAwZWNcbmlmICghRXZlbnQucHJvdG90eXBlLmNvbXBvc2VkUGF0aCkge1xuICB2YXIgZ2V0Q29tcG9zZWRQYXRoID0gZnVuY3Rpb24gZ2V0Q29tcG9zZWRQYXRoKG5vZGUpIHtcbiAgICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgIHZhciBwYXJlbnQ7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ob3N0KSB7XG4gICAgICAvLyBTaGFkb3dSb290XG4gICAgICBwYXJlbnQgPSBub2RlLmhvc3Q7XG4gICAgfSBlbHNlIGlmIChub2RlLmRlZmF1bHRWaWV3KSB7XG4gICAgICAvLyBEb2N1bWVudFxuICAgICAgcGFyZW50ID0gbm9kZS5kZWZhdWx0VmlldztcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudCA/IGdldENvbXBvc2VkUGF0aChwYXJlbnQsIHBhdGgpIDogcGF0aDtcbiAgfTtcbiAgRXZlbnQucHJvdG90eXBlLmNvbXBvc2VkUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0Q29tcG9zZWRQYXRoKHRoaXMudGFyZ2V0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRGcm9tUGF0aChwYXRoLCBjcml0ZXJpYSwgY3VycmVudFRhcmdldCkge1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gIHZhciBlbCA9IHBhdGhbaW5kZXhdO1xuICBpZiAoY3JpdGVyaWEoZWwpKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9IGVsc2UgaWYgKGVsID09PSBjdXJyZW50VGFyZ2V0IHx8ICFlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgLy8gc3RvcCB3aGVuIHJlYWNoaW5nIGN1cnJlbnRUYXJnZXQgb3IgPGh0bWw+XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBmaW5kRnJvbVBhdGgocGF0aCwgY3JpdGVyaWEsIGN1cnJlbnRUYXJnZXQsIGluZGV4ICsgMSk7XG59XG5cbi8vIFNlYXJjaCBmb3IgdGhlIGFjdHVhbCB0YXJnZXQgb2YgYSBkZWxlZ2F0ZWQgZXZlbnRcbmZ1bmN0aW9uIGZpbmRFbGVtZW50SW5FdmVudFBhdGgoZXYsIHNlbGVjdG9yKSB7XG4gIHZhciBjcml0ZXJpYSA9IHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IHNlbGVjdG9yIDogZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xuICByZXR1cm4gZmluZEZyb21QYXRoKGV2LmNvbXBvc2VkUGF0aCgpLCBjcml0ZXJpYSwgZXYuY3VycmVudFRhcmdldCk7XG59XG5cbi8vIGRlZmF1bHQgbG9jYWxlc1xudmFyIGxvY2FsZXMgPSB7XG4gIGVuOiB7XG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgZGF5c01pbjogW1wiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBtb250aHNTaG9ydDogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdLFxuICAgIHRvZGF5OiBcIlRvZGF5XCIsXG4gICAgY2xlYXI6IFwiQ2xlYXJcIixcbiAgICB0aXRsZUZvcm1hdDogXCJNTSB5XCJcbiAgfVxufTtcblxuLy8gY29uZmlnIG9wdGlvbnMgdXBkYXRhYmxlIGJ5IHNldE9wdGlvbnMoKSBhbmQgdGhlaXIgZGVmYXVsdCB2YWx1ZXNcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYXV0b2hpZGU6IGZhbHNlLFxuICBiZWZvcmVTaG93RGF5OiBudWxsLFxuICBiZWZvcmVTaG93RGVjYWRlOiBudWxsLFxuICBiZWZvcmVTaG93TW9udGg6IG51bGwsXG4gIGJlZm9yZVNob3dZZWFyOiBudWxsLFxuICBjYWxlbmRhcldlZWtzOiBmYWxzZSxcbiAgY2xlYXJCdG46IGZhbHNlLFxuICBkYXRlRGVsaW1pdGVyOiAnLCcsXG4gIGRhdGVzRGlzYWJsZWQ6IFtdLFxuICBkYXlzT2ZXZWVrRGlzYWJsZWQ6IFtdLFxuICBkYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQ6IFtdLFxuICBkZWZhdWx0Vmlld0RhdGU6IHVuZGVmaW5lZCxcbiAgLy8gcGxhY2Vob2xkZXIsIGRlZmF1bHRzIHRvIHRvZGF5KCkgYnkgdGhlIHByb2dyYW1cbiAgZGlzYWJsZVRvdWNoS2V5Ym9hcmQ6IGZhbHNlLFxuICBmb3JtYXQ6ICdtbS9kZC95eXl5JyxcbiAgbGFuZ3VhZ2U6ICdlbicsXG4gIG1heERhdGU6IG51bGwsXG4gIG1heE51bWJlck9mRGF0ZXM6IDEsXG4gIG1heFZpZXc6IDMsXG4gIG1pbkRhdGU6IG51bGwsXG4gIG5leHRBcnJvdzogJzxzdmcgY2xhc3M9XCJ3LTQgaC00IHJ0bDpyb3RhdGUtMTgwIHRleHQtZ3JheS04MDAgZGFyazp0ZXh0LXdoaXRlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAxNCAxMFwiPjxwYXRoIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZS13aWR0aD1cIjJcIiBkPVwiTTEgNWgxMm0wIDBMOSAxbTQgNEw5IDlcIi8+PC9zdmc+JyxcbiAgb3JpZW50YXRpb246ICdhdXRvJyxcbiAgcGlja0xldmVsOiAwLFxuICBwcmV2QXJyb3c6ICc8c3ZnIGNsYXNzPVwidy00IGgtNCBydGw6cm90YXRlLTE4MCB0ZXh0LWdyYXktODAwIGRhcms6dGV4dC13aGl0ZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMTQgMTBcIj48cGF0aCBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBzdHJva2Utd2lkdGg9XCIyXCIgZD1cIk0xMyA1SDFtMCAwIDQgNE0xIDVsNC00XCIvPjwvc3ZnPicsXG4gIHNob3dEYXlzT2ZXZWVrOiB0cnVlLFxuICBzaG93T25DbGljazogdHJ1ZSxcbiAgc2hvd09uRm9jdXM6IHRydWUsXG4gIHN0YXJ0VmlldzogMCxcbiAgdGl0bGU6ICcnLFxuICB0b2RheUJ0bjogZmFsc2UsXG4gIHRvZGF5QnRuTW9kZTogMCxcbiAgdG9kYXlIaWdobGlnaHQ6IGZhbHNlLFxuICB1cGRhdGVPbkJsdXI6IHRydWUsXG4gIHdlZWtTdGFydDogMFxufTtcblxudmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbmZ1bmN0aW9uIHBhcnNlSFRNTChodG1sKSB7XG4gIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XG59XG5mdW5jdGlvbiBoaWRlRWxlbWVudChlbCkge1xuICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGJhY2sgdXAgdGhlIGV4aXN0aW5nIGRpc3BsYXkgc2V0dGluZyBpbiBkYXRhLXN0eWxlLWRpc3BsYXlcbiAgaWYgKGVsLnN0eWxlLmRpc3BsYXkpIHtcbiAgICBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheSA9IGVsLnN0eWxlLmRpc3BsYXk7XG4gIH1cbiAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbn1cbmZ1bmN0aW9uIHNob3dFbGVtZW50KGVsKSB7XG4gIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5KSB7XG4gICAgLy8gcmVzdG9yZSBiYWNrZWQtdXAgZGlzcGF5IHByb3BlcnR5XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLmRhdGFzZXQuc3R5bGVEaXNwbGF5O1xuICAgIGRlbGV0ZSBlbC5kYXRhc2V0LnN0eWxlRGlzcGxheTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtcHR5Q2hpbGROb2RlcyhlbCkge1xuICBpZiAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgIGVtcHR5Q2hpbGROb2RlcyhlbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VDaGlsZE5vZGVzKGVsLCBuZXdDaGlsZE5vZGVzKSB7XG4gIGVtcHR5Q2hpbGROb2RlcyhlbCk7XG4gIGlmIChuZXdDaGlsZE5vZGVzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgIGVsLmFwcGVuZENoaWxkKG5ld0NoaWxkTm9kZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDaGlsZE5vZGVzID09PSAnc3RyaW5nJykge1xuICAgIGVsLmFwcGVuZENoaWxkKHBhcnNlSFRNTChuZXdDaGlsZE5vZGVzKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5ld0NoaWxkTm9kZXMuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5ld0NoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRMYW5nID0gZGVmYXVsdE9wdGlvbnMubGFuZ3VhZ2UsXG4gIGRlZmF1bHRGb3JtYXQgPSBkZWZhdWx0T3B0aW9ucy5mb3JtYXQsXG4gIGRlZmF1bHRXZWVrU3RhcnQgPSBkZWZhdWx0T3B0aW9ucy53ZWVrU3RhcnQ7XG5cbi8vIFJlZHVjZXIgZnVuY3Rpb24gdG8gZmlsdGVyIG91dCBpbnZhbGlkIGRheS1vZi13ZWVrIGZyb20gdGhlIGlucHV0XG5mdW5jdGlvbiBzYW5pdGl6ZURPVyhkb3csIGRheSkge1xuICByZXR1cm4gZG93Lmxlbmd0aCA8IDYgJiYgZGF5ID49IDAgJiYgZGF5IDwgNyA/IHB1c2hVbmlxdWUoZG93LCBkYXkpIDogZG93O1xufVxuZnVuY3Rpb24gY2FsY0VuZE9mV2VlayhzdGFydE9mV2Vlaykge1xuICByZXR1cm4gKHN0YXJ0T2ZXZWVrICsgNikgJSA3O1xufVxuXG4vLyB2YWxpZGF0ZSBpbnB1dCBkYXRlLiBpZiBpbnZhbGlkLCBmYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWVcbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUsIG9yaWdWYWx1ZSkge1xuICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZSh2YWx1ZSwgZm9ybWF0LCBsb2NhbGUpO1xuICByZXR1cm4gZGF0ZSAhPT0gdW5kZWZpbmVkID8gZGF0ZSA6IG9yaWdWYWx1ZTtcbn1cblxuLy8gVmFsaWRhdGUgdmlld0lkLiBpZiBpbnZhbGlkLCBmYWxsYmFjayB0byB0aGUgb3JpZ2luYWwgdmFsdWVcbmZ1bmN0aW9uIHZhbGlkYXRlVmlld0lkKHZhbHVlLCBvcmlnVmFsdWUpIHtcbiAgdmFyIG1heCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMztcbiAgdmFyIHZpZXdJZCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIHJldHVybiB2aWV3SWQgPj0gMCAmJiB2aWV3SWQgPD0gbWF4ID8gdmlld0lkIDogb3JpZ1ZhbHVlO1xufVxuXG4vLyBDcmVhdGUgRGF0ZXBpY2tlciBjb25maWd1cmF0aW9uIHRvIHNldFxuZnVuY3Rpb24gcHJvY2Vzc09wdGlvbnMob3B0aW9ucywgZGF0ZXBpY2tlcikge1xuICB2YXIgaW5PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIHZhciBjb25maWcgPSB7fTtcbiAgdmFyIGxvY2FsZXMgPSBkYXRlcGlja2VyLmNvbnN0cnVjdG9yLmxvY2FsZXM7XG4gIHZhciBfcmVmID0gZGF0ZXBpY2tlci5jb25maWcgfHwge30sXG4gICAgZm9ybWF0ID0gX3JlZi5mb3JtYXQsXG4gICAgbGFuZ3VhZ2UgPSBfcmVmLmxhbmd1YWdlLFxuICAgIGxvY2FsZSA9IF9yZWYubG9jYWxlLFxuICAgIG1heERhdGUgPSBfcmVmLm1heERhdGUsXG4gICAgbWF4VmlldyA9IF9yZWYubWF4VmlldyxcbiAgICBtaW5EYXRlID0gX3JlZi5taW5EYXRlLFxuICAgIHBpY2tMZXZlbCA9IF9yZWYucGlja0xldmVsLFxuICAgIHN0YXJ0VmlldyA9IF9yZWYuc3RhcnRWaWV3LFxuICAgIHdlZWtTdGFydCA9IF9yZWYud2Vla1N0YXJ0O1xuICBpZiAoaW5PcHRzLmxhbmd1YWdlKSB7XG4gICAgdmFyIGxhbmc7XG4gICAgaWYgKGluT3B0cy5sYW5ndWFnZSAhPT0gbGFuZ3VhZ2UpIHtcbiAgICAgIGlmIChsb2NhbGVzW2luT3B0cy5sYW5ndWFnZV0pIHtcbiAgICAgICAgbGFuZyA9IGluT3B0cy5sYW5ndWFnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGxhbmdhdWdlICsgcmVnaW9uIHRhZyBjYW4gZmFsbGJhY2sgdG8gdGhlIG9uZSB3aXRob3V0XG4gICAgICAgIC8vIHJlZ2lvbiAoZS5nLiBmci1DQSDihpIgZnIpXG4gICAgICAgIGxhbmcgPSBpbk9wdHMubGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbGFuZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxhbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLmxhbmd1YWdlO1xuICAgIGlmIChsYW5nKSB7XG4gICAgICBsYW5ndWFnZSA9IGNvbmZpZy5sYW5ndWFnZSA9IGxhbmc7XG5cbiAgICAgIC8vIHVwZGF0ZSBsb2NhbGUgYXMgd2VsbCB3aGVuIHVwZGF0aW5nIGxhbmd1YWdlXG4gICAgICB2YXIgb3JpZ0xvY2FsZSA9IGxvY2FsZSB8fCBsb2NhbGVzW2RlZmF1bHRMYW5nXTtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IGxhbmd1YWdlJ3MgcHJvcGVydGllcyBmb3IgdGhlIGZhbGxiYWNrXG4gICAgICBsb2NhbGUgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgZm9ybWF0OiBkZWZhdWx0Rm9ybWF0LFxuICAgICAgICB3ZWVrU3RhcnQ6IGRlZmF1bHRXZWVrU3RhcnRcbiAgICAgIH0sIGxvY2FsZXNbZGVmYXVsdExhbmddKTtcbiAgICAgIGlmIChsYW5ndWFnZSAhPT0gZGVmYXVsdExhbmcpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsb2NhbGUsIGxvY2FsZXNbbGFuZ3VhZ2VdKTtcbiAgICAgIH1cbiAgICAgIGNvbmZpZy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAvLyBpZiBmb3JtYXQgYW5kL29yIHdlZWtTdGFydCBhcmUgdGhlIHNhbWUgYXMgb2xkIGxvY2FsZSdzIGRlZmF1bHRzLFxuICAgICAgLy8gdXBkYXRlIHRoZW0gdG8gbmV3IGxvY2FsZSdzIGRlZmF1bHRzXG4gICAgICBpZiAoZm9ybWF0ID09PSBvcmlnTG9jYWxlLmZvcm1hdCkge1xuICAgICAgICBmb3JtYXQgPSBjb25maWcuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgICAgIH1cbiAgICAgIGlmICh3ZWVrU3RhcnQgPT09IG9yaWdMb2NhbGUud2Vla1N0YXJ0KSB7XG4gICAgICAgIHdlZWtTdGFydCA9IGNvbmZpZy53ZWVrU3RhcnQgPSBsb2NhbGUud2Vla1N0YXJ0O1xuICAgICAgICBjb25maWcud2Vla0VuZCA9IGNhbGNFbmRPZldlZWsobG9jYWxlLndlZWtTdGFydCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpbk9wdHMuZm9ybWF0KSB7XG4gICAgdmFyIGhhc1RvRGlzcGxheSA9IHR5cGVvZiBpbk9wdHMuZm9ybWF0LnRvRGlzcGxheSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB2YXIgaGFzVG9WYWx1ZSA9IHR5cGVvZiBpbk9wdHMuZm9ybWF0LnRvVmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgdmFyIHZhbGlkRm9ybWF0U3RyaW5nID0gcmVGb3JtYXRUb2tlbnMudGVzdChpbk9wdHMuZm9ybWF0KTtcbiAgICBpZiAoaGFzVG9EaXNwbGF5ICYmIGhhc1RvVmFsdWUgfHwgdmFsaWRGb3JtYXRTdHJpbmcpIHtcbiAgICAgIGZvcm1hdCA9IGNvbmZpZy5mb3JtYXQgPSBpbk9wdHMuZm9ybWF0O1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLmZvcm1hdDtcbiAgfVxuXG4gIC8vKioqIGRhdGVzICoqKi8vXG4gIC8vIHdoaWxlIG1pbiBhbmQgbWF4RGF0ZSBmb3IgXCJubyBsaW1pdFwiIGluIHRoZSBvcHRpb25zIGFyZSBiZXR0ZXIgdG8gYmUgbnVsbFxuICAvLyAoZXNwZWNpYWxseSB3aGVuIHVwZGF0aW5nKSwgdGhlIG9uZXMgaW4gdGhlIGNvbmZpZyBoYXZlIHRvIGJlIHVuZGVmaW5lZFxuICAvLyBiZWNhdXNlIG51bGwgaXMgdHJlYXRlZCBhcyAwICg9IHVuaXggZXBvY2gpIHdoZW4gY29tcGFyaW5nIHdpdGggdGltZSB2YWx1ZVxuICB2YXIgbWluRHQgPSBtaW5EYXRlO1xuICB2YXIgbWF4RHQgPSBtYXhEYXRlO1xuICBpZiAoaW5PcHRzLm1pbkRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1pbkR0ID0gaW5PcHRzLm1pbkRhdGUgPT09IG51bGwgPyBkYXRlVmFsdWUoMCwgMCwgMSkgLy8gc2V0IDAwMDAtMDEtMDEgdG8gcHJldmVudCBuZWdhdGl2ZSB2YWx1ZXMgZm9yIHllYXJcbiAgICA6IHZhbGlkYXRlRGF0ZShpbk9wdHMubWluRGF0ZSwgZm9ybWF0LCBsb2NhbGUsIG1pbkR0KTtcbiAgICBkZWxldGUgaW5PcHRzLm1pbkRhdGU7XG4gIH1cbiAgaWYgKGluT3B0cy5tYXhEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBtYXhEdCA9IGluT3B0cy5tYXhEYXRlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsaWRhdGVEYXRlKGluT3B0cy5tYXhEYXRlLCBmb3JtYXQsIGxvY2FsZSwgbWF4RHQpO1xuICAgIGRlbGV0ZSBpbk9wdHMubWF4RGF0ZTtcbiAgfVxuICBpZiAobWF4RHQgPCBtaW5EdCkge1xuICAgIG1pbkRhdGUgPSBjb25maWcubWluRGF0ZSA9IG1heER0O1xuICAgIG1heERhdGUgPSBjb25maWcubWF4RGF0ZSA9IG1pbkR0O1xuICB9IGVsc2Uge1xuICAgIGlmIChtaW5EYXRlICE9PSBtaW5EdCkge1xuICAgICAgbWluRGF0ZSA9IGNvbmZpZy5taW5EYXRlID0gbWluRHQ7XG4gICAgfVxuICAgIGlmIChtYXhEYXRlICE9PSBtYXhEdCkge1xuICAgICAgbWF4RGF0ZSA9IGNvbmZpZy5tYXhEYXRlID0gbWF4RHQ7XG4gICAgfVxuICB9XG4gIGlmIChpbk9wdHMuZGF0ZXNEaXNhYmxlZCkge1xuICAgIGNvbmZpZy5kYXRlc0Rpc2FibGVkID0gaW5PcHRzLmRhdGVzRGlzYWJsZWQucmVkdWNlKGZ1bmN0aW9uIChkYXRlcywgZHQpIHtcbiAgICAgIHZhciBkYXRlID0gcGFyc2VEYXRlKGR0LCBmb3JtYXQsIGxvY2FsZSk7XG4gICAgICByZXR1cm4gZGF0ZSAhPT0gdW5kZWZpbmVkID8gcHVzaFVuaXF1ZShkYXRlcywgZGF0ZSkgOiBkYXRlcztcbiAgICB9LCBbXSk7XG4gICAgZGVsZXRlIGluT3B0cy5kYXRlc0Rpc2FibGVkO1xuICB9XG4gIGlmIChpbk9wdHMuZGVmYXVsdFZpZXdEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgdmlld0RhdGUgPSBwYXJzZURhdGUoaW5PcHRzLmRlZmF1bHRWaWV3RGF0ZSwgZm9ybWF0LCBsb2NhbGUpO1xuICAgIGlmICh2aWV3RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25maWcuZGVmYXVsdFZpZXdEYXRlID0gdmlld0RhdGU7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMuZGVmYXVsdFZpZXdEYXRlO1xuICB9XG5cbiAgLy8qKiogZGF5cyBvZiB3ZWVrICoqKi8vXG4gIGlmIChpbk9wdHMud2Vla1N0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgd2tTdGFydCA9IE51bWJlcihpbk9wdHMud2Vla1N0YXJ0KSAlIDc7XG4gICAgaWYgKCFpc05hTih3a1N0YXJ0KSkge1xuICAgICAgd2Vla1N0YXJ0ID0gY29uZmlnLndlZWtTdGFydCA9IHdrU3RhcnQ7XG4gICAgICBjb25maWcud2Vla0VuZCA9IGNhbGNFbmRPZldlZWsod2tTdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMud2Vla1N0YXJ0O1xuICB9XG4gIGlmIChpbk9wdHMuZGF5c09mV2Vla0Rpc2FibGVkKSB7XG4gICAgY29uZmlnLmRheXNPZldlZWtEaXNhYmxlZCA9IGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQucmVkdWNlKHNhbml0aXplRE9XLCBbXSk7XG4gICAgZGVsZXRlIGluT3B0cy5kYXlzT2ZXZWVrRGlzYWJsZWQ7XG4gIH1cbiAgaWYgKGluT3B0cy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25maWcuZGF5c09mV2Vla0hpZ2hsaWdodGVkID0gaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZC5yZWR1Y2Uoc2FuaXRpemVET1csIFtdKTtcbiAgICBkZWxldGUgaW5PcHRzLmRheXNPZldlZWtIaWdobGlnaHRlZDtcbiAgfVxuXG4gIC8vKioqIG11bHRpIGRhdGUgKioqLy9cbiAgaWYgKGluT3B0cy5tYXhOdW1iZXJPZkRhdGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbWF4TnVtYmVyT2ZEYXRlcyA9IHBhcnNlSW50KGluT3B0cy5tYXhOdW1iZXJPZkRhdGVzLCAxMCk7XG4gICAgaWYgKG1heE51bWJlck9mRGF0ZXMgPj0gMCkge1xuICAgICAgY29uZmlnLm1heE51bWJlck9mRGF0ZXMgPSBtYXhOdW1iZXJPZkRhdGVzO1xuICAgICAgY29uZmlnLm11bHRpZGF0ZSA9IG1heE51bWJlck9mRGF0ZXMgIT09IDE7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMubWF4TnVtYmVyT2ZEYXRlcztcbiAgfVxuICBpZiAoaW5PcHRzLmRhdGVEZWxpbWl0ZXIpIHtcbiAgICBjb25maWcuZGF0ZURlbGltaXRlciA9IFN0cmluZyhpbk9wdHMuZGF0ZURlbGltaXRlcik7XG4gICAgZGVsZXRlIGluT3B0cy5kYXRlRGVsaW1pdGVyO1xuICB9XG5cbiAgLy8qKiogcGljayBsZXZlbCAmIHZpZXcgKioqLy9cbiAgdmFyIG5ld1BpY2tMZXZlbCA9IHBpY2tMZXZlbDtcbiAgaWYgKGluT3B0cy5waWNrTGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgIG5ld1BpY2tMZXZlbCA9IHZhbGlkYXRlVmlld0lkKGluT3B0cy5waWNrTGV2ZWwsIDIpO1xuICAgIGRlbGV0ZSBpbk9wdHMucGlja0xldmVsO1xuICB9XG4gIGlmIChuZXdQaWNrTGV2ZWwgIT09IHBpY2tMZXZlbCkge1xuICAgIHBpY2tMZXZlbCA9IGNvbmZpZy5waWNrTGV2ZWwgPSBuZXdQaWNrTGV2ZWw7XG4gIH1cbiAgdmFyIG5ld01heFZpZXcgPSBtYXhWaWV3O1xuICBpZiAoaW5PcHRzLm1heFZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgIG5ld01heFZpZXcgPSB2YWxpZGF0ZVZpZXdJZChpbk9wdHMubWF4VmlldywgbWF4Vmlldyk7XG4gICAgZGVsZXRlIGluT3B0cy5tYXhWaWV3O1xuICB9XG4gIC8vIGVuc3VyZSBtYXggdmlldyA+PSBwaWNrIGxldmVsXG4gIG5ld01heFZpZXcgPSBwaWNrTGV2ZWwgPiBuZXdNYXhWaWV3ID8gcGlja0xldmVsIDogbmV3TWF4VmlldztcbiAgaWYgKG5ld01heFZpZXcgIT09IG1heFZpZXcpIHtcbiAgICBtYXhWaWV3ID0gY29uZmlnLm1heFZpZXcgPSBuZXdNYXhWaWV3O1xuICB9XG4gIHZhciBuZXdTdGFydFZpZXcgPSBzdGFydFZpZXc7XG4gIGlmIChpbk9wdHMuc3RhcnRWaWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICBuZXdTdGFydFZpZXcgPSB2YWxpZGF0ZVZpZXdJZChpbk9wdHMuc3RhcnRWaWV3LCBuZXdTdGFydFZpZXcpO1xuICAgIGRlbGV0ZSBpbk9wdHMuc3RhcnRWaWV3O1xuICB9XG4gIC8vIGVuc3VyZSBwaWNrIGxldmVsIDw9IHN0YXJ0IHZpZXcgPD0gbWF4IHZpZXdcbiAgaWYgKG5ld1N0YXJ0VmlldyA8IHBpY2tMZXZlbCkge1xuICAgIG5ld1N0YXJ0VmlldyA9IHBpY2tMZXZlbDtcbiAgfSBlbHNlIGlmIChuZXdTdGFydFZpZXcgPiBtYXhWaWV3KSB7XG4gICAgbmV3U3RhcnRWaWV3ID0gbWF4VmlldztcbiAgfVxuICBpZiAobmV3U3RhcnRWaWV3ICE9PSBzdGFydFZpZXcpIHtcbiAgICBjb25maWcuc3RhcnRWaWV3ID0gbmV3U3RhcnRWaWV3O1xuICB9XG5cbiAgLy8qKiogdGVtcGxhdGUgKioqLy9cbiAgaWYgKGluT3B0cy5wcmV2QXJyb3cpIHtcbiAgICB2YXIgcHJldkFycm93ID0gcGFyc2VIVE1MKGluT3B0cy5wcmV2QXJyb3cpO1xuICAgIGlmIChwcmV2QXJyb3cuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25maWcucHJldkFycm93ID0gcHJldkFycm93LmNoaWxkTm9kZXM7XG4gICAgfVxuICAgIGRlbGV0ZSBpbk9wdHMucHJldkFycm93O1xuICB9XG4gIGlmIChpbk9wdHMubmV4dEFycm93KSB7XG4gICAgdmFyIG5leHRBcnJvdyA9IHBhcnNlSFRNTChpbk9wdHMubmV4dEFycm93KTtcbiAgICBpZiAobmV4dEFycm93LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uZmlnLm5leHRBcnJvdyA9IG5leHRBcnJvdy5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLm5leHRBcnJvdztcbiAgfVxuXG4gIC8vKioqIG1pc2MgKioqLy9cbiAgaWYgKGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnLmRpc2FibGVUb3VjaEtleWJvYXJkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQgJiYgISFpbk9wdHMuZGlzYWJsZVRvdWNoS2V5Ym9hcmQ7XG4gICAgZGVsZXRlIGluT3B0cy5kaXNhYmxlVG91Y2hLZXlib2FyZDtcbiAgfVxuICBpZiAoaW5PcHRzLm9yaWVudGF0aW9uKSB7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gaW5PcHRzLm9yaWVudGF0aW9uLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1xccysvZyk7XG4gICAgY29uZmlnLm9yaWVudGF0aW9uID0ge1xuICAgICAgeDogb3JpZW50YXRpb24uZmluZChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCA9PT0gJ2xlZnQnIHx8IHggPT09ICdyaWdodCc7XG4gICAgICB9KSB8fCAnYXV0bycsXG4gICAgICB5OiBvcmllbnRhdGlvbi5maW5kKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIHJldHVybiB5ID09PSAndG9wJyB8fCB5ID09PSAnYm90dG9tJztcbiAgICAgIH0pIHx8ICdhdXRvJ1xuICAgIH07XG4gICAgZGVsZXRlIGluT3B0cy5vcmllbnRhdGlvbjtcbiAgfVxuICBpZiAoaW5PcHRzLnRvZGF5QnRuTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3dpdGNoIChpbk9wdHMudG9kYXlCdG5Nb2RlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNvbmZpZy50b2RheUJ0bk1vZGUgPSBpbk9wdHMudG9kYXlCdG5Nb2RlO1xuICAgIH1cbiAgICBkZWxldGUgaW5PcHRzLnRvZGF5QnRuTW9kZTtcbiAgfVxuXG4gIC8vKioqIGNvcHkgdGhlIHJlc3QgKioqLy9cbiAgT2JqZWN0LmtleXMoaW5PcHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoaW5PcHRzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBoYXNQcm9wZXJ0eShkZWZhdWx0T3B0aW9ucywga2V5KSkge1xuICAgICAgY29uZmlnW2tleV0gPSBpbk9wdHNba2V5XTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29uZmlnO1xufVxuXG52YXIgcGlja2VyVGVtcGxhdGUgPSBvcHRpbWl6ZVRlbXBsYXRlSFRNTChcIjxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXIgaGlkZGVuXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItcGlja2VyIGlubGluZS1ibG9jayByb3VuZGVkLWxnIGJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgc2hhZG93LWxnIHAtNFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItaGVhZGVyXFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJkYXRlcGlja2VyLXRpdGxlIGJnLXdoaXRlIGRhcms6YmctZ3JheS03MDAgZGFyazp0ZXh0LXdoaXRlIHB4LTIgcHktMyB0ZXh0LWNlbnRlciBmb250LXNlbWlib2xkXFxcIj48L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJkYXRlcGlja2VyLWNvbnRyb2xzIGZsZXgganVzdGlmeS1iZXR3ZWVuIG1iLTJcXFwiPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIHJvdW5kZWQtbGcgdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtd2hpdGUgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBob3Zlcjp0ZXh0LWdyYXktOTAwIGRhcms6aG92ZXI6dGV4dC13aGl0ZSB0ZXh0LWxnIHAtMi41IGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTIwMCBwcmV2LWJ0blxcXCI+PC9idXR0b24+XFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcInRleHQtc20gcm91bmRlZC1sZyB0ZXh0LWdyYXktOTAwIGRhcms6dGV4dC13aGl0ZSBiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIGZvbnQtc2VtaWJvbGQgcHktMi41IHB4LTUgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JheS0yMDAgdmlldy1zd2l0Y2hcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJiZy13aGl0ZSBkYXJrOmJnLWdyYXktNzAwIHJvdW5kZWQtbGcgdGV4dC1ncmF5LTUwMCBkYXJrOnRleHQtd2hpdGUgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBob3Zlcjp0ZXh0LWdyYXktOTAwIGRhcms6aG92ZXI6dGV4dC13aGl0ZSB0ZXh0LWxnIHAtMi41IGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1ncmF5LTIwMCBuZXh0LWJ0blxcXCI+PC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkYXRlcGlja2VyLW1haW4gcC0xXFxcIj48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlci1mb290ZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItY29udHJvbHMgZmxleCBzcGFjZS14LTIgcnRsOnNwYWNlLXgtcmV2ZXJzZSBtdC0yXFxcIj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiJWJ1dHRvbkNsYXNzJSB0b2RheS1idG4gdGV4dC13aGl0ZSBiZy1ibHVlLTcwMCAhYmctcHJpbWFyeS03MDAgZGFyazpiZy1ibHVlLTYwMCBkYXJrOiFiZy1wcmltYXJ5LTYwMCBob3ZlcjpiZy1ibHVlLTgwMCBob3ZlcjohYmctcHJpbWFyeS04MDAgZGFyazpob3ZlcjpiZy1ibHVlLTcwMCBkYXJrOmhvdmVyOiFiZy1wcmltYXJ5LTcwMCBmb2N1czpyaW5nLTQgZm9jdXM6cmluZy1ibHVlLTMwMCBmb2N1czohcmluZy1wcmltYXJ5LTMwMCBmb250LW1lZGl1bSByb3VuZGVkLWxnIHRleHQtc20gcHgtNSBweS0yIHRleHQtY2VudGVyIHctMS8yXFxcIj48L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiJWJ1dHRvbkNsYXNzJSBjbGVhci1idG4gdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgYmctd2hpdGUgZGFyazpiZy1ncmF5LTcwMCBib3JkZXIgYm9yZGVyLWdyYXktMzAwIGRhcms6Ym9yZGVyLWdyYXktNjAwIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgZm9jdXM6cmluZy00IGZvY3VzOnJpbmctYmx1ZS0zMDAgZm9jdXM6IXJpbmctcHJpbWFyeS0zMDAgZm9udC1tZWRpdW0gcm91bmRlZC1sZyB0ZXh0LXNtIHB4LTUgcHktMiB0ZXh0LWNlbnRlciB3LTEvMlxcXCI+PC9idXR0b24+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XCIpO1xuXG52YXIgZGF5c1RlbXBsYXRlID0gb3B0aW1pemVUZW1wbGF0ZUhUTUwoXCI8ZGl2IGNsYXNzPVxcXCJkYXlzXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImRheXMtb2Ytd2VlayBncmlkIGdyaWQtY29scy03IG1iLTFcXFwiPlwiLmNvbmNhdChjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA3LCB7XG4gIFwiY2xhc3NcIjogJ2RvdyBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLWRlZmF1bHQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBmb250LXNlbWlib2xkIHRleHQtc20nXG59KSwgXCI8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImRhdGVwaWNrZXItZ3JpZCB3LTY0IGdyaWQgZ3JpZC1jb2xzLTdcXFwiPlwiKS5jb25jYXQoY3JlYXRlVGFnUmVwZWF0KCdzcGFuJywgNDIsIHtcbiAgXCJjbGFzc1wiOiAnYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1kZWZhdWx0IHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZm9udC1zZW1pYm9sZCB0ZXh0LXNtIGgtNiBsZWFkaW5nLTYgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMCdcbn0pLCBcIjwvZGl2PlxcbjwvZGl2PlwiKSk7XG5cbnZhciBjYWxlbmRhcldlZWtzVGVtcGxhdGUgPSBvcHRpbWl6ZVRlbXBsYXRlSFRNTChcIjxkaXYgY2xhc3M9XFxcImNhbGVuZGFyLXdlZWtzXFxcIj5cXG4gIDxkaXYgY2xhc3M9XFxcImRheXMtb2Ytd2VlayBmbGV4XFxcIj48c3BhbiBjbGFzcz1cXFwiZG93IGgtNiBsZWFkaW5nLTYgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMFxcXCI+PC9zcGFuPjwvZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwid2Vla3NcXFwiPlwiLmNvbmNhdChjcmVhdGVUYWdSZXBlYXQoJ3NwYW4nLCA2LCB7XG4gIFwiY2xhc3NcIjogJ3dlZWsgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1kZWZhdWx0IHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZm9udC1zZW1pYm9sZCB0ZXh0LXNtJ1xufSksIFwiPC9kaXY+XFxuPC9kaXY+XCIpKTtcblxuLy8gQmFzZSBjbGFzcyBvZiB0aGUgdmlldyBjbGFzc2VzXG52YXIgVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXcocGlja2VyLCBjb25maWcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlldyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjb25maWcsIHtcbiAgICAgIHBpY2tlcjogcGlja2VyLFxuICAgICAgZWxlbWVudDogcGFyc2VIVE1MKFwiPGRpdiBjbGFzcz1cXFwiZGF0ZXBpY2tlci12aWV3IGZsZXhcXFwiPjwvZGl2PlwiKS5maXJzdENoaWxkLFxuICAgICAgc2VsZWN0ZWQ6IFtdXG4gICAgfSk7XG4gICAgdGhpcy5pbml0KHRoaXMucGlja2VyLmRhdGVwaWNrZXIuY29uZmlnKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFZpZXcsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5waWNrTGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlzTWluVmlldyA9IHRoaXMuaWQgPT09IG9wdGlvbnMucGlja0xldmVsO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdGhpcy51cGRhdGVGb2N1cygpO1xuICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRlIGJlZm9yZVNob3coKSBjYWxsYmFjayBhbmQgYXBwbHkgdGhlIHJlc3VsdCB0byB0aGUgZWxlbWVudFxuICAgIC8vIGFyZ3M6XG4gICAgLy8gLSBjdXJyZW50IC0gY3VycmVudCB2YWx1ZSBvbiB0aGUgaXRlcmF0aW9uIG9uIHZpZXcgcmVuZGVyaW5nXG4gICAgLy8gLSB0aW1lVmFsdWUgLSB0aW1lIHZhbHVlIG9mIHRoZSBkYXRlIHRvIHBhc3MgdG8gYmVmb3JlU2hvdygpXG4gIH0sIHtcbiAgICBrZXk6IFwicGVyZm9ybUJlZm9yZUhvb2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIHRpbWVWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYmVmb3JlU2hvdyhuZXcgRGF0ZSh0aW1lVmFsdWUpKTtcbiAgICAgIHN3aXRjaCAoX3R5cGVvZihyZXN1bHQpKSB7XG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHJlc3VsdFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY2xhc3NlczogcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgcHVzaFVuaXF1ZSh0aGlzLmRpc2FibGVkLCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmNsYXNzZXMpIHtcbiAgICAgICAgICB2YXIgX2VsJGNsYXNzTGlzdDtcbiAgICAgICAgICB2YXIgZXh0cmFDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAoX2VsJGNsYXNzTGlzdCA9IGVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9lbCRjbGFzc0xpc3QsIF90b0NvbnN1bWFibGVBcnJheShleHRyYUNsYXNzZXMpKTtcbiAgICAgICAgICBpZiAoZXh0cmFDbGFzc2VzLmluY2x1ZGVzKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICBwdXNoVW5pcXVlKHRoaXMuZGlzYWJsZWQsIGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmNvbnRlbnQpIHtcbiAgICAgICAgICByZXBsYWNlQ2hpbGROb2RlcyhlbCwgcmVzdWx0LmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbnZhciBEYXlzVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1ZpZXcpIHtcbiAgZnVuY3Rpb24gRGF5c1ZpZXcocGlja2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERheXNWaWV3KTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBEYXlzVmlldywgW3BpY2tlciwge1xuICAgICAgaWQ6IDAsXG4gICAgICBuYW1lOiAnZGF5cycsXG4gICAgICBjZWxsQ2xhc3M6ICdkYXknXG4gICAgfV0pO1xuICB9XG4gIF9pbmhlcml0cyhEYXlzVmlldywgX1ZpZXcpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERheXNWaWV3LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgICAgdmFyIG9uQ29uc3RydWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XG4gICAgICAgIHZhciBpbm5lciA9IHBhcnNlSFRNTChkYXlzVGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZG93ID0gaW5uZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgdGhpcy5ncmlkID0gaW5uZXIubGFzdENoaWxkO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgfVxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRGF5c1ZpZXcucHJvdG90eXBlKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHVwZGF0ZURPVztcbiAgICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWluRGF0ZScpKSB7XG4gICAgICAgIHRoaXMubWluRGF0ZSA9IG9wdGlvbnMubWluRGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IG9wdGlvbnMubWF4RGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmRhdGVzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5kYXRlc0Rpc2FibGVkID0gb3B0aW9ucy5kYXRlc0Rpc2FibGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZGF5c09mV2Vla0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGF5c09mV2Vla0Rpc2FibGVkID0gb3B0aW9ucy5kYXlzT2ZXZWVrRGlzYWJsZWQ7XG4gICAgICAgIHVwZGF0ZURPVyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgdGhpcy5kYXlzT2ZXZWVrSGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmRheXNPZldlZWtIaWdobGlnaHRlZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRvZGF5SGlnaGxpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy50b2RheUhpZ2hsaWdodCA9IG9wdGlvbnMudG9kYXlIaWdobGlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy53ZWVrU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLndlZWtTdGFydCA9IG9wdGlvbnMud2Vla1N0YXJ0O1xuICAgICAgICB0aGlzLndlZWtFbmQgPSBvcHRpb25zLndlZWtFbmQ7XG4gICAgICAgIHVwZGF0ZURPVyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5sb2NhbGUpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlID0gb3B0aW9ucy5sb2NhbGU7XG4gICAgICAgIHRoaXMuZGF5TmFtZXMgPSBsb2NhbGUuZGF5c01pbjtcbiAgICAgICAgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCA9IGxvY2FsZS50aXRsZUZvcm1hdDtcbiAgICAgICAgdXBkYXRlRE9XID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJlZm9yZVNob3dEYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJlZm9yZVNob3cgPSB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTaG93RGF5ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5iZWZvcmVTaG93RGF5IDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuY2FsZW5kYXJXZWVrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNhbGVuZGFyV2Vla3MgJiYgIXRoaXMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgICAgIHZhciB3ZWVrc0VsZW0gPSBwYXJzZUhUTUwoY2FsZW5kYXJXZWVrc1RlbXBsYXRlKS5maXJzdENoaWxkO1xuICAgICAgICAgIHRoaXMuY2FsZW5kYXJXZWVrcyA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHdlZWtzRWxlbSxcbiAgICAgICAgICAgIGRvdzogd2Vla3NFbGVtLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICB3ZWVrczogd2Vla3NFbGVtLmxhc3RDaGlsZFxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZSh3ZWVrc0VsZW0sIHRoaXMuZWxlbWVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MgJiYgIW9wdGlvbnMuY2FsZW5kYXJXZWVrcykge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmNhbGVuZGFyV2Vla3MuZWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5jYWxlbmRhcldlZWtzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2hvd0RheXNPZldlZWsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5zaG93RGF5c09mV2Vlaykge1xuICAgICAgICAgIHNob3dFbGVtZW50KHRoaXMuZG93KTtcbiAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgICAgICBzaG93RWxlbWVudCh0aGlzLmNhbGVuZGFyV2Vla3MuZG93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlkZUVsZW1lbnQodGhpcy5kb3cpO1xuICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFyV2Vla3MpIHtcbiAgICAgICAgICAgIGhpZGVFbGVtZW50KHRoaXMuY2FsZW5kYXJXZWVrcy5kb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgZGF5cy1vZi13ZWVrIHdoZW4gbG9jYWxlLCBkYXlzT2Z3ZWVrRGlzYWJsZWQgb3Igd2Vla1N0YXJ0IGlzIGNoYW5nZWRcbiAgICAgIGlmICh1cGRhdGVET1cpIHtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmRvdy5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGRvdyA9IChfdGhpcy53ZWVrU3RhcnQgKyBpbmRleCkgJSA3O1xuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gX3RoaXMuZGF5TmFtZXNbZG93XTtcbiAgICAgICAgICBlbC5jbGFzc05hbWUgPSBfdGhpcy5kYXlzT2ZXZWVrRGlzYWJsZWQuaW5jbHVkZXMoZG93KSA/ICdkb3cgZGlzYWJsZWQgdGV4dC1jZW50ZXIgaC02IGxlYWRpbmctNiB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwIGN1cnNvci1ub3QtYWxsb3dlZCcgOiAnZG93IHRleHQtY2VudGVyIGgtNiBsZWFkaW5nLTYgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTQwMCc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IHVwZGF0ZSBvbiB0aGUgZm9jdXNlZCBkYXRlIHRvIHZpZXcncyBzZXR0aW5nc1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuICAgICAgdmFyIHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xuICAgICAgdmFyIHZpZXdZZWFyID0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciB2aWV3TW9udGggPSB2aWV3RGF0ZS5nZXRNb250aCgpO1xuICAgICAgdmFyIGZpcnN0T2ZNb250aCA9IGRhdGVWYWx1ZSh2aWV3WWVhciwgdmlld01vbnRoLCAxKTtcbiAgICAgIHZhciBzdGFydCA9IGRheU9mVGhlV2Vla09mKGZpcnN0T2ZNb250aCwgdGhpcy53ZWVrU3RhcnQsIHRoaXMud2Vla1N0YXJ0KTtcbiAgICAgIHRoaXMuZmlyc3QgPSBmaXJzdE9mTW9udGg7XG4gICAgICB0aGlzLmxhc3QgPSBkYXRlVmFsdWUodmlld1llYXIsIHZpZXdNb250aCArIDEsIDApO1xuICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5mb2N1c2VkID0gdGhpcy5waWNrZXIudmlld0RhdGU7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgdXBkYXRlIG9uIHRoZSBzZWxlY3RlZCBkYXRlcyB0byB2aWV3J3Mgc2V0dGluZ3NcbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzJHBpY2tlciRkYXRlcGljayA9IHRoaXMucGlja2VyLmRhdGVwaWNrZXIsXG4gICAgICAgIGRhdGVzID0gX3RoaXMkcGlja2VyJGRhdGVwaWNrLmRhdGVzLFxuICAgICAgICByYW5nZXBpY2tlciA9IF90aGlzJHBpY2tlciRkYXRlcGljay5yYW5nZXBpY2tlcjtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBkYXRlcztcbiAgICAgIGlmIChyYW5nZXBpY2tlcikge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VwaWNrZXIuZGF0ZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIC8vIHVwZGF0ZSB0b2RheSBtYXJrZXIgb24gZXZlciByZW5kZXJcbiAgICAgIHRoaXMudG9kYXkgPSB0aGlzLnRvZGF5SGlnaGxpZ2h0ID8gdG9kYXkoKSA6IHVuZGVmaW5lZDtcbiAgICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgZGF0ZXMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXG4gICAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXG4gICAgICB0aGlzLmRpc2FibGVkID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuZGF0ZXNEaXNhYmxlZCk7XG4gICAgICB2YXIgc3dpdGNoTGFiZWwgPSBmb3JtYXREYXRlKHRoaXMuZm9jdXNlZCwgdGhpcy5zd2l0Y2hMYWJlbEZvcm1hdCwgdGhpcy5sb2NhbGUpO1xuICAgICAgdGhpcy5waWNrZXIuc2V0Vmlld1N3aXRjaExhYmVsKHN3aXRjaExhYmVsKTtcbiAgICAgIHRoaXMucGlja2VyLnNldFByZXZCdG5EaXNhYmxlZCh0aGlzLmZpcnN0IDw9IHRoaXMubWluRGF0ZSk7XG4gICAgICB0aGlzLnBpY2tlci5zZXROZXh0QnRuRGlzYWJsZWQodGhpcy5sYXN0ID49IHRoaXMubWF4RGF0ZSk7XG4gICAgICBpZiAodGhpcy5jYWxlbmRhcldlZWtzKSB7XG4gICAgICAgIC8vIHN0YXJ0IG9mIHRoZSBVVEMgd2VlayAoTW9uZGF5KSBvZiB0aGUgMXN0IG9mIHRoZSBtb250aFxuICAgICAgICB2YXIgc3RhcnRPZldlZWsgPSBkYXlPZlRoZVdlZWtPZih0aGlzLmZpcnN0LCAxLCAxKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLmNhbGVuZGFyV2Vla3Mud2Vla3MuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpbmRleCkge1xuICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gZ2V0V2VlayhhZGRXZWVrcyhzdGFydE9mV2VlaywgaW5kZXgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICAgIHZhciBjdXJyZW50ID0gYWRkRGF5cyhfdGhpczIuc3RhcnQsIGluZGV4KTtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShjdXJyZW50KTtcbiAgICAgICAgdmFyIGRheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiZGF0ZXBpY2tlci1jZWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSBcIi5jb25jYXQoX3RoaXMyLmNlbGxDbGFzcyk7XG4gICAgICAgIGVsLmRhdGFzZXQuZGF0ZSA9IGN1cnJlbnQ7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIGlmIChjdXJyZW50IDwgX3RoaXMyLmZpcnN0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncHJldicsICd0ZXh0LWdyYXktNTAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQgPiBfdGhpczIubGFzdCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ25leHQnLCAndGV4dC1ncmF5LTUwMCcsICdkYXJrOnRleHQtd2hpdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLnRvZGF5ID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgndG9kYXknLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50IDwgX3RoaXMyLm1pbkRhdGUgfHwgY3VycmVudCA+IF90aGlzMi5tYXhEYXRlIHx8IF90aGlzMi5kaXNhYmxlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJywgJ2N1cnNvci1ub3QtYWxsb3dlZCcsICd0ZXh0LWdyYXktNDAwJywgJ2Rhcms6dGV4dC1ncmF5LTUwMCcpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyOmJnLWdyYXktMTAwJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnLCAndGV4dC1ncmF5LTkwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnY3Vyc29yLXBvaW50ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLmRheXNPZldlZWtEaXNhYmxlZC5pbmNsdWRlcyhkYXkpKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZGlzYWJsZWQnLCAnY3Vyc29yLW5vdC1hbGxvd2VkJywgJ3RleHQtZ3JheS00MDAnLCAnZGFyazp0ZXh0LWdyYXktNTAwJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcsICd0ZXh0LWdyYXktOTAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICdjdXJzb3ItcG9pbnRlcicpO1xuICAgICAgICAgIHB1c2hVbmlxdWUoX3RoaXMyLmRpc2FibGVkLCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLmRheXNPZldlZWtIaWdobGlnaHRlZC5pbmNsdWRlcyhkYXkpKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLnJhbmdlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiRyYW5nZSA9IF9zbGljZWRUb0FycmF5KF90aGlzMi5yYW5nZSwgMiksXG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gX3RoaXMyJHJhbmdlWzBdLFxuICAgICAgICAgICAgcmFuZ2VFbmQgPSBfdGhpczIkcmFuZ2VbMV07XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnLCAnYmctZ3JheS0yMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLWwtbGcnLCAncm91bmRlZC1yLWxnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcsICdiZy1ncmF5LTEwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycpO1xuICAgICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgncm91bmRlZC1sZycsICdyb3VuZGVkLXItbGcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnLCAnYmctZ3JheS0xMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdyb3VuZGVkLXItbGcnKTtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnLCAncm91bmRlZC1sLWxnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIuc2VsZWN0ZWQuaW5jbHVkZXMoY3VycmVudCkpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICchYmctcHJpbWFyeS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6IWJnLXByaW1hcnktNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAndGV4dC1ncmF5LTUwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ2JnLWdyYXktMTAwJywgJ2JnLWdyYXktMjAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IF90aGlzMi5mb2N1c2VkKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIuYmVmb3JlU2hvdykge1xuICAgICAgICAgIF90aGlzMi5wZXJmb3JtQmVmb3JlSG9vayhlbCwgY3VycmVudCwgY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlcyBvZiBzZWxlY3RlZCBhbmQgZm9jdXNlZCBpdGVtc1xuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIF9yZWYgPSB0aGlzLnJhbmdlIHx8IFtdLFxuICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICByYW5nZVN0YXJ0ID0gX3JlZjJbMF0sXG4gICAgICAgIHJhbmdlRW5kID0gX3JlZjJbMV07XG4gICAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLnJhbmdlLCAucmFuZ2Utc3RhcnQsIC5yYW5nZS1lbmQsIC5zZWxlY3RlZCwgLmZvY3VzZWQnKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdyYW5nZScsICdyYW5nZS1zdGFydCcsICdyYW5nZS1lbmQnLCAnc2VsZWN0ZWQnLCAnYmctYmx1ZS03MDAnLCAnIWJnLXByaW1hcnktNzAwJywgJ3RleHQtd2hpdGUnLCAnZGFyazpiZy1ibHVlLTYwMCcsICdkYXJrOiFiZy1wcmltYXJ5LTYwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZm9jdXNlZCcpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd0ZXh0LWdyYXktOTAwJywgJ3JvdW5kZWQtbGcnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICB9KTtcbiAgICAgIEFycmF5LmZyb20odGhpcy5ncmlkLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IE51bWJlcihlbC5kYXRhc2V0LmRhdGUpO1xuICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycsICdyb3VuZGVkLXItbGcnKTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPiByYW5nZVN0YXJ0ICYmIGN1cnJlbnQgPCByYW5nZUVuZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJywgJ2JnLWdyYXktMjAwJywgJ2Rhcms6YmctZ3JheS02MDAnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1zdGFydCcsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJywgJ3JvdW5kZWQtbC1sZycpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3JvdW5kZWQtbGcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VFbmQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnLCAnYmctZ3JheS0yMDAnLCAnZGFyazpiZy1ncmF5LTYwMCcsICdyb3VuZGVkLXItbGcnKTtcbiAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKCdyb3VuZGVkLWxnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazohYmctcHJpbWFyeS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcsICdiZy1ncmF5LTEwMCcsICdiZy1ncmF5LTIwMCcsICdkYXJrOmJnLWdyYXktNjAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IF90aGlzMy5mb2N1c2VkKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZSBvZiBmb2N1c2VkIGl0ZW1cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoRm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaEZvY3VzKCkge1xuICAgICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZCgodGhpcy5mb2N1c2VkIC0gdGhpcy5zdGFydCkgLyA4NjQwMDAwMCk7XG4gICAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JpZC5jaGlsZHJlbltpbmRleF0uY2xhc3NMaXN0LmFkZCgnZm9jdXNlZCcpO1xuICAgIH1cbiAgfV0pO1xufShWaWV3KTtcblxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoUmFuZ2UocmFuZ2UsIHRoaXNZZWFyKSB7XG4gIGlmICghcmFuZ2UgfHwgIXJhbmdlWzBdIHx8ICFyYW5nZVsxXSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX3JhbmdlID0gX3NsaWNlZFRvQXJyYXkocmFuZ2UsIDIpLFxuICAgIF9yYW5nZSQgPSBfc2xpY2VkVG9BcnJheShfcmFuZ2VbMF0sIDIpLFxuICAgIHN0YXJ0WSA9IF9yYW5nZSRbMF0sXG4gICAgc3RhcnRNID0gX3JhbmdlJFsxXSxcbiAgICBfcmFuZ2UkMiA9IF9zbGljZWRUb0FycmF5KF9yYW5nZVsxXSwgMiksXG4gICAgZW5kWSA9IF9yYW5nZSQyWzBdLFxuICAgIGVuZE0gPSBfcmFuZ2UkMlsxXTtcbiAgaWYgKHN0YXJ0WSA+IHRoaXNZZWFyIHx8IGVuZFkgPCB0aGlzWWVhcikge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gW3N0YXJ0WSA9PT0gdGhpc1llYXIgPyBzdGFydE0gOiAtMSwgZW5kWSA9PT0gdGhpc1llYXIgPyBlbmRNIDogMTJdO1xufVxudmFyIE1vbnRoc1ZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9WaWV3KSB7XG4gIGZ1bmN0aW9uIE1vbnRoc1ZpZXcocGlja2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vbnRoc1ZpZXcpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIE1vbnRoc1ZpZXcsIFtwaWNrZXIsIHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogJ21vbnRocycsXG4gICAgICBjZWxsQ2xhc3M6ICdtb250aCdcbiAgICB9XSk7XG4gIH1cbiAgX2luaGVyaXRzKE1vbnRoc1ZpZXcsIF9WaWV3KTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNb250aHNWaWV3LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgICAgdmFyIG9uQ29uc3RydWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKG9uQ29uc3RydWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21vbnRocycsICdkYXRlcGlja2VyLWdyaWQnLCAndy02NCcsICdncmlkJywgJ2dyaWQtY29scy00Jyk7XG4gICAgICAgIHRoaXMuZ3JpZC5hcHBlbmRDaGlsZChwYXJzZUhUTUwoY3JlYXRlVGFnUmVwZWF0KCdzcGFuJywgMTIsIHtcbiAgICAgICAgICAnZGF0YS1tb250aCc6IGZ1bmN0aW9uIGRhdGFNb250aChpeCkge1xuICAgICAgICAgICAgcmV0dXJuIGl4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE1vbnRoc1ZpZXcucHJvdG90eXBlKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5sb2NhbGUpIHtcbiAgICAgICAgdGhpcy5tb250aE5hbWVzID0gb3B0aW9ucy5sb2NhbGUubW9udGhzU2hvcnQ7XG4gICAgICB9XG4gICAgICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5taW5EYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm1pblllYXIgPSB0aGlzLm1pbk1vbnRoID0gdGhpcy5taW5EYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW5EYXRlT2JqID0gbmV3IERhdGUob3B0aW9ucy5taW5EYXRlKTtcbiAgICAgICAgICB0aGlzLm1pblllYXIgPSBtaW5EYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgdGhpcy5taW5Nb250aCA9IG1pbkRhdGVPYmouZ2V0TW9udGgoKTtcbiAgICAgICAgICB0aGlzLm1pbkRhdGUgPSBtaW5EYXRlT2JqLnNldERhdGUoMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMubWF4WWVhciA9IHRoaXMubWF4TW9udGggPSB0aGlzLm1heERhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1heERhdGVPYmogPSBuZXcgRGF0ZShvcHRpb25zLm1heERhdGUpO1xuICAgICAgICAgIHRoaXMubWF4WWVhciA9IG1heERhdGVPYmouZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICB0aGlzLm1heE1vbnRoID0gbWF4RGF0ZU9iai5nZXRNb250aCgpO1xuICAgICAgICAgIHRoaXMubWF4RGF0ZSA9IGRhdGVWYWx1ZSh0aGlzLm1heFllYXIsIHRoaXMubWF4TW9udGggKyAxLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlU2hvd01vbnRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVTaG93ID0gdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2hvd01vbnRoID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5iZWZvcmVTaG93TW9udGggOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpZXcncyBzZXR0aW5ncyB0byByZWZsZWN0IHRoZSB2aWV3RGF0ZSBzZXQgb24gdGhlIHBpY2tlclxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuICAgICAgdmFyIHZpZXdEYXRlID0gbmV3IERhdGUodGhpcy5waWNrZXIudmlld0RhdGUpO1xuICAgICAgdGhpcy55ZWFyID0gdmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHRoaXMuZm9jdXNlZCA9IHZpZXdEYXRlLmdldE1vbnRoKCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpZXcncyBzZXR0aW5ncyB0byByZWZsZWN0IHRoZSBzZWxlY3RlZCBkYXRlc1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMkcGlja2VyJGRhdGVwaWNrID0gdGhpcy5waWNrZXIuZGF0ZXBpY2tlcixcbiAgICAgICAgZGF0ZXMgPSBfdGhpcyRwaWNrZXIkZGF0ZXBpY2suZGF0ZXMsXG4gICAgICAgIHJhbmdlcGlja2VyID0gX3RoaXMkcGlja2VyJGRhdGVwaWNrLnJhbmdlcGlja2VyO1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGRhdGVzLnJlZHVjZShmdW5jdGlvbiAoc2VsZWN0ZWQsIHRpbWVWYWx1ZSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWVWYWx1ZSk7XG4gICAgICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICB2YXIgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIGlmIChzZWxlY3RlZFt5ZWFyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWRbeWVhcl0gPSBbbW9udGhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2hVbmlxdWUoc2VsZWN0ZWRbeWVhcl0sIG1vbnRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgICB9LCB7fSk7XG4gICAgICBpZiAocmFuZ2VwaWNrZXIgJiYgcmFuZ2VwaWNrZXIuZGF0ZXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlcGlja2VyLmRhdGVzLm1hcChmdW5jdGlvbiAodGltZVZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lVmFsdWUpO1xuICAgICAgICAgIHJldHVybiBpc05hTihkYXRlKSA/IHVuZGVmaW5lZCA6IFtkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZW50aXJlIHZpZXcgVUlcbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgbW9udGhzIG9uIGV2ZXJ5IHJlbmRlciBpbiBvcmRlciB0byBjbGVhciB0aGUgb25lcyBhZGRlZFxuICAgICAgLy8gYnkgYmVmb3JlU2hvdyBob29rIGF0IHByZXZpb3VzIHJlbmRlclxuICAgICAgdGhpcy5kaXNhYmxlZCA9IFtdO1xuICAgICAgdGhpcy5waWNrZXIuc2V0Vmlld1N3aXRjaExhYmVsKHRoaXMueWVhcik7XG4gICAgICB0aGlzLnBpY2tlci5zZXRQcmV2QnRuRGlzYWJsZWQodGhpcy55ZWFyIDw9IHRoaXMubWluWWVhcik7XG4gICAgICB0aGlzLnBpY2tlci5zZXROZXh0QnRuRGlzYWJsZWQodGhpcy55ZWFyID49IHRoaXMubWF4WWVhcik7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkW3RoaXMueWVhcl0gfHwgW107XG4gICAgICB2YXIgeXJPdXRPZlJhbmdlID0gdGhpcy55ZWFyIDwgdGhpcy5taW5ZZWFyIHx8IHRoaXMueWVhciA+IHRoaXMubWF4WWVhcjtcbiAgICAgIHZhciBpc01pblllYXIgPSB0aGlzLnllYXIgPT09IHRoaXMubWluWWVhcjtcbiAgICAgIHZhciBpc01heFllYXIgPSB0aGlzLnllYXIgPT09IHRoaXMubWF4WWVhcjtcbiAgICAgIHZhciByYW5nZSA9IGNvbXB1dGVNb250aFJhbmdlKHRoaXMucmFuZ2UsIHRoaXMueWVhcik7XG4gICAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICAgIHZhciBkYXRlID0gZGF0ZVZhbHVlKF90aGlzLnllYXIsIGluZGV4LCAxKTtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gXCJkYXRlcGlja2VyLWNlbGwgaG92ZXI6YmctZ3JheS0xMDAgZGFyazpob3ZlcjpiZy1ncmF5LTYwMCBibG9jayBmbGV4LTEgbGVhZGluZy05IGJvcmRlci0wIHJvdW5kZWQtbGcgY3Vyc29yLXBvaW50ZXIgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTkwMCBkYXJrOnRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0ZXh0LXNtIFwiLmNvbmNhdChfdGhpcy5jZWxsQ2xhc3MpO1xuICAgICAgICBpZiAoX3RoaXMuaXNNaW5WaWV3KSB7XG4gICAgICAgICAgZWwuZGF0YXNldC5kYXRlID0gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0ZXh0IG9uIGV2ZXJ5IHJlbmRlciB0byBjbGVhciB0aGUgY3VzdG9tIGNvbnRlbnQgc2V0XG4gICAgICAgIC8vIGJ5IGJlZm9yZVNob3cgaG9vayBhdCBwcmV2aW91cyByZW5kZXJcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSBfdGhpcy5tb250aE5hbWVzW2luZGV4XTtcbiAgICAgICAgaWYgKHlyT3V0T2ZSYW5nZSB8fCBpc01pblllYXIgJiYgaW5kZXggPCBfdGhpcy5taW5Nb250aCB8fCBpc01heFllYXIgJiYgaW5kZXggPiBfdGhpcy5tYXhNb250aCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgdmFyIF9yYW5nZTIgPSBfc2xpY2VkVG9BcnJheShyYW5nZSwgMiksXG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gX3JhbmdlMlswXSxcbiAgICAgICAgICAgIHJhbmdlRW5kID0gX3JhbmdlMlsxXTtcbiAgICAgICAgICBpZiAoaW5kZXggPiByYW5nZVN0YXJ0ICYmIGluZGV4IDwgcmFuZ2VFbmQpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZGV4ID09PSByYW5nZUVuZCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RlZC5pbmNsdWRlcyhpbmRleCkpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcsICdiZy1ibHVlLTcwMCcsICchYmctcHJpbWFyeS03MDAnLCAndGV4dC13aGl0ZScsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6IWJnLXByaW1hcnktNjAwJywgJ2Rhcms6dGV4dC13aGl0ZScpO1xuICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ3RleHQtZ3JheS05MDAnLCAnaG92ZXI6YmctZ3JheS0xMDAnLCAnZGFyazp0ZXh0LXdoaXRlJywgJ2Rhcms6aG92ZXI6YmctZ3JheS02MDAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IF90aGlzLmZvY3VzZWQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLmJlZm9yZVNob3cpIHtcbiAgICAgICAgICBfdGhpcy5wZXJmb3JtQmVmb3JlSG9vayhlbCwgaW5kZXgsIGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZXMgb2Ygc2VsZWN0ZWQgYW5kIGZvY3VzZWQgaXRlbXNcbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRbdGhpcy55ZWFyXSB8fCBbXTtcbiAgICAgIHZhciBfcmVmID0gY29tcHV0ZU1vbnRoUmFuZ2UodGhpcy5yYW5nZSwgdGhpcy55ZWFyKSB8fCBbXSxcbiAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcmFuZ2VTdGFydCA9IF9yZWYyWzBdLFxuICAgICAgICByYW5nZUVuZCA9IF9yZWYyWzFdO1xuICAgICAgdGhpcy5ncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYW5nZSwgLnJhbmdlLXN0YXJ0LCAucmFuZ2UtZW5kLCAuc2VsZWN0ZWQsIC5mb2N1c2VkJykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICdkYXJrOmJnLWJsdWUtNjAwJywgJ2Rhcms6IWJnLXByaW1hcnktNzAwJywgJ2Rhcms6dGV4dC13aGl0ZScsICd0ZXh0LXdoaXRlJywgJ2ZvY3VzZWQnKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgfSk7XG4gICAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICAgIGlmIChpbmRleCA+IHJhbmdlU3RhcnQgJiYgaW5kZXggPCByYW5nZUVuZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdGVkLmluY2x1ZGVzKGluZGV4KSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazohYmctcHJpbWFyeS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gX3RoaXMyLmZvY3VzZWQpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBVSSBieSBhcHBseWluZyB0aGUgY2hhbmdlIG9mIGZvY3VzZWQgaXRlbVxuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hGb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoRm9jdXMoKSB7XG4gICAgICB0aGlzLmdyaWQucXVlcnlTZWxlY3RvckFsbCgnLmZvY3VzZWQnKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmb2N1c2VkJyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JpZC5jaGlsZHJlblt0aGlzLmZvY3VzZWRdLmNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICB9XG4gIH1dKTtcbn0oVmlldyk7XG5cbmZ1bmN0aW9uIHRvVGl0bGVDYXNlKHdvcmQpIHtcbiAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheSh3b3JkKS5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgY2gsIGl4KSB7XG4gICAgcmV0dXJuIHN0ciArPSBpeCA/IGNoIDogY2gudG9VcHBlckNhc2UoKTtcbiAgfSwgJycpO1xufVxuXG4vLyBDbGFzcyByZXByZXNlbnRpbmcgdGhlIHllYXJzIGFuZCBkZWNhZGVzIHZpZXcgZWxlbWVudHNcbnZhciBZZWFyc1ZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9WaWV3KSB7XG4gIGZ1bmN0aW9uIFllYXJzVmlldyhwaWNrZXIsIGNvbmZpZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBZZWFyc1ZpZXcpO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIFllYXJzVmlldywgW3BpY2tlciwgY29uZmlnXSk7XG4gIH1cbiAgX2luaGVyaXRzKFllYXJzVmlldywgX1ZpZXcpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFllYXJzVmlldywgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KG9wdGlvbnMpIHtcbiAgICAgIHZhciBvbkNvbnN0cnVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIGlmIChvbkNvbnN0cnVjdGlvbikge1xuICAgICAgICB0aGlzLm5hdlN0ZXAgPSB0aGlzLnN0ZXAgKiAxMDtcbiAgICAgICAgdGhpcy5iZWZvcmVTaG93T3B0aW9uID0gXCJiZWZvcmVTaG93XCIuY29uY2F0KHRvVGl0bGVDYXNlKHRoaXMuY2VsbENsYXNzKSk7XG4gICAgICAgIHRoaXMuZ3JpZCA9IHRoaXMuZWxlbWVudDtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5uYW1lLCAnZGF0ZXBpY2tlci1ncmlkJywgJ3ctNjQnLCAnZ3JpZCcsICdncmlkLWNvbHMtNCcpO1xuICAgICAgICB0aGlzLmdyaWQuYXBwZW5kQ2hpbGQocGFyc2VIVE1MKGNyZWF0ZVRhZ1JlcGVhdCgnc3BhbicsIDEyKSkpO1xuICAgICAgfVxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoWWVhcnNWaWV3LnByb3RvdHlwZSksIFwiaW5pdFwiLCB0aGlzKS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtaW5EYXRlJykpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWluRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5taW5ZZWFyID0gdGhpcy5taW5EYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWluWWVhciA9IHN0YXJ0T2ZZZWFyUGVyaW9kKG9wdGlvbnMubWluRGF0ZSwgdGhpcy5zdGVwKTtcbiAgICAgICAgICB0aGlzLm1pbkRhdGUgPSBkYXRlVmFsdWUodGhpcy5taW5ZZWFyLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc1Byb3BlcnR5KG9wdGlvbnMsICdtYXhEYXRlJykpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5tYXhZZWFyID0gdGhpcy5tYXhEYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWF4WWVhciA9IHN0YXJ0T2ZZZWFyUGVyaW9kKG9wdGlvbnMubWF4RGF0ZSwgdGhpcy5zdGVwKTtcbiAgICAgICAgICB0aGlzLm1heERhdGUgPSBkYXRlVmFsdWUodGhpcy5tYXhZZWFyLCAxMSwgMzEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uc1t0aGlzLmJlZm9yZVNob3dPcHRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGJlZm9yZVNob3cgPSBvcHRpb25zW3RoaXMuYmVmb3JlU2hvd09wdGlvbl07XG4gICAgICAgIHRoaXMuYmVmb3JlU2hvdyA9IHR5cGVvZiBiZWZvcmVTaG93ID09PSAnZnVuY3Rpb24nID8gYmVmb3JlU2hvdyA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlldydzIHNldHRpbmdzIHRvIHJlZmxlY3QgdGhlIHZpZXdEYXRlIHNldCBvbiB0aGUgcGlja2VyXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG4gICAgICB2YXIgdmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnBpY2tlci52aWV3RGF0ZSk7XG4gICAgICB2YXIgZmlyc3QgPSBzdGFydE9mWWVhclBlcmlvZCh2aWV3RGF0ZSwgdGhpcy5uYXZTdGVwKTtcbiAgICAgIHZhciBsYXN0ID0gZmlyc3QgKyA5ICogdGhpcy5zdGVwO1xuICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgICAgdGhpcy5sYXN0ID0gbGFzdDtcbiAgICAgIHRoaXMuc3RhcnQgPSBmaXJzdCAtIHRoaXMuc3RlcDtcbiAgICAgIHRoaXMuZm9jdXNlZCA9IHN0YXJ0T2ZZZWFyUGVyaW9kKHZpZXdEYXRlLCB0aGlzLnN0ZXApO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3J3Mgc2V0dGluZ3MgdG8gcmVmbGVjdCB0aGUgc2VsZWN0ZWQgZGF0ZXNcbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwaWNrZXIkZGF0ZXBpY2sgPSB0aGlzLnBpY2tlci5kYXRlcGlja2VyLFxuICAgICAgICBkYXRlcyA9IF90aGlzJHBpY2tlciRkYXRlcGljay5kYXRlcyxcbiAgICAgICAgcmFuZ2VwaWNrZXIgPSBfdGhpcyRwaWNrZXIkZGF0ZXBpY2sucmFuZ2VwaWNrZXI7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZGF0ZXMucmVkdWNlKGZ1bmN0aW9uICh5ZWFycywgdGltZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwdXNoVW5pcXVlKHllYXJzLCBzdGFydE9mWWVhclBlcmlvZCh0aW1lVmFsdWUsIF90aGlzLnN0ZXApKTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIGlmIChyYW5nZXBpY2tlciAmJiByYW5nZXBpY2tlci5kYXRlcykge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2VwaWNrZXIuZGF0ZXMubWFwKGZ1bmN0aW9uICh0aW1lVmFsdWUpIHtcbiAgICAgICAgICBpZiAodGltZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mWWVhclBlcmlvZCh0aW1lVmFsdWUsIF90aGlzLnN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBlbnRpcmUgdmlldyBVSVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIC8vIHJlZnJlc2ggZGlzYWJsZWQgeWVhcnMgb24gZXZlcnkgcmVuZGVyIGluIG9yZGVyIHRvIGNsZWFyIHRoZSBvbmVzIGFkZGVkXG4gICAgICAvLyBieSBiZWZvcmVTaG93IGhvb2sgYXQgcHJldmlvdXMgcmVuZGVyXG4gICAgICB0aGlzLmRpc2FibGVkID0gW107XG4gICAgICB0aGlzLnBpY2tlci5zZXRWaWV3U3dpdGNoTGFiZWwoXCJcIi5jb25jYXQodGhpcy5maXJzdCwgXCItXCIpLmNvbmNhdCh0aGlzLmxhc3QpKTtcbiAgICAgIHRoaXMucGlja2VyLnNldFByZXZCdG5EaXNhYmxlZCh0aGlzLmZpcnN0IDw9IHRoaXMubWluWWVhcik7XG4gICAgICB0aGlzLnBpY2tlci5zZXROZXh0QnRuRGlzYWJsZWQodGhpcy5sYXN0ID49IHRoaXMubWF4WWVhcik7XG4gICAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICAgIHZhciBjbGFzc0xpc3QgPSBlbC5jbGFzc0xpc3Q7XG4gICAgICAgIHZhciBjdXJyZW50ID0gX3RoaXMyLnN0YXJ0ICsgaW5kZXggKiBfdGhpczIuc3RlcDtcbiAgICAgICAgdmFyIGRhdGUgPSBkYXRlVmFsdWUoY3VycmVudCwgMCwgMSk7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IFwiZGF0ZXBpY2tlci1jZWxsIGhvdmVyOmJnLWdyYXktMTAwIGRhcms6aG92ZXI6YmctZ3JheS02MDAgYmxvY2sgZmxleC0xIGxlYWRpbmctOSBib3JkZXItMCByb3VuZGVkLWxnIGN1cnNvci1wb2ludGVyIHRleHQtY2VudGVyIHRleHQtZ3JheS05MDAgZGFyazp0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdGV4dC1zbSBcIi5jb25jYXQoX3RoaXMyLmNlbGxDbGFzcyk7XG4gICAgICAgIGlmIChfdGhpczIuaXNNaW5WaWV3KSB7XG4gICAgICAgICAgZWwuZGF0YXNldC5kYXRlID0gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbC50ZXh0Q29udGVudCA9IGVsLmRhdGFzZXQueWVhciA9IGN1cnJlbnQ7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3ByZXYnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMTEpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCduZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPCBfdGhpczIubWluWWVhciB8fCBjdXJyZW50ID4gX3RoaXMyLm1heFllYXIpIHtcbiAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczIucmFuZ2UpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyJHJhbmdlID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMyLnJhbmdlLCAyKSxcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBfdGhpczIkcmFuZ2VbMF0sXG4gICAgICAgICAgICByYW5nZUVuZCA9IF90aGlzMiRyYW5nZVsxXTtcbiAgICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2Utc3RhcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKCdyYW5nZS1lbmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMi5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazohYmctcHJpbWFyeS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBfdGhpczIuZm9jdXNlZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMyLmJlZm9yZVNob3cpIHtcbiAgICAgICAgICBfdGhpczIucGVyZm9ybUJlZm9yZUhvb2soZWwsIGN1cnJlbnQsIGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHZpZXcgVUkgYnkgYXBwbHlpbmcgdGhlIGNoYW5nZXMgb2Ygc2VsZWN0ZWQgYW5kIGZvY3VzZWQgaXRlbXNcbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBfcmVmID0gdGhpcy5yYW5nZSB8fCBbXSxcbiAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgcmFuZ2VTdGFydCA9IF9yZWYyWzBdLFxuICAgICAgICByYW5nZUVuZCA9IF9yZWYyWzFdO1xuICAgICAgdGhpcy5ncmlkLnF1ZXJ5U2VsZWN0b3JBbGwoJy5yYW5nZSwgLnJhbmdlLXN0YXJ0LCAucmFuZ2UtZW5kLCAuc2VsZWN0ZWQsIC5mb2N1c2VkJykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UnLCAncmFuZ2Utc3RhcnQnLCAncmFuZ2UtZW5kJywgJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyayFiZy1wcmltYXJ5LTYwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZm9jdXNlZCcpO1xuICAgICAgfSk7XG4gICAgICBBcnJheS5mcm9tKHRoaXMuZ3JpZC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBOdW1iZXIoZWwudGV4dENvbnRlbnQpO1xuICAgICAgICB2YXIgY2xhc3NMaXN0ID0gZWwuY2xhc3NMaXN0O1xuICAgICAgICBpZiAoY3VycmVudCA+IHJhbmdlU3RhcnQgJiYgY3VycmVudCA8IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3JhbmdlLXN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgY2xhc3NMaXN0LmFkZCgncmFuZ2UtZW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMy5zZWxlY3RlZC5pbmNsdWRlcyhjdXJyZW50KSkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJywgJ2JnLWJsdWUtNzAwJywgJyFiZy1wcmltYXJ5LTcwMCcsICd0ZXh0LXdoaXRlJywgJ2Rhcms6YmctYmx1ZS02MDAnLCAnZGFyazohYmctcHJpbWFyeS02MDAnLCAnZGFyazp0ZXh0LXdoaXRlJyk7XG4gICAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSgndGV4dC1ncmF5LTkwMCcsICdob3ZlcjpiZy1ncmF5LTEwMCcsICdkYXJrOnRleHQtd2hpdGUnLCAnZGFyazpob3ZlcjpiZy1ncmF5LTYwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBfdGhpczMuZm9jdXNlZCkge1xuICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2ZvY3VzZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSB2aWV3IFVJIGJ5IGFwcGx5aW5nIHRoZSBjaGFuZ2Ugb2YgZm9jdXNlZCBpdGVtXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaEZvY3VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2hGb2N1cygpIHtcbiAgICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQoKHRoaXMuZm9jdXNlZCAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwKTtcbiAgICAgIHRoaXMuZ3JpZC5xdWVyeVNlbGVjdG9yQWxsKCcuZm9jdXNlZCcpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvY3VzZWQnKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncmlkLmNoaWxkcmVuW2luZGV4XS5jbGFzc0xpc3QuYWRkKCdmb2N1c2VkJyk7XG4gICAgfVxuICB9XSk7XG59KFZpZXcpO1xuXG5mdW5jdGlvbiB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KGRhdGVwaWNrZXIsIHR5cGUpIHtcbiAgdmFyIGRldGFpbCA9IHtcbiAgICBkYXRlOiBkYXRlcGlja2VyLmdldERhdGUoKSxcbiAgICB2aWV3RGF0ZTogbmV3IERhdGUoZGF0ZXBpY2tlci5waWNrZXIudmlld0RhdGUpLFxuICAgIHZpZXdJZDogZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcuaWQsXG4gICAgZGF0ZXBpY2tlcjogZGF0ZXBpY2tlclxuICB9O1xuICBkYXRlcGlja2VyLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgIGRldGFpbDogZGV0YWlsXG4gIH0pKTtcbn1cblxuLy8gZGlyZWN0aW9uOiAtMSAodG8gcHJldmlvdXMpLCAxICh0byBuZXh0KVxuZnVuY3Rpb24gZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgZGlyZWN0aW9uKSB7XG4gIHZhciBfZGF0ZXBpY2tlciRjb25maWcgPSBkYXRlcGlja2VyLmNvbmZpZyxcbiAgICBtaW5EYXRlID0gX2RhdGVwaWNrZXIkY29uZmlnLm1pbkRhdGUsXG4gICAgbWF4RGF0ZSA9IF9kYXRlcGlja2VyJGNvbmZpZy5tYXhEYXRlO1xuICB2YXIgX2RhdGVwaWNrZXIkcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXIsXG4gICAgY3VycmVudFZpZXcgPSBfZGF0ZXBpY2tlciRwaWNrZXIuY3VycmVudFZpZXcsXG4gICAgdmlld0RhdGUgPSBfZGF0ZXBpY2tlciRwaWNrZXIudmlld0RhdGU7XG4gIHZhciBuZXdWaWV3RGF0ZTtcbiAgc3dpdGNoIChjdXJyZW50Vmlldy5pZCkge1xuICAgIGNhc2UgMDpcbiAgICAgIG5ld1ZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgbmV3Vmlld0RhdGUgPSBhZGRZZWFycyh2aWV3RGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBuZXdWaWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiBjdXJyZW50Vmlldy5uYXZTdGVwKTtcbiAgfVxuICBuZXdWaWV3RGF0ZSA9IGxpbWl0VG9SYW5nZShuZXdWaWV3RGF0ZSwgbWluRGF0ZSwgbWF4RGF0ZSk7XG4gIGRhdGVwaWNrZXIucGlja2VyLmNoYW5nZUZvY3VzKG5ld1ZpZXdEYXRlKS5yZW5kZXIoKTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcikge1xuICB2YXIgdmlld0lkID0gZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcuaWQ7XG4gIGlmICh2aWV3SWQgPT09IGRhdGVwaWNrZXIuY29uZmlnLm1heFZpZXcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGF0ZXBpY2tlci5waWNrZXIuY2hhbmdlVmlldyh2aWV3SWQgKyAxKS5yZW5kZXIoKTtcbn1cbmZ1bmN0aW9uIHVuZm9jdXMoZGF0ZXBpY2tlcikge1xuICBpZiAoZGF0ZXBpY2tlci5jb25maWcudXBkYXRlT25CbHVyKSB7XG4gICAgZGF0ZXBpY2tlci51cGRhdGUoe1xuICAgICAgYXV0b2hpZGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkYXRlcGlja2VyLnJlZnJlc2goJ2lucHV0Jyk7XG4gICAgZGF0ZXBpY2tlci5oaWRlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgc2VsZWN0aW9uKSB7XG4gIHZhciBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcbiAgdmFyIHZpZXdEYXRlID0gbmV3IERhdGUocGlja2VyLnZpZXdEYXRlKTtcbiAgdmFyIHZpZXdJZCA9IHBpY2tlci5jdXJyZW50Vmlldy5pZDtcbiAgdmFyIG5ld0RhdGUgPSB2aWV3SWQgPT09IDEgPyBhZGRNb250aHModmlld0RhdGUsIHNlbGVjdGlvbiAtIHZpZXdEYXRlLmdldE1vbnRoKCkpIDogYWRkWWVhcnModmlld0RhdGUsIHNlbGVjdGlvbiAtIHZpZXdEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICBwaWNrZXIuY2hhbmdlRm9jdXMobmV3RGF0ZSkuY2hhbmdlVmlldyh2aWV3SWQgLSAxKS5yZW5kZXIoKTtcbn1cbmZ1bmN0aW9uIG9uQ2xpY2tUb2RheUJ0bihkYXRlcGlja2VyKSB7XG4gIHZhciBwaWNrZXIgPSBkYXRlcGlja2VyLnBpY2tlcjtcbiAgdmFyIGN1cnJlbnREYXRlID0gdG9kYXkoKTtcbiAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLnRvZGF5QnRuTW9kZSA9PT0gMSkge1xuICAgIGlmIChkYXRlcGlja2VyLmNvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0ZXBpY2tlci5zZXREYXRlKGN1cnJlbnREYXRlLCB7XG4gICAgICByZW5kZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgcGlja2VyLnVwZGF0ZSgpO1xuICB9XG4gIGlmIChwaWNrZXIudmlld0RhdGUgIT09IGN1cnJlbnREYXRlKSB7XG4gICAgcGlja2VyLmNoYW5nZUZvY3VzKGN1cnJlbnREYXRlKTtcbiAgfVxuICBwaWNrZXIuY2hhbmdlVmlldygwKS5yZW5kZXIoKTtcbn1cbmZ1bmN0aW9uIG9uQ2xpY2tDbGVhckJ0bihkYXRlcGlja2VyKSB7XG4gIGRhdGVwaWNrZXIuc2V0RGF0ZSh7XG4gICAgY2xlYXI6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBvbkNsaWNrVmlld1N3aXRjaChkYXRlcGlja2VyKSB7XG4gIHN3aXRjaFZpZXcoZGF0ZXBpY2tlcik7XG59XG5mdW5jdGlvbiBvbkNsaWNrUHJldkJ0bihkYXRlcGlja2VyKSB7XG4gIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIC0xKTtcbn1cbmZ1bmN0aW9uIG9uQ2xpY2tOZXh0QnRuKGRhdGVwaWNrZXIpIHtcbiAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgMSk7XG59XG5cbi8vIEZvciB0aGUgcGlja2VyJ3MgbWFpbiBibG9jayB0byBkZWxlZ2V0ZSB0aGUgZXZlbnRzIGZyb20gYGRhdGVwaWNrZXItY2VsbGBzXG5mdW5jdGlvbiBvbkNsaWNrVmlldyhkYXRlcGlja2VyLCBldikge1xuICB2YXIgdGFyZ2V0ID0gZmluZEVsZW1lbnRJbkV2ZW50UGF0aChldiwgJy5kYXRlcGlja2VyLWNlbGwnKTtcbiAgaWYgKCF0YXJnZXQgfHwgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgX2RhdGVwaWNrZXIkcGlja2VyJGN1ID0gZGF0ZXBpY2tlci5waWNrZXIuY3VycmVudFZpZXcsXG4gICAgaWQgPSBfZGF0ZXBpY2tlciRwaWNrZXIkY3UuaWQsXG4gICAgaXNNaW5WaWV3ID0gX2RhdGVwaWNrZXIkcGlja2VyJGN1LmlzTWluVmlldztcbiAgaWYgKGlzTWluVmlldykge1xuICAgIGRhdGVwaWNrZXIuc2V0RGF0ZShOdW1iZXIodGFyZ2V0LmRhdGFzZXQuZGF0ZSkpO1xuICB9IGVsc2UgaWYgKGlkID09PSAxKSB7XG4gICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0Lm1vbnRoKSk7XG4gIH0gZWxzZSB7XG4gICAgZ29Ub1NlbGVjdGVkTW9udGhPclllYXIoZGF0ZXBpY2tlciwgTnVtYmVyKHRhcmdldC5kYXRhc2V0LnllYXIpKTtcbiAgfVxufVxuZnVuY3Rpb24gb25DbGlja1BpY2tlcihkYXRlcGlja2VyKSB7XG4gIGlmICghZGF0ZXBpY2tlci5pbmxpbmUgJiYgIWRhdGVwaWNrZXIuY29uZmlnLmRpc2FibGVUb3VjaEtleWJvYXJkKSB7XG4gICAgZGF0ZXBpY2tlci5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1BpY2tlck9wdGlvbnMocGlja2VyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgcGlja2VyLmNvbnRyb2xzLnRpdGxlLnRleHRDb250ZW50ID0gb3B0aW9ucy50aXRsZTtcbiAgICAgIHNob3dFbGVtZW50KHBpY2tlci5jb250cm9scy50aXRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpY2tlci5jb250cm9scy50aXRsZS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLnRpdGxlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJldkFycm93KSB7XG4gICAgdmFyIHByZXZCdG4gPSBwaWNrZXIuY29udHJvbHMucHJldkJ0bjtcbiAgICBlbXB0eUNoaWxkTm9kZXMocHJldkJ0bik7XG4gICAgb3B0aW9ucy5wcmV2QXJyb3cuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcHJldkJ0bi5hcHBlbmRDaGlsZChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubmV4dEFycm93KSB7XG4gICAgdmFyIG5leHRCdG4gPSBwaWNrZXIuY29udHJvbHMubmV4dEJ0bjtcbiAgICBlbXB0eUNoaWxkTm9kZXMobmV4dEJ0bik7XG4gICAgb3B0aW9ucy5uZXh0QXJyb3cuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbmV4dEJ0bi5hcHBlbmRDaGlsZChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMubG9jYWxlKSB7XG4gICAgcGlja2VyLmNvbnRyb2xzLnRvZGF5QnRuLnRleHRDb250ZW50ID0gb3B0aW9ucy5sb2NhbGUudG9kYXk7XG4gICAgcGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuLnRleHRDb250ZW50ID0gb3B0aW9ucy5sb2NhbGUuY2xlYXI7XG4gIH1cbiAgaWYgKG9wdGlvbnMudG9kYXlCdG4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnRvZGF5QnRuKSB7XG4gICAgICBzaG93RWxlbWVudChwaWNrZXIuY29udHJvbHMudG9kYXlCdG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWRlRWxlbWVudChwaWNrZXIuY29udHJvbHMudG9kYXlCdG4pO1xuICAgIH1cbiAgfVxuICBpZiAoaGFzUHJvcGVydHkob3B0aW9ucywgJ21pbkRhdGUnKSB8fCBoYXNQcm9wZXJ0eShvcHRpb25zLCAnbWF4RGF0ZScpKSB7XG4gICAgdmFyIF9waWNrZXIkZGF0ZXBpY2tlciRjbyA9IHBpY2tlci5kYXRlcGlja2VyLmNvbmZpZyxcbiAgICAgIG1pbkRhdGUgPSBfcGlja2VyJGRhdGVwaWNrZXIkY28ubWluRGF0ZSxcbiAgICAgIG1heERhdGUgPSBfcGlja2VyJGRhdGVwaWNrZXIkY28ubWF4RGF0ZTtcbiAgICBwaWNrZXIuY29udHJvbHMudG9kYXlCdG4uZGlzYWJsZWQgPSAhaXNJblJhbmdlKHRvZGF5KCksIG1pbkRhdGUsIG1heERhdGUpO1xuICB9XG4gIGlmIChvcHRpb25zLmNsZWFyQnRuICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5jbGVhckJ0bikge1xuICAgICAgc2hvd0VsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZUVsZW1lbnQocGlja2VyLmNvbnRyb2xzLmNsZWFyQnRuKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQ29tcHV0ZSB2aWV3IGRhdGUgdG8gcmVzZXQsIHdoaWNoIHdpbGwgYmUuLi5cbi8vIC0gdGhlIGxhc3QgaXRlbSBvZiB0aGUgc2VsZWN0ZWQgZGF0ZXMgb3IgZGVmYXVsdFZpZXdEYXRlIGlmIG5vIHNlbGVjdGlvblxuLy8gLSBsaW1pdHRlZCB0byBtaW5EYXRlIG9yIG1heERhdGUgaWYgaXQgZXhjZWVkcyB0aGUgcmFuZ2VcbmZ1bmN0aW9uIGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpIHtcbiAgdmFyIGRhdGVzID0gZGF0ZXBpY2tlci5kYXRlcyxcbiAgICBjb25maWcgPSBkYXRlcGlja2VyLmNvbmZpZztcbiAgdmFyIHZpZXdEYXRlID0gZGF0ZXMubGVuZ3RoID4gMCA/IGxhc3RJdGVtT2YoZGF0ZXMpIDogY29uZmlnLmRlZmF1bHRWaWV3RGF0ZTtcbiAgcmV0dXJuIGxpbWl0VG9SYW5nZSh2aWV3RGF0ZSwgY29uZmlnLm1pbkRhdGUsIGNvbmZpZy5tYXhEYXRlKTtcbn1cblxuLy8gQ2hhbmdlIGN1cnJlbnQgdmlldydzIHZpZXcgZGF0ZVxuZnVuY3Rpb24gc2V0Vmlld0RhdGUocGlja2VyLCBuZXdEYXRlKSB7XG4gIHZhciBvbGRWaWV3RGF0ZSA9IG5ldyBEYXRlKHBpY2tlci52aWV3RGF0ZSk7XG4gIHZhciBuZXdWaWV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUpO1xuICB2YXIgX3BpY2tlciRjdXJyZW50VmlldyA9IHBpY2tlci5jdXJyZW50VmlldyxcbiAgICBpZCA9IF9waWNrZXIkY3VycmVudFZpZXcuaWQsXG4gICAgeWVhciA9IF9waWNrZXIkY3VycmVudFZpZXcueWVhcixcbiAgICBmaXJzdCA9IF9waWNrZXIkY3VycmVudFZpZXcuZmlyc3QsXG4gICAgbGFzdCA9IF9waWNrZXIkY3VycmVudFZpZXcubGFzdDtcbiAgdmFyIHZpZXdZZWFyID0gbmV3Vmlld0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgcGlja2VyLnZpZXdEYXRlID0gbmV3RGF0ZTtcbiAgaWYgKHZpZXdZZWFyICE9PSBvbGRWaWV3RGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudChwaWNrZXIuZGF0ZXBpY2tlciwgJ2NoYW5nZVllYXInKTtcbiAgfVxuICBpZiAobmV3Vmlld0RhdGUuZ2V0TW9udGgoKSAhPT0gb2xkVmlld0RhdGUuZ2V0TW9udGgoKSkge1xuICAgIHRyaWdnZXJEYXRlcGlja2VyRXZlbnQocGlja2VyLmRhdGVwaWNrZXIsICdjaGFuZ2VNb250aCcpO1xuICB9XG5cbiAgLy8gcmV0dXJuIHdoZXRoZXIgdGhlIG5ldyBkYXRlIGlzIGluIGRpZmZlcmVudCBwZXJpb2Qgb24gdGltZSBmcm9tIHRoZSBvbmVcbiAgLy8gZGlzcGxheWVkIGluIHRoZSBjdXJyZW50IHZpZXdcbiAgLy8gd2hlbiB0cnVlLCB0aGUgdmlldyBuZWVkcyB0byBiZSByZS1yZW5kZXJlZCBvbiB0aGUgbmV4dCBVSSByZWZyZXNoLlxuICBzd2l0Y2ggKGlkKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIG5ld0RhdGUgPCBmaXJzdCB8fCBuZXdEYXRlID4gbGFzdDtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gdmlld1llYXIgIT09IHllYXI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2aWV3WWVhciA8IGZpcnN0IHx8IHZpZXdZZWFyID4gbGFzdDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGV4dERpcmVjdGlvbihlbCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLmRpcmVjdGlvbjtcbn1cblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBwaWNrZXIgVUlcbnZhciBQaWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQaWNrZXIoZGF0ZXBpY2tlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaWNrZXIpO1xuICAgIHRoaXMuZGF0ZXBpY2tlciA9IGRhdGVwaWNrZXI7XG4gICAgdmFyIHRlbXBsYXRlID0gcGlja2VyVGVtcGxhdGUucmVwbGFjZSgvJWJ1dHRvbkNsYXNzJS9nLCBkYXRlcGlja2VyLmNvbmZpZy5idXR0b25DbGFzcyk7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQgPSBwYXJzZUhUTUwodGVtcGxhdGUpLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIF9lbGVtZW50JGZpcnN0Q2hpbGQkYyA9IF9zbGljZWRUb0FycmF5KGVsZW1lbnQuZmlyc3RDaGlsZC5jaGlsZHJlbiwgMyksXG4gICAgICBoZWFkZXIgPSBfZWxlbWVudCRmaXJzdENoaWxkJGNbMF0sXG4gICAgICBtYWluID0gX2VsZW1lbnQkZmlyc3RDaGlsZCRjWzFdLFxuICAgICAgZm9vdGVyID0gX2VsZW1lbnQkZmlyc3RDaGlsZCRjWzJdO1xuICAgIHZhciB0aXRsZSA9IGhlYWRlci5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB2YXIgX2hlYWRlciRsYXN0RWxlbWVudENoID0gX3NsaWNlZFRvQXJyYXkoaGVhZGVyLmxhc3RFbGVtZW50Q2hpbGQuY2hpbGRyZW4sIDMpLFxuICAgICAgcHJldkJ0biA9IF9oZWFkZXIkbGFzdEVsZW1lbnRDaFswXSxcbiAgICAgIHZpZXdTd2l0Y2ggPSBfaGVhZGVyJGxhc3RFbGVtZW50Q2hbMV0sXG4gICAgICBuZXh0QnRuID0gX2hlYWRlciRsYXN0RWxlbWVudENoWzJdO1xuICAgIHZhciBfZm9vdGVyJGZpcnN0Q2hpbGQkY2ggPSBfc2xpY2VkVG9BcnJheShmb290ZXIuZmlyc3RDaGlsZC5jaGlsZHJlbiwgMiksXG4gICAgICB0b2RheUJ0biA9IF9mb290ZXIkZmlyc3RDaGlsZCRjaFswXSxcbiAgICAgIGNsZWFyQnRuID0gX2Zvb3RlciRmaXJzdENoaWxkJGNoWzFdO1xuICAgIHZhciBjb250cm9scyA9IHtcbiAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgIHByZXZCdG46IHByZXZCdG4sXG4gICAgICB2aWV3U3dpdGNoOiB2aWV3U3dpdGNoLFxuICAgICAgbmV4dEJ0bjogbmV4dEJ0bixcbiAgICAgIHRvZGF5QnRuOiB0b2RheUJ0bixcbiAgICAgIGNsZWFyQnRuOiBjbGVhckJ0blxuICAgIH07XG4gICAgdGhpcy5tYWluID0gbWFpbjtcbiAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgdmFyIGVsZW1lbnRDbGFzcyA9IGRhdGVwaWNrZXIuaW5saW5lID8gJ2lubGluZScgOiAnZHJvcGRvd24nO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRhdGVwaWNrZXItXCIuY29uY2F0KGVsZW1lbnRDbGFzcykpO1xuICAgIGVsZW1lbnRDbGFzcyA9PT0gJ2Ryb3Bkb3duJyA/IGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZHJvcGRvd24nLCAnYWJzb2x1dGUnLCAndG9wLTAnLCAnbGVmdC0wJywgJ3otNTAnLCAncHQtMicpIDogbnVsbDtcbiAgICBwcm9jZXNzUGlja2VyT3B0aW9ucyh0aGlzLCBkYXRlcGlja2VyLmNvbmZpZyk7XG4gICAgdGhpcy52aWV3RGF0ZSA9IGNvbXB1dGVSZXNldFZpZXdEYXRlKGRhdGVwaWNrZXIpO1xuXG4gICAgLy8gc2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgIHJlZ2lzdGVyTGlzdGVuZXJzKGRhdGVwaWNrZXIsIFtbZWxlbWVudCwgJ2NsaWNrJywgb25DbGlja1BpY2tlci5iaW5kKG51bGwsIGRhdGVwaWNrZXIpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfV0sIFttYWluLCAnY2xpY2snLCBvbkNsaWNrVmlldy5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSwgW2NvbnRyb2xzLnZpZXdTd2l0Y2gsICdjbGljaycsIG9uQ2xpY2tWaWV3U3dpdGNoLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildLCBbY29udHJvbHMucHJldkJ0biwgJ2NsaWNrJywgb25DbGlja1ByZXZCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sIFtjb250cm9scy5uZXh0QnRuLCAnY2xpY2snLCBvbkNsaWNrTmV4dEJ0bi5iaW5kKG51bGwsIGRhdGVwaWNrZXIpXSwgW2NvbnRyb2xzLnRvZGF5QnRuLCAnY2xpY2snLCBvbkNsaWNrVG9kYXlCdG4uYmluZChudWxsLCBkYXRlcGlja2VyKV0sIFtjb250cm9scy5jbGVhckJ0biwgJ2NsaWNrJywgb25DbGlja0NsZWFyQnRuLmJpbmQobnVsbCwgZGF0ZXBpY2tlcildXSk7XG5cbiAgICAvLyBzZXQgdXAgdmlld3NcbiAgICB0aGlzLnZpZXdzID0gW25ldyBEYXlzVmlldyh0aGlzKSwgbmV3IE1vbnRoc1ZpZXcodGhpcyksIG5ldyBZZWFyc1ZpZXcodGhpcywge1xuICAgICAgaWQ6IDIsXG4gICAgICBuYW1lOiAneWVhcnMnLFxuICAgICAgY2VsbENsYXNzOiAneWVhcicsXG4gICAgICBzdGVwOiAxXG4gICAgfSksIG5ldyBZZWFyc1ZpZXcodGhpcywge1xuICAgICAgaWQ6IDMsXG4gICAgICBuYW1lOiAnZGVjYWRlcycsXG4gICAgICBjZWxsQ2xhc3M6ICdkZWNhZGUnLFxuICAgICAgc3RlcDogMTBcbiAgICB9KV07XG4gICAgdGhpcy5jdXJyZW50VmlldyA9IHRoaXMudmlld3NbZGF0ZXBpY2tlci5jb25maWcuc3RhcnRWaWV3XTtcbiAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xuICAgIHRoaXMubWFpbi5hcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRWaWV3LmVsZW1lbnQpO1xuICAgIGRhdGVwaWNrZXIuY29uZmlnLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUGlja2VyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgcHJvY2Vzc1BpY2tlck9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgdmlldy5pbml0KG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5yZW5kZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0YWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlci5jb25maWcuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJywgJ2Jsb2NrJyk7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICB2YXIgZGF0ZXBpY2tlciA9IHRoaXMuZGF0ZXBpY2tlcjtcbiAgICAgIGlmICghZGF0ZXBpY2tlci5pbmxpbmUpIHtcbiAgICAgICAgLy8gZW5zdXJlIHBpY2tlcidzIGRpcmVjdGlvbiBtYXRjaGVzIGlucHV0J3NcbiAgICAgICAgdmFyIGlucHV0RGlyZWN0aW9uID0gZ2V0VGV4dERpcmVjdGlvbihkYXRlcGlja2VyLmlucHV0RmllbGQpO1xuICAgICAgICBpZiAoaW5wdXREaXJlY3Rpb24gIT09IGdldFRleHREaXJlY3Rpb24oZGF0ZXBpY2tlci5jb25maWcuY29udGFpbmVyKSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5kaXIgPSBpbnB1dERpcmVjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuZGlyKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGFjZSgpO1xuICAgICAgICBpZiAoZGF0ZXBpY2tlci5jb25maWcuZGlzYWJsZVRvdWNoS2V5Ym9hcmQpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmlucHV0RmllbGQuYmx1cigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KGRhdGVwaWNrZXIsICdzaG93Jyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRlcGlja2VyLmV4aXRFZGl0TW9kZSgpO1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScsICdibG9jaycpO1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScsICdibG9jaycsICdoaWRkZW4nKTtcbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KHRoaXMuZGF0ZXBpY2tlciwgJ2hpZGUnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGxhY2UoKSB7XG4gICAgICB2YXIgX3RoaXMkZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgY2xhc3NMaXN0ID0gX3RoaXMkZWxlbWVudC5jbGFzc0xpc3QsXG4gICAgICAgIHN0eWxlID0gX3RoaXMkZWxlbWVudC5zdHlsZTtcbiAgICAgIHZhciBfdGhpcyRkYXRlcGlja2VyID0gdGhpcy5kYXRlcGlja2VyLFxuICAgICAgICBjb25maWcgPSBfdGhpcyRkYXRlcGlja2VyLmNvbmZpZyxcbiAgICAgICAgaW5wdXRGaWVsZCA9IF90aGlzJGRhdGVwaWNrZXIuaW5wdXRGaWVsZDtcbiAgICAgIHZhciBjb250YWluZXIgPSBjb25maWcuY29udGFpbmVyO1xuICAgICAgdmFyIF90aGlzJGVsZW1lbnQkZ2V0Qm91biA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgY2FsZW5kYXJXaWR0aCA9IF90aGlzJGVsZW1lbnQkZ2V0Qm91bi53aWR0aCxcbiAgICAgICAgY2FsZW5kYXJIZWlnaHQgPSBfdGhpcyRlbGVtZW50JGdldEJvdW4uaGVpZ2h0O1xuICAgICAgdmFyIF9jb250YWluZXIkZ2V0Qm91bmRpbiA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgY29udGFpbmVyTGVmdCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbi5sZWZ0LFxuICAgICAgICBjb250YWluZXJUb3AgPSBfY29udGFpbmVyJGdldEJvdW5kaW4udG9wLFxuICAgICAgICBjb250YWluZXJXaWR0aCA9IF9jb250YWluZXIkZ2V0Qm91bmRpbi53aWR0aDtcbiAgICAgIHZhciBfaW5wdXRGaWVsZCRnZXRCb3VuZGkgPSBpbnB1dEZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBpbnB1dExlZnQgPSBfaW5wdXRGaWVsZCRnZXRCb3VuZGkubGVmdCxcbiAgICAgICAgaW5wdXRUb3AgPSBfaW5wdXRGaWVsZCRnZXRCb3VuZGkudG9wLFxuICAgICAgICBpbnB1dFdpZHRoID0gX2lucHV0RmllbGQkZ2V0Qm91bmRpLndpZHRoLFxuICAgICAgICBpbnB1dEhlaWdodCA9IF9pbnB1dEZpZWxkJGdldEJvdW5kaS5oZWlnaHQ7XG4gICAgICB2YXIgX2NvbmZpZyRvcmllbnRhdGlvbiA9IGNvbmZpZy5vcmllbnRhdGlvbixcbiAgICAgICAgb3JpZW50WCA9IF9jb25maWckb3JpZW50YXRpb24ueCxcbiAgICAgICAgb3JpZW50WSA9IF9jb25maWckb3JpZW50YXRpb24ueTtcbiAgICAgIHZhciBzY3JvbGxUb3A7XG4gICAgICB2YXIgbGVmdDtcbiAgICAgIHZhciB0b3A7XG4gICAgICBpZiAoY29udGFpbmVyID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICBsZWZ0ID0gaW5wdXRMZWZ0ICsgd2luZG93LnNjcm9sbFg7XG4gICAgICAgIHRvcCA9IGlucHV0VG9wICsgc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsVG9wID0gY29udGFpbmVyLnNjcm9sbFRvcDtcbiAgICAgICAgbGVmdCA9IGlucHV0TGVmdCAtIGNvbnRhaW5lckxlZnQ7XG4gICAgICAgIHRvcCA9IGlucHV0VG9wIC0gY29udGFpbmVyVG9wICsgc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWVudFggPT09ICdhdXRvJykge1xuICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICAvLyBhbGlnbiB0byB0aGUgbGVmdCBhbmQgbW92ZSBpbnRvIHZpc2libGUgYXJlYSBpZiBpbnB1dCdzIGxlZnQgZWRnZSA8IHdpbmRvdydzXG4gICAgICAgICAgb3JpZW50WCA9ICdsZWZ0JztcbiAgICAgICAgICBsZWZ0ID0gMTA7XG4gICAgICAgIH0gZWxzZSBpZiAobGVmdCArIGNhbGVuZGFyV2lkdGggPiBjb250YWluZXJXaWR0aCkge1xuICAgICAgICAgIC8vIGFsaWduIHRvIHRoZSByaWdodCBpZiBjYW5sZW5kYXIncyByaWdodCBlZGdlID4gY29udGFpbmVyJ3NcbiAgICAgICAgICBvcmllbnRYID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcmllbnRYID0gZ2V0VGV4dERpcmVjdGlvbihpbnB1dEZpZWxkKSA9PT0gJ3J0bCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3JpZW50WCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBsZWZ0IC09IGNhbGVuZGFyV2lkdGggLSBpbnB1dFdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWVudFkgPT09ICdhdXRvJykge1xuICAgICAgICBvcmllbnRZID0gdG9wIC0gY2FsZW5kYXJIZWlnaHQgPCBzY3JvbGxUb3AgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWVudFkgPT09ICd0b3AnKSB7XG4gICAgICAgIHRvcCAtPSBjYWxlbmRhckhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvcCArPSBpbnB1dEhlaWdodDtcbiAgICAgIH1cbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ2RhdGVwaWNrZXItb3JpZW50LXRvcCcsICdkYXRlcGlja2VyLW9yaWVudC1ib3R0b20nLCAnZGF0ZXBpY2tlci1vcmllbnQtcmlnaHQnLCAnZGF0ZXBpY2tlci1vcmllbnQtbGVmdCcpO1xuICAgICAgY2xhc3NMaXN0LmFkZChcImRhdGVwaWNrZXItb3JpZW50LVwiLmNvbmNhdChvcmllbnRZKSwgXCJkYXRlcGlja2VyLW9yaWVudC1cIi5jb25jYXQob3JpZW50WCkpO1xuICAgICAgc3R5bGUudG9wID0gdG9wID8gXCJcIi5jb25jYXQodG9wLCBcInB4XCIpIDogdG9wO1xuICAgICAgc3R5bGUubGVmdCA9IGxlZnQgPyBcIlwiLmNvbmNhdChsZWZ0LCBcInB4XCIpIDogbGVmdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Vmlld1N3aXRjaExhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZpZXdTd2l0Y2hMYWJlbChsYWJlbFRleHQpIHtcbiAgICAgIHRoaXMuY29udHJvbHMudmlld1N3aXRjaC50ZXh0Q29udGVudCA9IGxhYmVsVGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJldkJ0bkRpc2FibGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByZXZCdG5EaXNhYmxlZChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5jb250cm9scy5wcmV2QnRuLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE5leHRCdG5EaXNhYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXROZXh0QnRuRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY29udHJvbHMubmV4dEJ0bi5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGFuZ2VWaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZVZpZXcodmlld0lkKSB7XG4gICAgICB2YXIgb2xkVmlldyA9IHRoaXMuY3VycmVudFZpZXc7XG4gICAgICB2YXIgbmV3VmlldyA9IHRoaXMudmlld3Nbdmlld0lkXTtcbiAgICAgIGlmIChuZXdWaWV3LmlkICE9PSBvbGRWaWV3LmlkKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSBuZXdWaWV3O1xuICAgICAgICB0aGlzLl9yZW5kZXJNZXRob2QgPSAncmVuZGVyJztcbiAgICAgICAgdHJpZ2dlckRhdGVwaWNrZXJFdmVudCh0aGlzLmRhdGVwaWNrZXIsICdjaGFuZ2VWaWV3Jyk7XG4gICAgICAgIHRoaXMubWFpbi5yZXBsYWNlQ2hpbGQobmV3Vmlldy5lbGVtZW50LCBvbGRWaWV3LmVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBmb2N1c2VkIGRhdGUgKHZpZXcgZGF0ZSlcbiAgfSwge1xuICAgIGtleTogXCJjaGFuZ2VGb2N1c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VGb2N1cyhuZXdWaWV3RGF0ZSkge1xuICAgICAgdGhpcy5fcmVuZGVyTWV0aG9kID0gc2V0Vmlld0RhdGUodGhpcywgbmV3Vmlld0RhdGUpID8gJ3JlbmRlcicgOiAncmVmcmVzaEZvY3VzJztcbiAgICAgIHRoaXMudmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICB2aWV3LnVwZGF0ZUZvY3VzKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHRoZSBjaGFuZ2Ugb2YgdGhlIHNlbGVjdGVkIGRhdGVzXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBuZXdWaWV3RGF0ZSA9IGNvbXB1dGVSZXNldFZpZXdEYXRlKHRoaXMuZGF0ZXBpY2tlcik7XG4gICAgICB0aGlzLl9yZW5kZXJNZXRob2QgPSBzZXRWaWV3RGF0ZSh0aGlzLCBuZXdWaWV3RGF0ZSkgPyAncmVuZGVyJyA6ICdyZWZyZXNoJztcbiAgICAgIHRoaXMudmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xuICAgICAgICB2aWV3LnVwZGF0ZUZvY3VzKCk7XG4gICAgICAgIHZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFJlZnJlc2ggdGhlIHBpY2tlciBVSVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgcXVpY2tSZW5kZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICB2YXIgcmVuZGVyTWV0aG9kID0gcXVpY2tSZW5kZXIgJiYgdGhpcy5fcmVuZGVyTWV0aG9kIHx8ICdyZW5kZXInO1xuICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlck1ldGhvZDtcbiAgICAgIHRoaXMuY3VycmVudFZpZXdbcmVuZGVyTWV0aG9kXSgpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vLyBGaW5kIHRoZSBjbG9zZXN0IGRhdGUgdGhhdCBkb2Vzbid0IG1lZXQgdGhlIGNvbmRpdGlvbiBmb3IgdW5hdmFpbGFibGUgZGF0ZVxuLy8gUmV0dXJucyB1bmRlZmluZWQgaWYgbm8gYXZhaWxhYmxlIGRhdGUgaXMgZm91bmRcbi8vIGFkZEZuOiBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIG5leHQgZGF0ZVxuLy8gICAtIGFyZ3M6IHRpbWUgdmFsdWUsIGFtb3VudFxuLy8gaW5jcmVhc2U6IGFtb3VudCB0byBwYXNzIHRvIGFkZEZuXG4vLyB0ZXN0Rm46IGZ1bmN0aW9uIHRvIHRlc3QgdGhlIHVuYXZhaWxhYmxpdHkgb2YgdGhlIGRhdGVcbi8vICAgLSBhcmdzOiB0aW1lIHZhbHVlOyByZXR1bjogdHJ1ZSBpZiB1bmF2YWlsYWJsZVxuZnVuY3Rpb24gZmluZE5leHRBdmFpbGFibGVPbmUoZGF0ZSwgYWRkRm4sIGluY3JlYXNlLCB0ZXN0Rm4sIG1pbiwgbWF4KSB7XG4gIGlmICghaXNJblJhbmdlKGRhdGUsIG1pbiwgbWF4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodGVzdEZuKGRhdGUpKSB7XG4gICAgdmFyIG5ld0RhdGUgPSBhZGRGbihkYXRlLCBpbmNyZWFzZSk7XG4gICAgcmV0dXJuIGZpbmROZXh0QXZhaWxhYmxlT25lKG5ld0RhdGUsIGFkZEZuLCBpbmNyZWFzZSwgdGVzdEZuLCBtaW4sIG1heCk7XG4gIH1cbiAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIGRpcmVjdGlvbjogLTEgKGxlZnQvdXApLCAxIChyaWdodC9kb3duKVxuLy8gdmVydGljYWw6IHRydWUgZm9yIHVwL2Rvd24sIGZhbHNlIGZvciBsZWZ0L3JpZ2h0XG5mdW5jdGlvbiBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgZGlyZWN0aW9uLCB2ZXJ0aWNhbCkge1xuICB2YXIgcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXI7XG4gIHZhciBjdXJyZW50VmlldyA9IHBpY2tlci5jdXJyZW50VmlldztcbiAgdmFyIHN0ZXAgPSBjdXJyZW50Vmlldy5zdGVwIHx8IDE7XG4gIHZhciB2aWV3RGF0ZSA9IHBpY2tlci52aWV3RGF0ZTtcbiAgdmFyIGFkZEZuO1xuICB2YXIgdGVzdEZuO1xuICBzd2l0Y2ggKGN1cnJlbnRWaWV3LmlkKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIHZpZXdEYXRlID0gYWRkRGF5cyh2aWV3RGF0ZSwgZGlyZWN0aW9uICogNyk7XG4gICAgICB9IGVsc2UgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICB2aWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld0RhdGUgPSBhZGREYXlzKHZpZXdEYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgfVxuICAgICAgYWRkRm4gPSBhZGREYXlzO1xuICAgICAgdGVzdEZuID0gZnVuY3Rpb24gdGVzdEZuKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWaWV3LmRpc2FibGVkLmluY2x1ZGVzKGRhdGUpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHZpZXdEYXRlID0gYWRkTW9udGhzKHZpZXdEYXRlLCB2ZXJ0aWNhbCA/IGRpcmVjdGlvbiAqIDQgOiBkaXJlY3Rpb24pO1xuICAgICAgYWRkRm4gPSBhZGRNb250aHM7XG4gICAgICB0ZXN0Rm4gPSBmdW5jdGlvbiB0ZXN0Rm4oZGF0ZSkge1xuICAgICAgICB2YXIgZHQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgdmFyIHllYXIgPSBjdXJyZW50Vmlldy55ZWFyLFxuICAgICAgICAgIGRpc2FibGVkID0gY3VycmVudFZpZXcuZGlzYWJsZWQ7XG4gICAgICAgIHJldHVybiBkdC5nZXRGdWxsWWVhcigpID09PSB5ZWFyICYmIGRpc2FibGVkLmluY2x1ZGVzKGR0LmdldE1vbnRoKCkpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2aWV3RGF0ZSA9IGFkZFllYXJzKHZpZXdEYXRlLCBkaXJlY3Rpb24gKiAodmVydGljYWwgPyA0IDogMSkgKiBzdGVwKTtcbiAgICAgIGFkZEZuID0gYWRkWWVhcnM7XG4gICAgICB0ZXN0Rm4gPSBmdW5jdGlvbiB0ZXN0Rm4oZGF0ZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFZpZXcuZGlzYWJsZWQuaW5jbHVkZXMoc3RhcnRPZlllYXJQZXJpb2QoZGF0ZSwgc3RlcCkpO1xuICAgICAgfTtcbiAgfVxuICB2aWV3RGF0ZSA9IGZpbmROZXh0QXZhaWxhYmxlT25lKHZpZXdEYXRlLCBhZGRGbiwgZGlyZWN0aW9uIDwgMCA/IC1zdGVwIDogc3RlcCwgdGVzdEZuLCBjdXJyZW50Vmlldy5taW5EYXRlLCBjdXJyZW50Vmlldy5tYXhEYXRlKTtcbiAgaWYgKHZpZXdEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwaWNrZXIuY2hhbmdlRm9jdXModmlld0RhdGUpLnJlbmRlcigpO1xuICB9XG59XG5mdW5jdGlvbiBvbktleWRvd24oZGF0ZXBpY2tlciwgZXYpIHtcbiAgaWYgKGV2LmtleSA9PT0gJ1RhYicpIHtcbiAgICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGlja2VyID0gZGF0ZXBpY2tlci5waWNrZXI7XG4gIHZhciBfcGlja2VyJGN1cnJlbnRWaWV3ID0gcGlja2VyLmN1cnJlbnRWaWV3LFxuICAgIGlkID0gX3BpY2tlciRjdXJyZW50Vmlldy5pZCxcbiAgICBpc01pblZpZXcgPSBfcGlja2VyJGN1cnJlbnRWaWV3LmlzTWluVmlldztcbiAgaWYgKCFwaWNrZXIuYWN0aXZlKSB7XG4gICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICBwaWNrZXIuc2hvdygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgZGF0ZXBpY2tlci51cGRhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGVwaWNrZXIuZWRpdE1vZGUpIHtcbiAgICBzd2l0Y2ggKGV2LmtleSkge1xuICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgcGlja2VyLmhpZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgIGRhdGVwaWNrZXIuZXhpdEVkaXRNb2RlKHtcbiAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgYXV0b2hpZGU6IGRhdGVwaWNrZXIuY29uZmlnLmF1dG9oaWRlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChldi5rZXkpIHtcbiAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgIHBpY2tlci5oaWRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgIGdvVG9QcmV2T3JOZXh0KGRhdGVwaWNrZXIsIC0xKTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgLTEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgZ29Ub1ByZXZPck5leHQoZGF0ZXBpY2tlciwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW92ZUJ5QXJyb3dLZXkoZGF0ZXBpY2tlciwgZXYsIDEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgc3dpdGNoVmlldyhkYXRlcGlja2VyKTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb3ZlQnlBcnJvd0tleShkYXRlcGlja2VyLCBldiwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgaWYgKGV2LnNoaWZ0S2V5ICYmICFldi5jdHJsS2V5ICYmICFldi5tZXRhS2V5KSB7XG4gICAgICAgICAgZGF0ZXBpY2tlci5lbnRlckVkaXRNb2RlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vdmVCeUFycm93S2V5KGRhdGVwaWNrZXIsIGV2LCAxLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgIGlmIChpc01pblZpZXcpIHtcbiAgICAgICAgICBkYXRlcGlja2VyLnNldERhdGUocGlja2VyLnZpZXdEYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwaWNrZXIuY2hhbmdlVmlldyhpZCAtIDEpLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgIGNhc2UgJ0RlbGV0ZSc6XG4gICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoZXYua2V5Lmxlbmd0aCA9PT0gMSAmJiAhZXYuY3RybEtleSAmJiAhZXYubWV0YUtleSkge1xuICAgICAgICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBvbkZvY3VzKGRhdGVwaWNrZXIpIHtcbiAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLnNob3dPbkZvY3VzICYmICFkYXRlcGlja2VyLl9zaG93aW5nKSB7XG4gICAgZGF0ZXBpY2tlci5zaG93KCk7XG4gIH1cbn1cblxuLy8gZm9yIHRoZSBwcmV2ZW50aW9uIGZvciBlbnRlcmluZyBlZGl0IG1vZGUgd2hpbGUgZ2V0dGluZyBmb2N1cyBvbiBjbGlja1xuZnVuY3Rpb24gb25Nb3VzZWRvd24oZGF0ZXBpY2tlciwgZXYpIHtcbiAgdmFyIGVsID0gZXYudGFyZ2V0O1xuICBpZiAoZGF0ZXBpY2tlci5waWNrZXIuYWN0aXZlIHx8IGRhdGVwaWNrZXIuY29uZmlnLnNob3dPbkNsaWNrKSB7XG4gICAgZWwuX2FjdGl2ZSA9IGVsID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGVsLl9jbGlja2luZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIGVsLl9hY3RpdmU7XG4gICAgICBkZWxldGUgZWwuX2NsaWNraW5nO1xuICAgIH0sIDIwMDApO1xuICB9XG59XG5mdW5jdGlvbiBvbkNsaWNrSW5wdXQoZGF0ZXBpY2tlciwgZXYpIHtcbiAgdmFyIGVsID0gZXYudGFyZ2V0O1xuICBpZiAoIWVsLl9jbGlja2luZykge1xuICAgIHJldHVybjtcbiAgfVxuICBjbGVhclRpbWVvdXQoZWwuX2NsaWNraW5nKTtcbiAgZGVsZXRlIGVsLl9jbGlja2luZztcbiAgaWYgKGVsLl9hY3RpdmUpIHtcbiAgICBkYXRlcGlja2VyLmVudGVyRWRpdE1vZGUoKTtcbiAgfVxuICBkZWxldGUgZWwuX2FjdGl2ZTtcbiAgaWYgKGRhdGVwaWNrZXIuY29uZmlnLnNob3dPbkNsaWNrKSB7XG4gICAgZGF0ZXBpY2tlci5zaG93KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uUGFzdGUoZGF0ZXBpY2tlciwgZXYpIHtcbiAgaWYgKGV2LmNsaXBib2FyZERhdGEudHlwZXMuaW5jbHVkZXMoJ3RleHQvcGxhaW4nKSkge1xuICAgIGRhdGVwaWNrZXIuZW50ZXJFZGl0TW9kZSgpO1xuICB9XG59XG5cbi8vIGZvciB0aGUgYGRvY3VtZW50YCB0byBkZWxlZ2F0ZSB0aGUgZXZlbnRzIGZyb20gb3V0c2lkZSB0aGUgcGlja2VyL2lucHV0IGZpZWxkXG5mdW5jdGlvbiBvbkNsaWNrT3V0c2lkZShkYXRlcGlja2VyLCBldikge1xuICB2YXIgZWxlbWVudCA9IGRhdGVwaWNrZXIuZWxlbWVudDtcbiAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHBpY2tlckVsZW0gPSBkYXRlcGlja2VyLnBpY2tlci5lbGVtZW50O1xuICBpZiAoZmluZEVsZW1lbnRJbkV2ZW50UGF0aChldiwgZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsID09PSBlbGVtZW50IHx8IGVsID09PSBwaWNrZXJFbGVtO1xuICB9KSkge1xuICAgIHJldHVybjtcbiAgfVxuICB1bmZvY3VzKGRhdGVwaWNrZXIpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlEYXRlcyhkYXRlcywgY29uZmlnKSB7XG4gIHJldHVybiBkYXRlcy5tYXAoZnVuY3Rpb24gKGR0KSB7XG4gICAgcmV0dXJuIGZvcm1hdERhdGUoZHQsIGNvbmZpZy5mb3JtYXQsIGNvbmZpZy5sb2NhbGUpO1xuICB9KS5qb2luKGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcbn1cblxuLy8gcGFyc2UgaW5wdXQgZGF0ZXMgYW5kIGNyZWF0ZSBhbiBhcnJheSBvZiB0aW1lIHZhbHVlcyBmb3Igc2VsZWN0aW9uXG4vLyByZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgZGF0ZXMgaW4gaW5wdXREYXRlc1xuLy8gd2hlbiBvcmlnRGF0ZXMgKGN1cnJlbnQgc2VsZWN0aW9uKSBpcyBwYXNzZWQsIHRoZSBmdW5jdGlvbiB3b3JrcyB0byBtaXhcbi8vIHRoZSBpbnB1dCBkYXRlcyBpbnRvIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZnVuY3Rpb24gcHJvY2Vzc0lucHV0RGF0ZXMoZGF0ZXBpY2tlciwgaW5wdXREYXRlcykge1xuICB2YXIgY2xlYXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICB2YXIgY29uZmlnID0gZGF0ZXBpY2tlci5jb25maWcsXG4gICAgb3JpZ0RhdGVzID0gZGF0ZXBpY2tlci5kYXRlcyxcbiAgICByYW5nZXBpY2tlciA9IGRhdGVwaWNrZXIucmFuZ2VwaWNrZXI7XG4gIGlmIChpbnB1dERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGVtcHR5IGlucHV0IGlzIGNvbnNpZGVyZWQgdmFsaWQgdW5sZXNzIG9yaWdpRGF0ZXMgaXMgcGFzc2VkXG4gICAgcmV0dXJuIGNsZWFyID8gW10gOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHJhbmdlRW5kID0gcmFuZ2VwaWNrZXIgJiYgZGF0ZXBpY2tlciA9PT0gcmFuZ2VwaWNrZXIuZGF0ZXBpY2tlcnNbMV07XG4gIHZhciBuZXdEYXRlcyA9IGlucHV0RGF0ZXMucmVkdWNlKGZ1bmN0aW9uIChkYXRlcywgZHQpIHtcbiAgICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZShkdCwgY29uZmlnLmZvcm1hdCwgY29uZmlnLmxvY2FsZSk7XG4gICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnBpY2tMZXZlbCA+IDApIHtcbiAgICAgIC8vIGFkanVzdCB0byAxc3Qgb2YgdGhlIG1vbnRoL0phbiAxc3Qgb2YgdGhlIHllYXJcbiAgICAgIC8vIG9yIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9uaC9EZWMgMzFzdCBvZiB0aGUgeWVhciBpZiB0aGUgZGF0ZXBpY2tlclxuICAgICAgLy8gaXMgdGhlIHJhbmdlLWVuZCBwaWNrZXIgb2YgYSByYW5nZXBpY2tlclxuICAgICAgdmFyIF9kdCA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgaWYgKGNvbmZpZy5waWNrTGV2ZWwgPT09IDEpIHtcbiAgICAgICAgZGF0ZSA9IHJhbmdlRW5kID8gX2R0LnNldE1vbnRoKF9kdC5nZXRNb250aCgpICsgMSwgMCkgOiBfZHQuc2V0RGF0ZSgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUgPSByYW5nZUVuZCA/IF9kdC5zZXRGdWxsWWVhcihfZHQuZ2V0RnVsbFllYXIoKSArIDEsIDAsIDApIDogX2R0LnNldE1vbnRoKDAsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNJblJhbmdlKGRhdGUsIGNvbmZpZy5taW5EYXRlLCBjb25maWcubWF4RGF0ZSkgJiYgIWRhdGVzLmluY2x1ZGVzKGRhdGUpICYmICFjb25maWcuZGF0ZXNEaXNhYmxlZC5pbmNsdWRlcyhkYXRlKSAmJiAhY29uZmlnLmRheXNPZldlZWtEaXNhYmxlZC5pbmNsdWRlcyhuZXcgRGF0ZShkYXRlKS5nZXREYXkoKSkpIHtcbiAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlcztcbiAgfSwgW10pO1xuICBpZiAobmV3RGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjb25maWcubXVsdGlkYXRlICYmICFjbGVhcikge1xuICAgIC8vIGdldCB0aGUgc3lubWV0cmljIGRpZmZlcmVuY2UgYmV0d2VlbiBvcmlnRGF0ZXMgYW5kIG5ld0RhdGVzXG4gICAgbmV3RGF0ZXMgPSBuZXdEYXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGRhdGVzLCBkYXRlKSB7XG4gICAgICBpZiAoIW9yaWdEYXRlcy5pbmNsdWRlcyhkYXRlKSkge1xuICAgICAgICBkYXRlcy5wdXNoKGRhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH0sIG9yaWdEYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiAhbmV3RGF0ZXMuaW5jbHVkZXMoZGF0ZSk7XG4gICAgfSkpO1xuICB9XG4gIC8vIGRvIGxlbmd0aCBjaGVjayBhbHdheXMgYmVjYXVzZSB1c2VyIGNhbiBpbnB1dCBtdWx0aXBsZSBkYXRlcyByZWdhcmRsZXNzIG9mIHRoZSBtb2RlXG4gIHJldHVybiBjb25maWcubWF4TnVtYmVyT2ZEYXRlcyAmJiBuZXdEYXRlcy5sZW5ndGggPiBjb25maWcubWF4TnVtYmVyT2ZEYXRlcyA/IG5ld0RhdGVzLnNsaWNlKGNvbmZpZy5tYXhOdW1iZXJPZkRhdGVzICogLTEpIDogbmV3RGF0ZXM7XG59XG5cbi8vIHJlZnJlc2ggdGhlIFVJIGVsZW1lbnRzXG4vLyBtb2RlczogMTogaW5wdXQgb25seSwgMiwgcGlja2VyIG9ubHksIDMgYm90aFxuZnVuY3Rpb24gcmVmcmVzaFVJKGRhdGVwaWNrZXIpIHtcbiAgdmFyIG1vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDM7XG4gIHZhciBxdWlja1JlbmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgdmFyIGNvbmZpZyA9IGRhdGVwaWNrZXIuY29uZmlnLFxuICAgIHBpY2tlciA9IGRhdGVwaWNrZXIucGlja2VyLFxuICAgIGlucHV0RmllbGQgPSBkYXRlcGlja2VyLmlucHV0RmllbGQ7XG4gIGlmIChtb2RlICYgMikge1xuICAgIHZhciBuZXdWaWV3ID0gcGlja2VyLmFjdGl2ZSA/IGNvbmZpZy5waWNrTGV2ZWwgOiBjb25maWcuc3RhcnRWaWV3O1xuICAgIHBpY2tlci51cGRhdGUoKS5jaGFuZ2VWaWV3KG5ld1ZpZXcpLnJlbmRlcihxdWlja1JlbmRlcik7XG4gIH1cbiAgaWYgKG1vZGUgJiAxICYmIGlucHV0RmllbGQpIHtcbiAgICBpbnB1dEZpZWxkLnZhbHVlID0gc3RyaW5naWZ5RGF0ZXMoZGF0ZXBpY2tlci5kYXRlcywgY29uZmlnKTtcbiAgfVxufVxuZnVuY3Rpb24gX3NldERhdGUoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgb3B0aW9ucykge1xuICB2YXIgY2xlYXIgPSBvcHRpb25zLmNsZWFyLFxuICAgIHJlbmRlciA9IG9wdGlvbnMucmVuZGVyLFxuICAgIGF1dG9oaWRlID0gb3B0aW9ucy5hdXRvaGlkZTtcbiAgaWYgKHJlbmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVuZGVyID0gdHJ1ZTtcbiAgfVxuICBpZiAoIXJlbmRlcikge1xuICAgIGF1dG9oaWRlID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYXV0b2hpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGF1dG9oaWRlID0gZGF0ZXBpY2tlci5jb25maWcuYXV0b2hpZGU7XG4gIH1cbiAgdmFyIG5ld0RhdGVzID0gcHJvY2Vzc0lucHV0RGF0ZXMoZGF0ZXBpY2tlciwgaW5wdXREYXRlcywgY2xlYXIpO1xuICBpZiAoIW5ld0RhdGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChuZXdEYXRlcy50b1N0cmluZygpICE9PSBkYXRlcGlja2VyLmRhdGVzLnRvU3RyaW5nKCkpIHtcbiAgICBkYXRlcGlja2VyLmRhdGVzID0gbmV3RGF0ZXM7XG4gICAgcmVmcmVzaFVJKGRhdGVwaWNrZXIsIHJlbmRlciA/IDMgOiAxKTtcbiAgICB0cmlnZ2VyRGF0ZXBpY2tlckV2ZW50KGRhdGVwaWNrZXIsICdjaGFuZ2VEYXRlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVmcmVzaFVJKGRhdGVwaWNrZXIsIDEpO1xuICB9XG4gIGlmIChhdXRvaGlkZSkge1xuICAgIGRhdGVwaWNrZXIuaGlkZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZGF0ZSBwaWNrZXJcbiAqL1xudmFyIERhdGVwaWNrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgZGF0ZSBwaWNrZXJcbiAgICogQHBhcmFtICB7RWxlbWVudH0gZWxlbWVudCAtIGVsZW1lbnQgdG8gYmluZCBhIGRhdGUgcGlja2VyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdIC0gY29uZmlnIG9wdGlvbnNcbiAgICogQHBhcmFtICB7RGF0ZVJhbmdlUGlja2VyfSBbcmFuZ2VwaWNrZXJdIC0gRGF0ZVJhbmdlUGlja2VyIGluc3RhbmNlIHRoZVxuICAgKiBkYXRlIHBpY2tlciBiZWxvbmdzIHRvLiBVc2UgdGhpcyBvbmx5IHdoZW4gY3JlYXRpbmcgZGF0ZSBwaWNrZXIgYXMgYSBwYXJ0XG4gICAqIG9mIGRhdGUgcmFuZ2UgcGlja2VyXG4gICAqL1xuICBmdW5jdGlvbiBEYXRlcGlja2VyKGVsZW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHJhbmdlcGlja2VyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGVwaWNrZXIpO1xuICAgIGVsZW1lbnQuZGF0ZXBpY2tlciA9IHRoaXM7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAgIC8vIHNldCB1cCBjb25maWdcbiAgICB2YXIgY29uZmlnID0gdGhpcy5jb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGJ1dHRvbkNsYXNzOiBvcHRpb25zLmJ1dHRvbkNsYXNzICYmIFN0cmluZyhvcHRpb25zLmJ1dHRvbkNsYXNzKSB8fCAnYnV0dG9uJyxcbiAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keSxcbiAgICAgIGRlZmF1bHRWaWV3RGF0ZTogdG9kYXkoKSxcbiAgICAgIG1heERhdGU6IHVuZGVmaW5lZCxcbiAgICAgIG1pbkRhdGU6IHVuZGVmaW5lZFxuICAgIH0sIHByb2Nlc3NPcHRpb25zKGRlZmF1bHRPcHRpb25zLCB0aGlzKSk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBieSB0eXBlXG4gICAgdmFyIGlubGluZSA9IHRoaXMuaW5saW5lID0gZWxlbWVudC50YWdOYW1lICE9PSAnSU5QVVQnO1xuICAgIHZhciBpbnB1dEZpZWxkO1xuICAgIHZhciBpbml0aWFsRGF0ZXM7XG4gICAgaWYgKGlubGluZSkge1xuICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGVsZW1lbnQ7XG4gICAgICBpbml0aWFsRGF0ZXMgPSBzdHJpbmdUb0FycmF5KGVsZW1lbnQuZGF0YXNldC5kYXRlLCBjb25maWcuZGF0ZURlbGltaXRlcik7XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob3B0aW9ucy5jb250YWluZXIpIDogbnVsbDtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIH1cbiAgICAgIGlucHV0RmllbGQgPSB0aGlzLmlucHV0RmllbGQgPSBlbGVtZW50O1xuICAgICAgaW5wdXRGaWVsZC5jbGFzc0xpc3QuYWRkKCdkYXRlcGlja2VyLWlucHV0Jyk7XG4gICAgICBpbml0aWFsRGF0ZXMgPSBzdHJpbmdUb0FycmF5KGlucHV0RmllbGQudmFsdWUsIGNvbmZpZy5kYXRlRGVsaW1pdGVyKTtcbiAgICB9XG4gICAgaWYgKHJhbmdlcGlja2VyKSB7XG4gICAgICAvLyBjaGVjayB2YWxpZGlyeVxuICAgICAgdmFyIGluZGV4ID0gcmFuZ2VwaWNrZXIuaW5wdXRzLmluZGV4T2YoaW5wdXRGaWVsZCk7XG4gICAgICB2YXIgZGF0ZXBpY2tlcnMgPSByYW5nZXBpY2tlci5kYXRlcGlja2VycztcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiAxIHx8ICFBcnJheS5pc0FycmF5KGRhdGVwaWNrZXJzKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCByYW5nZXBpY2tlciBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgICAvLyBhdHRhY2ggaXRhZWxmIHRvIHRoZSByYW5nZXBpY2tlciBoZXJlIHNvIHRoYXQgcHJvY2Vzc0lucHV0RGF0ZXMoKSBjYW5cbiAgICAgIC8vIGRldGVybWluZSBpZiB0aGlzIGlzIHRoZSByYW5nZS1lbmQgcGlja2VyIG9mIHRoZSByYW5nZXBpY2tlciB3aGlsZVxuICAgICAgLy8gc2V0dGluZyBpbml0YWwgdmFsdWVzIHdoZW4gcGlja0xldmVsID4gMFxuICAgICAgZGF0ZXBpY2tlcnNbaW5kZXhdID0gdGhpcztcbiAgICAgIC8vIGFkZCBnZXR0ZXIgZm9yIHJhbmdlcGlja2VyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JhbmdlcGlja2VyJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2VwaWNrZXI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHNldCBpbml0aWFsIGRhdGVzXG4gICAgdGhpcy5kYXRlcyA9IFtdO1xuICAgIC8vIHByb2Nlc3MgaW5pdGlhbCB2YWx1ZVxuICAgIHZhciBpbnB1dERhdGVWYWx1ZXMgPSBwcm9jZXNzSW5wdXREYXRlcyh0aGlzLCBpbml0aWFsRGF0ZXMpO1xuICAgIGlmIChpbnB1dERhdGVWYWx1ZXMgJiYgaW5wdXREYXRlVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZGF0ZXMgPSBpbnB1dERhdGVWYWx1ZXM7XG4gICAgfVxuICAgIGlmIChpbnB1dEZpZWxkKSB7XG4gICAgICBpbnB1dEZpZWxkLnZhbHVlID0gc3RyaW5naWZ5RGF0ZXModGhpcy5kYXRlcywgY29uZmlnKTtcbiAgICB9XG4gICAgdmFyIHBpY2tlciA9IHRoaXMucGlja2VyID0gbmV3IFBpY2tlcih0aGlzKTtcbiAgICBpZiAoaW5saW5lKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0IHVwIGV2ZW50IGxpc3RlbmVycyBpbiBvdGhlciBtb2Rlc1xuICAgICAgdmFyIG9uTW91c2Vkb3duRG9jdW1lbnQgPSBvbkNsaWNrT3V0c2lkZS5iaW5kKG51bGwsIHRoaXMpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IFtbaW5wdXRGaWVsZCwgJ2tleWRvd24nLCBvbktleWRvd24uYmluZChudWxsLCB0aGlzKV0sIFtpbnB1dEZpZWxkLCAnZm9jdXMnLCBvbkZvY3VzLmJpbmQobnVsbCwgdGhpcyldLCBbaW5wdXRGaWVsZCwgJ21vdXNlZG93bicsIG9uTW91c2Vkb3duLmJpbmQobnVsbCwgdGhpcyldLCBbaW5wdXRGaWVsZCwgJ2NsaWNrJywgb25DbGlja0lucHV0LmJpbmQobnVsbCwgdGhpcyldLCBbaW5wdXRGaWVsZCwgJ3Bhc3RlJywgb25QYXN0ZS5iaW5kKG51bGwsIHRoaXMpXSwgW2RvY3VtZW50LCAnbW91c2Vkb3duJywgb25Nb3VzZWRvd25Eb2N1bWVudF0sIFtkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbk1vdXNlZG93bkRvY3VtZW50XSwgW3dpbmRvdywgJ3Jlc2l6ZScsIHBpY2tlci5wbGFjZS5iaW5kKHBpY2tlcildXTtcbiAgICAgIHJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMsIGxpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBEYXRlIG9iamVjdCBvciB0aW1lIHZhbHVlIGluIGdpdmVuIGZvcm1hdCBhbmQgbGFuZ3VhZ2VcbiAgICogQHBhcmFtICB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSBkYXRlIG9yIHRpbWUgdmFsdWUgdG8gZm9ybWF0XG4gICAqIEBwYXJhbSAge1N0cmluZ3xPYmplY3R9IGZvcm1hdCAtIGZvcm1hdCBzdHJpbmcgb3Igb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICogdG9EaXNwbGF5KCkgY3VzdG9tIGZvcm1hdHRlciwgd2hvc2Ugc2lnbmF0dXJlIGlzXG4gICAqIC0gYXJnczpcbiAgICogICAtIGRhdGU6IHtEYXRlfSAtIERhdGUgaW5zdGFuY2Ugb2YgdGhlIGRhdGUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICogICAtIGZvcm1hdDoge09iamVjdH0gLSB0aGUgZm9ybWF0IG9iamVjdCBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgKiAgIC0gbG9jYWxlOiB7T2JqZWN0fSAtIGxvY2FsZSBmb3IgdGhlIGxhbmd1YWdlIHNwZWNpZmllZCBieSBgbGFuZ2BcbiAgICogLSByZXR1cm46XG4gICAqICAgICB7U3RyaW5nfSBmb3JtYXR0ZWQgZGF0ZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtsYW5nPWVuXSAtIGxhbmd1YWdlIGNvZGUgZm9yIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZm9ybWF0dGVkIGRhdGVcbiAgICovXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGF0ZXBpY2tlciwgW3tcbiAgICBrZXk6IFwiYWN0aXZlXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufSAtIFdoZXRoZXIgdGhlIHBpY2tlciBlbGVtZW50IGlzIHNob3duLiBgdHJ1ZWAgd2huZSBzaG93blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLnBpY2tlciAmJiB0aGlzLnBpY2tlci5hY3RpdmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gLSBET00gb2JqZWN0IG9mIHBpY2tlciBlbGVtZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGlja2VyRWxlbWVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGlja2VyID8gdGhpcy5waWNrZXIuZWxlbWVudCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbmV3IHZhbHVlcyB0byB0aGUgY29uZmlnIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGNvbmZpZyBvcHRpb25zIHRvIHVwZGF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgcGlja2VyID0gdGhpcy5waWNrZXI7XG4gICAgICB2YXIgbmV3T3B0aW9ucyA9IHByb2Nlc3NPcHRpb25zKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWcsIG5ld09wdGlvbnMpO1xuICAgICAgcGlja2VyLnNldE9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICByZWZyZXNoVUkodGhpcywgMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5pbnB1dEZpZWxkKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0RmllbGQuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRGaWVsZCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuX3Nob3dpbmcgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaG93aW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBpY2tlci5zaG93KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICAgKiBOb3QgYXZhaWxhYmxlIG9uIGlubGluZSBwaWNrZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5waWNrZXIuaGlkZSgpO1xuICAgICAgdGhpcy5waWNrZXIudXBkYXRlKCkuY2hhbmdlVmlldyh0aGlzLmNvbmZpZy5zdGFydFZpZXcpLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIERhdGVwaWNrZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtEZXRlcGlja2VyfSAtIHRoZSBpbnN0YW5jZSBkZXN0cm95ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIHVucmVnaXN0ZXJMaXN0ZW5lcnModGhpcyk7XG4gICAgICB0aGlzLnBpY2tlci5kZXRhY2goKTtcbiAgICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2RhdGVwaWNrZXItaW5wdXQnKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0ZXBpY2tlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2VsZWN0ZWQgZGF0ZShzKVxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZCByZXR1cm5zIGEgRGF0ZSBvYmplY3Qgb2Ygc2VsZWN0ZWQgZGF0ZSBieSBkZWZhdWx0LCBhbmQgcmV0dXJuc1xuICAgICAqIGFuIGFycmF5IG9mIHNlbGVjdGVkIGRhdGVzIGluIG11bHRpZGF0ZSBtb2RlLiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcbiAgICAgKiBpdCByZXR1cm5zIGRhdGUgc3RyaW5nKHMpIGZvcm1hdHRlZCBpbiBnaXZlbiBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtmb3JtYXRdIC0gRm9ybWF0IHN0cmluZyB0byBzdHJpbmdpZnkgdGhlIGRhdGUocylcbiAgICAgKiBAcmV0dXJuIHtEYXRlfFN0cmluZ3xEYXRlW118U3RyaW5nW119IC0gc2VsZWN0ZWQgZGF0ZShzKSwgb3IgaWYgbm9uZSBpc1xuICAgICAqIHNlbGVjdGVkLCBlbXB0eSBhcnJheSBpbiBtdWx0aWRhdGUgbW9kZSBhbmQgdW50aXRsZWQgaW4gc2lnbGVkYXRlIG1vZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXREYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERhdGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZm9ybWF0ID8gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBfdGhpcy5jb25maWcubG9jYWxlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY29uZmlnLm11bHRpZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlcy5tYXAoY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHNlbGVjdGVkIGRhdGUocylcbiAgICAgKlxuICAgICAqIEluIG11bHRpZGF0ZSBtb2RlLCB5b3UgY2FuIHBhc3MgbXVsdGlwbGUgZGF0ZXMgYXMgYSBzZXJpZXMgb2YgYXJndW1lbnRzXG4gICAgICogb3IgYW4gYXJyYXkuIChTaW5jZSBlYWNoIGRhdGUgaXMgcGFyc2VkIGluZGl2aWR1YWxseSwgdGhlIHR5cGUgb2YgdGhlXG4gICAgICogZGF0ZXMgZG9lc24ndCBoYXZlIHRvIGJlIHRoZSBzYW1lLilcbiAgICAgKiBUaGUgZ2l2ZW4gZGF0ZXMgYXJlIHVzZWQgdG8gdG9nZ2xlIHRoZSBzZWxlY3Qgc3RhdHVzIG9mIGVhY2ggZGF0ZS4gVGhlXG4gICAgICogbnVtYmVyIG9mIHNlbGVjdGVkIGRhdGVzIGlzIGtlcHQgZnJvbSBleGNlZWRpbmcgdGhlIGxlbmd0aCBzZXQgdG9cbiAgICAgKiBtYXhOdW1iZXJPZkRhdGVzLlxuICAgICAqXG4gICAgICogV2l0aCBjbGVhcjogdHJ1ZSBvcHRpb24sIHRoZSBtZXRob2QgY2FuIGJlIHVzZWQgdG8gY2xlYXIgdGhlIHNlbGVjdGlvblxuICAgICAqIGFuZCB0byByZXBsYWNlIHRoZSBzZWxlY3Rpb24gaW5zdGVhZCBvZiB0b2dnbGluZyBpbiBtdWx0aWRhdGUgbW9kZS5cbiAgICAgKiBJZiB0aGUgb3B0aW9uIGlzIHBhc3NlZCB3aXRoIG5vIGRhdGUgYXJndW1lbnRzIG9yIGFuIGVtcHR5IGRhdGVzIGFycmF5LFxuICAgICAqIGl0IHdvcmtzIGFzIFwiY2xlYXJcIiAoY2xlYXIgdGhlIHNlbGVjdGlvbiB0aGVuIHNldCBub3RoaW5nKSwgYW5kIGlmIHRoZVxuICAgICAqIG9wdGlvbiBpcyBwYXNzZWQgd2l0aCBuZXcgZGF0ZXMgdG8gc2VsZWN0LCBpdCB3b3JrcyBhcyBcInJlcGxhY2VcIiAoY2xlYXJcbiAgICAgKiB0aGUgc2VsZWN0aW9uIHRoZW4gc2V0IHRoZSBnaXZlbiBkYXRlcylcbiAgICAgKlxuICAgICAqIFdoZW4gcmVuZGVyOiBmYWxzZSBvcHRpb24gaXMgdXNlZCwgdGhlIG1ldGhvZCBvbWl0cyByZS1yZW5kZXJpbmcgdGhlXG4gICAgICogcGlja2VyIGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgeW91IG5lZWQgdG8gY2FsbCByZWZyZXNoKCkgbWV0aG9kIGxhdGVyIGluXG4gICAgICogb3JkZXIgZm9yIHRoZSBwaWNrZXIgZWxlbWVudCB0byByZWZsZWN0IHRoZSBjaGFuZ2VzLiBUaGUgaW5wdXQgZmllbGQgaXNcbiAgICAgKiByZWZyZXNoZWQgYWx3YXlzIHJlZ2FyZGxlc3Mgb2YgdGhpcyBvcHRpb24uXG4gICAgICpcbiAgICAgKiBXaGVuIGludmFsaWQgKHVucGFyc2FibGUsIHJlcGVhdGVkLCBkaXNhYmxlZCBvciBvdXQtb2YtcmFuZ2UpIGRhdGVzIGFyZVxuICAgICAqIHBhc3NlZCwgdGhlIG1ldGhvZCBpZ25vcmVzIHRoZW0gYW5kIGFwcGxpZXMgb25seSB2YWxpZCBvbmVzLiBJbiB0aGUgY2FzZVxuICAgICAqIHRoYXQgYWxsIHRoZSBnaXZlbiBkYXRlcyBhcmUgaW52YWxpZCwgd2hpY2ggaXMgZGlzdGluZ3Vpc2hlZCBmcm9tIHBhc3NpbmdcbiAgICAgKiBubyBkYXRlcywgdGhlIG1ldGhvZCBjb25zaWRlcnMgaXQgYXMgYW4gZXJyb3IgYW5kIGxlYXZlcyB0aGUgc2VsZWN0aW9uXG4gICAgICogdW50b3VjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4oRGF0ZXxOdW1iZXJ8U3RyaW5nKXxBcnJheX0gW2RhdGVzXSAtIERhdGUgc3RyaW5ncywgRGF0ZVxuICAgICAqIG9iamVjdHMsIHRpbWUgdmFsdWVzIG9yIG1peCBvZiB0aG9zZSBmb3IgbmV3IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBmdW5jdGlvbiBvcHRpb25zXG4gICAgICogLSBjbGVhcjoge2Jvb2xlYW59IC0gV2hldGhlciB0byBjbGVhciB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAgICogICAgIGRlZnVhbHQ6IGZhbHNlXG4gICAgICogLSByZW5kZXI6IHtib29sZWFufSAtIFdoZXRoZXIgdG8gcmUtcmVuZGVyIHRoZSBwaWNrZXIgZWxlbWVudFxuICAgICAqICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICogLSBhdXRvaGlkZToge2Jvb2xlYW59IC0gV2hldGhlciB0byBoaWRlIHRoZSBwaWNrZXIgZWxlbWVudCBhZnRlciByZS1yZW5kZXJcbiAgICAgKiAgICAgSWdub3JlZCB3aGVuIHVzZWQgd2l0aCByZW5kZXI6IGZhbHNlXG4gICAgICogICAgIGRlZmF1bHQ6IGNvbmZpZy5hdXRvaGlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldERhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0ZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGVzID0gW10uY29uY2F0KGFyZ3MpO1xuICAgICAgdmFyIG9wdHMgPSB7fTtcbiAgICAgIHZhciBsYXN0QXJnID0gbGFzdEl0ZW1PZihhcmdzKTtcbiAgICAgIGlmIChfdHlwZW9mKGxhc3RBcmcpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShsYXN0QXJnKSAmJiAhKGxhc3RBcmcgaW5zdGFuY2VvZiBEYXRlKSAmJiBsYXN0QXJnKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgZGF0ZXMucG9wKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGlucHV0RGF0ZXMgPSBBcnJheS5pc0FycmF5KGRhdGVzWzBdKSA/IGRhdGVzWzBdIDogZGF0ZXM7XG4gICAgICBfc2V0RGF0ZSh0aGlzLCBpbnB1dERhdGVzLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHNlbGVjdGVkIGRhdGUocykgd2l0aCBpbnB1dCBmaWVsZCdzIHZhbHVlXG4gICAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyXG4gICAgICpcbiAgICAgKiBUaGUgaW5wdXQgZmllbGQgd2lsbCBiZSByZWZyZXNoZWQgd2l0aCBwcm9wZXJseSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcbiAgICAgKiAtIGF1dG9oaWRlOiB7Ym9vbGVhbn0gLSB3aGV0aGVyIHRvIGhpZGUgdGhlIHBpY2tlciBlbGVtZW50IGFmdGVyIHJlZnJlc2hcbiAgICAgKiAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgY2xlYXI6IHRydWUsXG4gICAgICAgIGF1dG9oaWRlOiAhIShvcHRpb25zICYmIG9wdGlvbnMuYXV0b2hpZGUpXG4gICAgICB9O1xuICAgICAgdmFyIGlucHV0RGF0ZXMgPSBzdHJpbmdUb0FycmF5KHRoaXMuaW5wdXRGaWVsZC52YWx1ZSwgdGhpcy5jb25maWcuZGF0ZURlbGltaXRlcik7XG4gICAgICBfc2V0RGF0ZSh0aGlzLCBpbnB1dERhdGVzLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoIHRoZSBwaWNrZXIgZWxlbWVudCBhbmQgdGhlIGFzc29jaWF0ZWQgaW5wdXQgZmllbGRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3RhcmdldF0gLSB0YXJnZXQgaXRlbSB3aGVuIHJlZnJlc2hpbmcgb25lIGl0ZW0gb25seVxuICAgICAqICdwaWNrZXInIG9yICdpbnB1dCdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVJlbmRlcl0gLSB3aGV0aGVyIHRvIHJlLXJlbmRlciB0aGUgcGlja2VyIGVsZW1lbnRcbiAgICAgKiByZWdhcmRsZXNzIG9mIGl0cyBzdGF0ZSBpbnN0ZWFkIG9mIG9wdGltaXplZCByZWZyZXNoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGZvcmNlUmVuZGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIgPSB0YXJnZXQ7XG4gICAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBtb2RlO1xuICAgICAgaWYgKHRhcmdldCA9PT0gJ3BpY2tlcicpIHtcbiAgICAgICAgbW9kZSA9IDI7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCA9PT0gJ2lucHV0Jykge1xuICAgICAgICBtb2RlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGUgPSAzO1xuICAgICAgfVxuICAgICAgcmVmcmVzaFVJKHRoaXMsIG1vZGUsICFmb3JjZVJlbmRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW50ZXIgZWRpdCBtb2RlXG4gICAgICogTm90IGF2YWlsYWJsZSBvbiBpbmxpbmUgcGlja2VyIG9yIHdoZW4gdGhlIHBpY2tlciBlbGVtZW50IGlzIGhpZGRlblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVudGVyRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJFZGl0TW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLmlubGluZSB8fCAhdGhpcy5waWNrZXIuYWN0aXZlIHx8IHRoaXMuZWRpdE1vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LmFkZCgnaW4tZWRpdCcsICdib3JkZXItYmx1ZS03MDAnLCAnIWJvcmRlci1wcmltYXJ5LTcwMCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4aXQgZnJvbSBlZGl0IG1vZGVcbiAgICAgKiBOb3QgYXZhaWxhYmxlIG9uIGlubGluZSBwaWNrZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIGZ1bmN0aW9uIG9wdGlvbnNcbiAgICAgKiAtIHVwZGF0ZToge2Jvb2xlYW59IC0gd2hldGhlciB0byBjYWxsIHVwZGF0ZSgpIGFmdGVyIGV4aXRpbmdcbiAgICAgKiAgICAgSWYgZmFsc2UsIGlucHV0IGZpZWxkIGlzIHJldmVydCB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uXG4gICAgICogICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZXhpdEVkaXRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4aXRFZGl0TW9kZSgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodGhpcy5pbmxpbmUgfHwgIXRoaXMuZWRpdE1vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdXBkYXRlOiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICBkZWxldGUgdGhpcy5lZGl0TW9kZTtcbiAgICAgIHRoaXMuaW5wdXRGaWVsZC5jbGFzc0xpc3QucmVtb3ZlKCdpbi1lZGl0JywgJ2JvcmRlci1ibHVlLTcwMCcsICchYm9yZGVyLXByaW1hcnktNzAwJyk7XG4gICAgICBpZiAob3B0cy51cGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUob3B0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZm9ybWF0RGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXREYXRlJDEoZGF0ZSwgZm9ybWF0LCBsYW5nKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGxhbmcgJiYgbG9jYWxlc1tsYW5nXSB8fCBsb2NhbGVzLmVuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBkYXRlIHN0cmluZ1xuICAgICAqIEBwYXJhbSAge1N0cmluZ3xEYXRlfE51bWJlcn0gZGF0ZVN0ciAtIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBvciB0aW1lXG4gICAgICogdmFsdWUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBmb3JtYXQgLSBmb3JtYXQgc3RyaW5nIG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zXG4gICAgICogdG9WYWx1ZSgpIGN1c3RvbSBwYXJzZXIsIHdob3NlIHNpZ25hdHVyZSBpc1xuICAgICAqIC0gYXJnczpcbiAgICAgKiAgIC0gZGF0ZVN0cjoge1N0cmluZ3xEYXRlfE51bWJlcn0gLSB0aGUgZGF0ZVN0ciBwYXNzZWQgdG8gdGhlIG1ldGhvZFxuICAgICAqICAgLSBmb3JtYXQ6IHtPYmplY3R9IC0gdGhlIGZvcm1hdCBvYmplY3QgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAgICAgKiAgIC0gbG9jYWxlOiB7T2JqZWN0fSAtIGxvY2FsZSBmb3IgdGhlIGxhbmd1YWdlIHNwZWNpZmllZCBieSBgbGFuZ2BcbiAgICAgKiAtIHJldHVybjpcbiAgICAgKiAgICAge0RhdGV8TnVtYmVyfSBwYXJzZWQgZGF0ZSBvciBpdHMgdGltZSB2YWx1ZVxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2xhbmc9ZW5dIC0gbGFuZ3VhZ2UgY29kZSBmb3IgdGhlIGxvY2FsZSB0byB1c2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRpbWUgdmFsdWUgb2YgcGFyc2VkIGRhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZURhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VEYXRlJDEoZGF0ZVN0ciwgZm9ybWF0LCBsYW5nKSB7XG4gICAgICByZXR1cm4gcGFyc2VEYXRlKGRhdGVTdHIsIGZvcm1hdCwgbGFuZyAmJiBsb2NhbGVzW2xhbmddIHx8IGxvY2FsZXMuZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R9IC0gSW5zdGFsbGVkIGxvY2FsZXMgaW4gYFtsYW5ndWFnZUNvZGVdOiBsb2NhbGVPYmplY3RgIGZvcm1hdFxuICAgICAqIGVuYDpfRW5nbGlzaCAoVVMpXyBpcyBwcmUtaW5zdGFsbGVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxvY2FsZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBsb2NhbGVzO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vLyBmaWx0ZXIgb3V0IHRoZSBjb25maWcgb3B0aW9ucyBpbmFwcHJvcHJpdGUgdG8gcGFzcyB0byBEYXRlcGlja2VyXG5mdW5jdGlvbiBmaWx0ZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIG5ld09wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgZGVsZXRlIG5ld09wdHMuaW5wdXRzO1xuICBkZWxldGUgbmV3T3B0cy5hbGxvd09uZVNpZGVkUmFuZ2U7XG4gIGRlbGV0ZSBuZXdPcHRzLm1heE51bWJlck9mRGF0ZXM7IC8vIHRvIGVuc3VyZSBlYWNoIGRhdGVwaWNrZXIgaGFuZGxlcyBhIHNpbmdsZSBkYXRlXG5cbiAgcmV0dXJuIG5ld09wdHM7XG59XG5mdW5jdGlvbiBzZXR1cERhdGVwaWNrZXIocmFuZ2VwaWNrZXIsIGNoYW5nZURhdGVMaXN0ZW5lciwgZWwsIG9wdGlvbnMpIHtcbiAgcmVnaXN0ZXJMaXN0ZW5lcnMocmFuZ2VwaWNrZXIsIFtbZWwsICdjaGFuZ2VEYXRlJywgY2hhbmdlRGF0ZUxpc3RlbmVyXV0pO1xuICBuZXcgRGF0ZXBpY2tlcihlbCwgb3B0aW9ucywgcmFuZ2VwaWNrZXIpO1xufVxuZnVuY3Rpb24gb25DaGFuZ2VEYXRlKHJhbmdlcGlja2VyLCBldikge1xuICAvLyB0byBwcmV2ZW50IGJvdGggZGF0ZXBpY2tlcnMgdHJpZ2dlciB0aGUgb3RoZXIgc2lkZSdzIHVwZGF0ZSBlYWNoIG90aGVyXG4gIGlmIChyYW5nZXBpY2tlci5fdXBkYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmFuZ2VwaWNrZXIuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcbiAgaWYgKHRhcmdldC5kYXRlcGlja2VyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRhdGVwaWNrZXJzID0gcmFuZ2VwaWNrZXIuZGF0ZXBpY2tlcnM7XG4gIHZhciBzZXREYXRlT3B0aW9ucyA9IHtcbiAgICByZW5kZXI6IGZhbHNlXG4gIH07XG4gIHZhciBjaGFuZ2VkU2lkZSA9IHJhbmdlcGlja2VyLmlucHV0cy5pbmRleE9mKHRhcmdldCk7XG4gIHZhciBvdGhlclNpZGUgPSBjaGFuZ2VkU2lkZSA9PT0gMCA/IDEgOiAwO1xuICB2YXIgY2hhbmdlZERhdGUgPSBkYXRlcGlja2Vyc1tjaGFuZ2VkU2lkZV0uZGF0ZXNbMF07XG4gIHZhciBvdGhlckRhdGUgPSBkYXRlcGlja2Vyc1tvdGhlclNpZGVdLmRhdGVzWzBdO1xuICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCAmJiBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGlmIHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgPiB0aGUgZW5kLCBzd2FwIHRoZW1cbiAgICBpZiAoY2hhbmdlZFNpZGUgPT09IDAgJiYgY2hhbmdlZERhdGUgPiBvdGhlckRhdGUpIHtcbiAgICAgIGRhdGVwaWNrZXJzWzBdLnNldERhdGUob3RoZXJEYXRlLCBzZXREYXRlT3B0aW9ucyk7XG4gICAgICBkYXRlcGlja2Vyc1sxXS5zZXREYXRlKGNoYW5nZWREYXRlLCBzZXREYXRlT3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2VkU2lkZSA9PT0gMSAmJiBjaGFuZ2VkRGF0ZSA8IG90aGVyRGF0ZSkge1xuICAgICAgZGF0ZXBpY2tlcnNbMF0uc2V0RGF0ZShjaGFuZ2VkRGF0ZSwgc2V0RGF0ZU9wdGlvbnMpO1xuICAgICAgZGF0ZXBpY2tlcnNbMV0uc2V0RGF0ZShvdGhlckRhdGUsIHNldERhdGVPcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXJhbmdlcGlja2VyLmFsbG93T25lU2lkZWRSYW5nZSkge1xuICAgIC8vIHRvIHByZXZlbnQgdGhlIHJhbmdlIGZyb20gYmVjb21pbmcgb25lLXNpZGVkLCBjb3B5IGNoYW5nZWQgc2lkZSdzXG4gICAgLy8gc2VsZWN0aW9uIChubyBtYXR0ZXIgaWYgaXQncyBlbXB0eSkgdG8gdGhlIG90aGVyIHNpZGVcbiAgICBpZiAoY2hhbmdlZERhdGUgIT09IHVuZGVmaW5lZCB8fCBvdGhlckRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2V0RGF0ZU9wdGlvbnMuY2xlYXIgPSB0cnVlO1xuICAgICAgZGF0ZXBpY2tlcnNbb3RoZXJTaWRlXS5zZXREYXRlKGRhdGVwaWNrZXJzW2NoYW5nZWRTaWRlXS5kYXRlcywgc2V0RGF0ZU9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBkYXRlcGlja2Vyc1swXS5waWNrZXIudXBkYXRlKCkucmVuZGVyKCk7XG4gIGRhdGVwaWNrZXJzWzFdLnBpY2tlci51cGRhdGUoKS5yZW5kZXIoKTtcbiAgZGVsZXRlIHJhbmdlcGlja2VyLl91cGRhdGluZztcbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBkYXRlIHJhbmdlIHBpY2tlclxuICovXG52YXIgRGF0ZVJhbmdlUGlja2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRhdGUgcmFuZ2UgcGlja2VyXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgLSBlbGVtZW50IHRvIGJpbmQgYSBkYXRlIHJhbmdlIHBpY2tlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXSAtIGNvbmZpZyBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBEYXRlUmFuZ2VQaWNrZXIoZWxlbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0ZVJhbmdlUGlja2VyKTtcbiAgICB2YXIgaW5wdXRzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmlucHV0cykgPyBvcHRpb25zLmlucHV0cyA6IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpKTtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5yYW5nZXBpY2tlciA9IHRoaXM7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0cyA9IGlucHV0cy5zbGljZSgwLCAyKTtcbiAgICB0aGlzLmFsbG93T25lU2lkZWRSYW5nZSA9ICEhb3B0aW9ucy5hbGxvd09uZVNpZGVkUmFuZ2U7XG4gICAgdmFyIGNoYW5nZURhdGVMaXN0ZW5lciA9IG9uQ2hhbmdlRGF0ZS5iaW5kKG51bGwsIHRoaXMpO1xuICAgIHZhciBjbGVhbk9wdGlvbnMgPSBmaWx0ZXJPcHRpb25zKG9wdGlvbnMpO1xuICAgIC8vIGluIG9yZGVyIGZvciBpbml0aWFsIGRhdGUgc2V0dXAgdG8gd29yayByaWdodCB3aGVuIHBjaWNMdmVsID4gMCxcbiAgICAvLyBsZXQgRGF0ZXBpY2tlciBjb25zdHJ1Y3RvciBhZGQgdGhlIGluc3RhbmNlIHRvIHRoZSByYW5nZXBpY2tlclxuICAgIHZhciBkYXRlcGlja2VycyA9IFtdO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGF0ZXBpY2tlcnMnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVwaWNrZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldHVwRGF0ZXBpY2tlcih0aGlzLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIHRoaXMuaW5wdXRzWzBdLCBjbGVhbk9wdGlvbnMpO1xuICAgIHNldHVwRGF0ZXBpY2tlcih0aGlzLCBjaGFuZ2VEYXRlTGlzdGVuZXIsIHRoaXMuaW5wdXRzWzFdLCBjbGVhbk9wdGlvbnMpO1xuICAgIE9iamVjdC5mcmVlemUoZGF0ZXBpY2tlcnMpO1xuICAgIC8vIG5vcm1hbGl6ZSB0aGUgcmFuZ2UgaWYgaW5pdGFsIGRhdGVzIGFyZSBnaXZlblxuICAgIGlmIChkYXRlcGlja2Vyc1swXS5kYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbkNoYW5nZURhdGUodGhpcywge1xuICAgICAgICB0YXJnZXQ6IHRoaXMuaW5wdXRzWzBdXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRhdGVwaWNrZXJzWzFdLmRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7XG4gICAgICAgIHRhcmdldDogdGhpcy5pbnB1dHNbMV1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXl9IC0gc2VsZWN0ZWQgZGF0ZSBvZiB0aGUgbGlua2VkIGRhdGUgcGlja2Vyc1xuICAgKi9cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEYXRlUmFuZ2VQaWNrZXIsIFt7XG4gICAga2V5OiBcImRhdGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlcGlja2Vycy5sZW5ndGggPT09IDIgPyBbdGhpcy5kYXRlcGlja2Vyc1swXS5kYXRlc1swXSwgdGhpcy5kYXRlcGlja2Vyc1sxXS5kYXRlc1swXV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG5ldyB2YWx1ZXMgdG8gdGhlIGNvbmZpZyBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWcgb3B0aW9ucyB0byB1cGRhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5hbGxvd09uZVNpZGVkUmFuZ2UgPSAhIW9wdGlvbnMuYWxsb3dPbmVTaWRlZFJhbmdlO1xuICAgICAgdmFyIGNsZWFuT3B0aW9ucyA9IGZpbHRlck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLmRhdGVwaWNrZXJzWzBdLnNldE9wdGlvbnMoY2xlYW5PcHRpb25zKTtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlcnNbMV0uc2V0T3B0aW9ucyhjbGVhbk9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIERhdGVSYW5nZVBpY2tlciBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0RhdGVSYW5nZVBpY2tlcn0gLSB0aGUgaW5zdGFuY2UgZGVzdHJveWVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5kYXRlcGlja2Vyc1swXS5kZXN0cm95KCk7XG4gICAgICB0aGlzLmRhdGVwaWNrZXJzWzFdLmRlc3Ryb3koKTtcbiAgICAgIHVucmVnaXN0ZXJMaXN0ZW5lcnModGhpcyk7XG4gICAgICBkZWxldGUgdGhpcy5lbGVtZW50LnJhbmdlcGlja2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBvZiB0aGUgZGF0ZSByYW5nZVxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZCByZXR1cm5zIERhdGUgb2JqZWN0cyBieSBkZWZhdWx0LiBJZiBmb3JtYXQgc3RyaW5nIGlzIHBhc3NlZCxcbiAgICAgKiBpdCByZXR1cm5zIGRhdGUgc3RyaW5ncyBmb3JtYXR0ZWQgaW4gZ2l2ZW4gZm9ybWF0LlxuICAgICAqIFRoZSByZXN1bHQgYXJyYXkgYWx3YXlzIGNvbnRhaW5zIDIgaXRlbXMgKHN0YXJ0IGRhdGUvZW5kIGRhdGUpIGFuZFxuICAgICAqIHVuZGVmaW5lZCBpcyB1c2VkIGZvciB1bnNlbGVjdGVkIHNpZGUuIChlLmcuIElmIG5vbmUgaXMgc2VsZWN0ZWQsXG4gICAgICogdGhlIHJlc3VsdCB3aWxsIGJlIFt1bmRlZmluZWQsIHVuZGVmaW5lZF0uIElmIG9ubHkgdGhlIGVuZCBkYXRlIGlzIHNldFxuICAgICAqIHdoZW4gYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgdHJ1ZSwgW3VuZGVmaW5lZCwgZW5kRGF0ZV0gd2lsbFxuICAgICAqIGJlIHJldHVybmVkLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gW2Zvcm1hdF0gLSBGb3JtYXQgc3RyaW5nIHRvIHN0cmluZ2lmeSB0aGUgZGF0ZXNcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gLSBTdGFydCBhbmQgZW5kIGRhdGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGF0ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGZvcm1hdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZm9ybWF0ID8gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBfdGhpcy5kYXRlcGlja2Vyc1swXS5jb25maWcubG9jYWxlKTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuZGF0ZXMubWFwKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlID09PSB1bmRlZmluZWQgPyBkYXRlIDogY2FsbGJhY2soZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgb2YgdGhlIGRhdGUgcmFuZ2VcbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgY2FsbHMgZGF0ZXBpY2tlci5zZXREYXRlKCkgaW50ZXJuYWxseSB1c2luZyBlYWNoIG9mIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpbiBzdGFydOKGkmVuZCBvcmRlci5cbiAgICAgKlxuICAgICAqIFdoZW4gYSBjbGVhcjogdHJ1ZSBvcHRpb24gb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkIG9mIGEgZGF0ZSwgdGhlIG1ldGhvZFxuICAgICAqIGNsZWFycyB0aGUgZGF0ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIGludmFsaWQgZGF0ZSwgdGhlIHNhbWUgZGF0ZSBhcyB0aGUgY3VycmVudCBvbmUgb3IgYW4gb3B0aW9uIG9iamVjdFxuICAgICAqIHdpdGhvdXQgY2xlYXI6IHRydWUgaXMgcGFzc2VkLCB0aGUgbWV0aG9kIGNvbnNpZGVycyB0aGF0IGFyZ3VtZW50IGFzIGFuXG4gICAgICogXCJpbmVmZmVjdGl2ZVwiIGFyZ3VtZW50IGJlY2F1c2UgY2FsbGluZyBkYXRlcGlja2VyLnNldERhdGUoKSB3aXRoIHRob3NlXG4gICAgICogdmFsdWVzIG1ha2VzIG5vIGNoYW5nZXMgdG8gdGhlIGRhdGUgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgYWxsb3dPbmVTaWRlZFJhbmdlIGNvbmZpZyBvcHRpb24gaXMgZmFsc2UsIHBhc3Npbmcge2NsZWFyOiB0cnVlfVxuICAgICAqIHRvIGNsZWFyIHRoZSByYW5nZSB3b3JrcyBvbmx5IHdoZW4gaXQgaXMgZG9uZSB0byB0aGUgbGFzdCBlZmZlY3RpdmVcbiAgICAgKiBhcmd1bWVudCAoaW4gb3RoZXIgd29yZHMsIHBhc3NlZCB0byByYW5nZUVuZCBvciB0byByYW5nZVN0YXJ0IGFsb25nIHdpdGhcbiAgICAgKiBpbmVmZmVjdGl2ZSByYW5nZUVuZCkuIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHRoZSBkYXRlIHJhbmdlIGlzIGNoYW5nZWQsXG4gICAgICogaXQgZ2V0cyBub3JtYWxpemVkIGJhc2VkIG9uIHRoZSBsYXN0IGNoYW5nZSBhdCB0aGUgZW5kIG9mIHRoZSBjaGFuZ2luZ1xuICAgICAqIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ3xPYmplY3R9IHJhbmdlU3RhcnQgLSBTdGFydCBkYXRlIG9mIHRoZSByYW5nZVxuICAgICAqIG9yIHtjbGVhcjogdHJ1ZX0gdG8gY2xlYXIgdGhlIGRhdGVcbiAgICAgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ3xPYmplY3R9IHJhbmdlRW5kIC0gRW5kIGRhdGUgb2YgdGhlIHJhbmdlXG4gICAgICogb3Ige2NsZWFyOiB0cnVlfSB0byBjbGVhciB0aGUgZGF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldERhdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGVzKHJhbmdlU3RhcnQsIHJhbmdlRW5kKSB7XG4gICAgICB2YXIgX3RoaXMkZGF0ZXBpY2tlcnMgPSBfc2xpY2VkVG9BcnJheSh0aGlzLmRhdGVwaWNrZXJzLCAyKSxcbiAgICAgICAgZGF0ZXBpY2tlcjAgPSBfdGhpcyRkYXRlcGlja2Vyc1swXSxcbiAgICAgICAgZGF0ZXBpY2tlcjEgPSBfdGhpcyRkYXRlcGlja2Vyc1sxXTtcbiAgICAgIHZhciBvcmlnRGF0ZXMgPSB0aGlzLmRhdGVzO1xuXG4gICAgICAvLyBJZiByYW5nZSBub3JtYWxpemF0aW9uIHJ1bnMgb24gZXZlcnkgY2hhbmdlLCB3ZSBjYW4ndCBzZXQgYSBuZXcgcmFuZ2VcbiAgICAgIC8vIHRoYXQgc3RhcnRzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcmFuZ2UgY29ycmVjdGx5IGJlY2F1c2UgdGhlXG4gICAgICAvLyBub3JtYWxpemF0aW9uIHByb2Nlc3Mgc3dhcHMgc3RhcnTihpTvuI5lbmQgcmlnaHQgYWZ0ZXIgc2V0dGluZyB0aGUgbmV3IHN0YXJ0XG4gICAgICAvLyBkYXRlLiBUbyBwcmV2ZW50IHRoaXMsIHRoZSBub3JtYWxpemF0aW9uIHByb2Nlc3MgbmVlZHMgdG8gcnVuIG9uY2UgYWZ0ZXJcbiAgICAgIC8vIGJvdGggb2YgdGhlIG5ldyBkYXRlcyBhcmUgc2V0LlxuICAgICAgdGhpcy5fdXBkYXRpbmcgPSB0cnVlO1xuICAgICAgZGF0ZXBpY2tlcjAuc2V0RGF0ZShyYW5nZVN0YXJ0KTtcbiAgICAgIGRhdGVwaWNrZXIxLnNldERhdGUocmFuZ2VFbmQpO1xuICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0aW5nO1xuICAgICAgaWYgKGRhdGVwaWNrZXIxLmRhdGVzWzBdICE9PSBvcmlnRGF0ZXNbMV0pIHtcbiAgICAgICAgb25DaGFuZ2VEYXRlKHRoaXMsIHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuaW5wdXRzWzFdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChkYXRlcGlja2VyMC5kYXRlc1swXSAhPT0gb3JpZ0RhdGVzWzBdKSB7XG4gICAgICAgIG9uQ2hhbmdlRGF0ZSh0aGlzLCB7XG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLmlucHV0c1swXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuZXhwb3J0IHsgRGF0ZVJhbmdlUGlja2VyLCBEYXRlcGlja2VyIH07XG4iLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuaW1wb3J0IGluc3RhbmNlcyBmcm9tICcuLi8uLi9kb20vaW5zdGFuY2VzJztcbmltcG9ydCB7IERhdGVwaWNrZXIgYXMgRmxvd2JpdGVEYXRlcGlja2VyLCBEYXRlUmFuZ2VQaWNrZXIgYXMgRmxvd2JpdGVEYXRlUmFuZ2VQaWNrZXIsIH0gZnJvbSAnZmxvd2JpdGUtZGF0ZXBpY2tlcic7XG52YXIgRGVmYXVsdCA9IHtcbiAgICBkZWZhdWx0RGF0ZXBpY2tlcklkOiBudWxsLFxuICAgIGF1dG9oaWRlOiBmYWxzZSxcbiAgICBmb3JtYXQ6ICdtbS9kZC95eXl5JyxcbiAgICBtYXhEYXRlOiBudWxsLFxuICAgIG1pbkRhdGU6IG51bGwsXG4gICAgb3JpZW50YXRpb246ICdib3R0b20nLFxuICAgIGJ1dHRvbnM6IGZhbHNlLFxuICAgIGF1dG9TZWxlY3RUb2RheTogMCxcbiAgICB0aXRsZTogbnVsbCxcbiAgICBsYW5ndWFnZTogJ2VuJyxcbiAgICByYW5nZVBpY2tlcjogZmFsc2UsXG4gICAgb25TaG93OiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgb25IaWRlOiBmdW5jdGlvbiAoKSB7IH0sXG59O1xudmFyIERlZmF1bHRJbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgaWQ6IG51bGwsXG4gICAgb3ZlcnJpZGU6IHRydWUsXG59O1xudmFyIERhdGVwaWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZXBpY2tlcihkYXRlcGlja2VyRWwsIG9wdGlvbnMsIGluc3RhbmNlT3B0aW9ucykge1xuICAgICAgICBpZiAoZGF0ZXBpY2tlckVsID09PSB2b2lkIDApIHsgZGF0ZXBpY2tlckVsID0gbnVsbDsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBEZWZhdWx0OyB9XG4gICAgICAgIGlmIChpbnN0YW5jZU9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW5jZU9wdGlvbnMgPSBEZWZhdWx0SW5zdGFuY2VPcHRpb25zOyB9XG4gICAgICAgIHRoaXMuX2luc3RhbmNlSWQgPSBpbnN0YW5jZU9wdGlvbnMuaWRcbiAgICAgICAgICAgID8gaW5zdGFuY2VPcHRpb25zLmlkXG4gICAgICAgICAgICA6IGRhdGVwaWNrZXJFbC5pZDtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckVsID0gZGF0ZXBpY2tlckVsO1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VySW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERlZmF1bHQpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGluc3RhbmNlcy5hZGRJbnN0YW5jZSgnRGF0ZXBpY2tlcicsIHRoaXMsIHRoaXMuX2luc3RhbmNlSWQsIGluc3RhbmNlT3B0aW9ucy5vdmVycmlkZSk7XG4gICAgfVxuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRlcGlja2VyRWwgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yYW5nZVBpY2tlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXJJbnN0YW5jZSA9IG5ldyBGbG93Yml0ZURhdGVSYW5nZVBpY2tlcih0aGlzLl9kYXRlcGlja2VyRWwsIHRoaXMuX2dldERhdGVwaWNrZXJPcHRpb25zKHRoaXMuX29wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXJJbnN0YW5jZSA9IG5ldyBGbG93Yml0ZURhdGVwaWNrZXIodGhpcy5fZGF0ZXBpY2tlckVsLCB0aGlzLl9nZXREYXRlcGlja2VyT3B0aW9ucyh0aGlzLl9vcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLnJlbW92ZUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgaW5zdGFuY2VzLnJlbW92ZUluc3RhbmNlKCdEYXRlcGlja2VyJywgdGhpcy5faW5zdGFuY2VJZCk7XG4gICAgfTtcbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5kZXN0cm95QW5kUmVtb3ZlSW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbW92ZUluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5nZXREYXRlcGlja2VySW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VySW5zdGFuY2U7XG4gICAgfTtcbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yYW5nZVBpY2tlciAmJlxuICAgICAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckluc3RhbmNlIGluc3RhbmNlb2YgRmxvd2JpdGVEYXRlUmFuZ2VQaWNrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VySW5zdGFuY2UuZ2V0RGF0ZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMucmFuZ2VQaWNrZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGVwaWNrZXJJbnN0YW5jZSBpbnN0YW5jZW9mIEZsb3diaXRlRGF0ZXBpY2tlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVwaWNrZXJJbnN0YW5jZS5nZXREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLnNldERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yYW5nZVBpY2tlciAmJlxuICAgICAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckluc3RhbmNlIGluc3RhbmNlb2YgRmxvd2JpdGVEYXRlUmFuZ2VQaWNrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VySW5zdGFuY2Uuc2V0RGF0ZXMoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLnJhbmdlUGlja2VyICYmXG4gICAgICAgICAgICB0aGlzLl9kYXRlcGlja2VySW5zdGFuY2UgaW5zdGFuY2VvZiBGbG93Yml0ZURhdGVwaWNrZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VySW5zdGFuY2Uuc2V0RGF0ZShkYXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckluc3RhbmNlLnNob3coKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vblNob3codGhpcyk7XG4gICAgfTtcbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VySW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICB0aGlzLl9vcHRpb25zLm9uSGlkZSh0aGlzKTtcbiAgICB9O1xuICAgIERhdGVwaWNrZXIucHJvdG90eXBlLl9nZXREYXRlcGlja2VyT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBkYXRlcGlja2VyT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5idXR0b25zKSB7XG4gICAgICAgICAgICBkYXRlcGlja2VyT3B0aW9ucy50b2RheUJ0biA9IHRydWU7XG4gICAgICAgICAgICBkYXRlcGlja2VyT3B0aW9ucy5jbGVhckJ0biA9IHRydWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvU2VsZWN0VG9kYXkpIHtcbiAgICAgICAgICAgICAgICBkYXRlcGlja2VyT3B0aW9ucy50b2RheUJ0bk1vZGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9oaWRlKSB7XG4gICAgICAgICAgICBkYXRlcGlja2VyT3B0aW9ucy5hdXRvaGlkZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICAgICAgICBkYXRlcGlja2VyT3B0aW9ucy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5tYXhEYXRlKSB7XG4gICAgICAgICAgICBkYXRlcGlja2VyT3B0aW9ucy5tYXhEYXRlID0gb3B0aW9ucy5tYXhEYXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pbkRhdGUpIHtcbiAgICAgICAgICAgIGRhdGVwaWNrZXJPcHRpb25zLm1pbkRhdGUgPSBvcHRpb25zLm1pbkRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGRhdGVwaWNrZXJPcHRpb25zLm9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50aXRsZSkge1xuICAgICAgICAgICAgZGF0ZXBpY2tlck9wdGlvbnMudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICBkYXRlcGlja2VyT3B0aW9ucy5sYW5ndWFnZSA9IG9wdGlvbnMubGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVwaWNrZXJPcHRpb25zO1xuICAgIH07XG4gICAgRGF0ZXBpY2tlci5wcm90b3R5cGUudXBkYXRlT25TaG93ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMub25TaG93ID0gY2FsbGJhY2s7XG4gICAgfTtcbiAgICBEYXRlcGlja2VyLnByb3RvdHlwZS51cGRhdGVPbkhpZGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkhpZGUgPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIHJldHVybiBEYXRlcGlja2VyO1xufSgpKTtcbmV4cG9ydCBmdW5jdGlvbiBpbml0RGF0ZXBpY2tlcnMoKSB7XG4gICAgZG9jdW1lbnRcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRlcGlja2VyXSwgW2lubGluZS1kYXRlcGlja2VyXSwgW2RhdGUtcmFuZ2VwaWNrZXJdJylcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKCRkYXRlcGlja2VyRWwpIHtcbiAgICAgICAgaWYgKCRkYXRlcGlja2VyRWwpIHtcbiAgICAgICAgICAgIHZhciBidXR0b25zID0gJGRhdGVwaWNrZXJFbC5oYXNBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItYnV0dG9ucycpO1xuICAgICAgICAgICAgdmFyIGF1dG9zZWxlY3RUb2RheSA9ICRkYXRlcGlja2VyRWwuaGFzQXR0cmlidXRlKCdkYXRlcGlja2VyLWF1dG9zZWxlY3QtdG9kYXknKTtcbiAgICAgICAgICAgIHZhciBhdXRvaGlkZSA9ICRkYXRlcGlja2VyRWwuaGFzQXR0cmlidXRlKCdkYXRlcGlja2VyLWF1dG9oaWRlJyk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gJGRhdGVwaWNrZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItZm9ybWF0Jyk7XG4gICAgICAgICAgICB2YXIgbWF4RGF0ZSA9ICRkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLW1heC1kYXRlJyk7XG4gICAgICAgICAgICB2YXIgbWluRGF0ZSA9ICRkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLW1pbi1kYXRlJyk7XG4gICAgICAgICAgICB2YXIgb3JpZW50YXRpb25fMSA9ICRkYXRlcGlja2VyRWwuZ2V0QXR0cmlidXRlKCdkYXRlcGlja2VyLW9yaWVudGF0aW9uJyk7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSAkZGF0ZXBpY2tlckVsLmdldEF0dHJpYnV0ZSgnZGF0ZXBpY2tlci10aXRsZScpO1xuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gJGRhdGVwaWNrZXJFbC5nZXRBdHRyaWJ1dGUoJ2RhdGVwaWNrZXItbGFuZ3VhZ2UnKTtcbiAgICAgICAgICAgIHZhciByYW5nZVBpY2tlciA9ICRkYXRlcGlja2VyRWwuaGFzQXR0cmlidXRlKCdkYXRlLXJhbmdlcGlja2VyJyk7XG4gICAgICAgICAgICBuZXcgRGF0ZXBpY2tlcigkZGF0ZXBpY2tlckVsLCB7XG4gICAgICAgICAgICAgICAgYnV0dG9uczogYnV0dG9ucyA/IGJ1dHRvbnMgOiBEZWZhdWx0LmJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgYXV0b1NlbGVjdFRvZGF5OiBhdXRvc2VsZWN0VG9kYXlcbiAgICAgICAgICAgICAgICAgICAgPyBhdXRvc2VsZWN0VG9kYXlcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LmF1dG9TZWxlY3RUb2RheSxcbiAgICAgICAgICAgICAgICBhdXRvaGlkZTogYXV0b2hpZGUgPyBhdXRvaGlkZSA6IERlZmF1bHQuYXV0b2hpZGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQgPyBmb3JtYXQgOiBEZWZhdWx0LmZvcm1hdCxcbiAgICAgICAgICAgICAgICBtYXhEYXRlOiBtYXhEYXRlID8gbWF4RGF0ZSA6IERlZmF1bHQubWF4RGF0ZSxcbiAgICAgICAgICAgICAgICBtaW5EYXRlOiBtaW5EYXRlID8gbWluRGF0ZSA6IERlZmF1bHQubWluRGF0ZSxcbiAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb25fMVxuICAgICAgICAgICAgICAgICAgICA/IG9yaWVudGF0aW9uXzFcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0Lm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlIDogRGVmYXVsdC50aXRsZSxcbiAgICAgICAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UgPyBsYW5ndWFnZSA6IERlZmF1bHQubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgcmFuZ2VQaWNrZXI6IHJhbmdlUGlja2VyXG4gICAgICAgICAgICAgICAgICAgID8gcmFuZ2VQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0LnJhbmdlUGlja2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIGRhdGVwaWNrZXIgZWxlbWVudCBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIGNoZWNrIHRoZSBkYXRlcGlja2VyIGF0dHJpYnV0ZS5cIik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5EYXRlcGlja2VyID0gRGF0ZXBpY2tlcjtcbiAgICB3aW5kb3cuaW5pdERhdGVwaWNrZXJzID0gaW5pdERhdGVwaWNrZXJzO1xufVxuZXhwb3J0IGRlZmF1bHQgRGF0ZXBpY2tlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGluaXRBY2NvcmRpb25zIH0gZnJvbSAnLi9hY2NvcmRpb24nO1xuaW1wb3J0IHsgaW5pdENhcm91c2VscyB9IGZyb20gJy4vY2Fyb3VzZWwnO1xuaW1wb3J0IHsgaW5pdENvcHlDbGlwYm9hcmRzIH0gZnJvbSAnLi9jbGlwYm9hcmQnO1xuaW1wb3J0IHsgaW5pdENvbGxhcHNlcyB9IGZyb20gJy4vY29sbGFwc2UnO1xuaW1wb3J0IHsgaW5pdERpYWxzIH0gZnJvbSAnLi9kaWFsJztcbmltcG9ydCB7IGluaXREaXNtaXNzZXMgfSBmcm9tICcuL2Rpc21pc3MnO1xuaW1wb3J0IHsgaW5pdERyYXdlcnMgfSBmcm9tICcuL2RyYXdlcic7XG5pbXBvcnQgeyBpbml0RHJvcGRvd25zIH0gZnJvbSAnLi9kcm9wZG93bic7XG5pbXBvcnQgeyBpbml0SW5wdXRDb3VudGVycyB9IGZyb20gJy4vaW5wdXQtY291bnRlcic7XG5pbXBvcnQgeyBpbml0TW9kYWxzIH0gZnJvbSAnLi9tb2RhbCc7XG5pbXBvcnQgeyBpbml0UG9wb3ZlcnMgfSBmcm9tICcuL3BvcG92ZXInO1xuaW1wb3J0IHsgaW5pdFRhYnMgfSBmcm9tICcuL3RhYnMnO1xuaW1wb3J0IHsgaW5pdFRvb2x0aXBzIH0gZnJvbSAnLi90b29sdGlwJztcbmltcG9ydCB7IGluaXREYXRlcGlja2VycyB9IGZyb20gJy4vZGF0ZXBpY2tlcic7XG5leHBvcnQgZnVuY3Rpb24gaW5pdEZsb3diaXRlKCkge1xuICAgIGluaXRBY2NvcmRpb25zKCk7XG4gICAgaW5pdENvbGxhcHNlcygpO1xuICAgIGluaXRDYXJvdXNlbHMoKTtcbiAgICBpbml0RGlzbWlzc2VzKCk7XG4gICAgaW5pdERyb3Bkb3ducygpO1xuICAgIGluaXRNb2RhbHMoKTtcbiAgICBpbml0RHJhd2VycygpO1xuICAgIGluaXRUYWJzKCk7XG4gICAgaW5pdFRvb2x0aXBzKCk7XG4gICAgaW5pdFBvcG92ZXJzKCk7XG4gICAgaW5pdERpYWxzKCk7XG4gICAgaW5pdElucHV0Q291bnRlcnMoKTtcbiAgICBpbml0Q29weUNsaXBib2FyZHMoKTtcbiAgICBpbml0RGF0ZXBpY2tlcnMoKTtcbn1cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5pbml0Rmxvd2JpdGUgPSBpbml0Rmxvd2JpdGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgRXZlbnRzIGZyb20gJy4vZG9tL2V2ZW50cyc7XG5pbXBvcnQgeyBpbml0QWNjb3JkaW9ucyB9IGZyb20gJy4vY29tcG9uZW50cy9hY2NvcmRpb24nO1xuaW1wb3J0IHsgaW5pdENvbGxhcHNlcyB9IGZyb20gJy4vY29tcG9uZW50cy9jb2xsYXBzZSc7XG5pbXBvcnQgeyBpbml0Q2Fyb3VzZWxzIH0gZnJvbSAnLi9jb21wb25lbnRzL2Nhcm91c2VsJztcbmltcG9ydCB7IGluaXREaXNtaXNzZXMgfSBmcm9tICcuL2NvbXBvbmVudHMvZGlzbWlzcyc7XG5pbXBvcnQgeyBpbml0RHJvcGRvd25zIH0gZnJvbSAnLi9jb21wb25lbnRzL2Ryb3Bkb3duJztcbmltcG9ydCB7IGluaXRNb2RhbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwnO1xuaW1wb3J0IHsgaW5pdERyYXdlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvZHJhd2VyJztcbmltcG9ydCB7IGluaXRUYWJzIH0gZnJvbSAnLi9jb21wb25lbnRzL3RhYnMnO1xuaW1wb3J0IHsgaW5pdFRvb2x0aXBzIH0gZnJvbSAnLi9jb21wb25lbnRzL3Rvb2x0aXAnO1xuaW1wb3J0IHsgaW5pdFBvcG92ZXJzIH0gZnJvbSAnLi9jb21wb25lbnRzL3BvcG92ZXInO1xuaW1wb3J0IHsgaW5pdERpYWxzIH0gZnJvbSAnLi9jb21wb25lbnRzL2RpYWwnO1xuaW1wb3J0IHsgaW5pdElucHV0Q291bnRlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvaW5wdXQtY291bnRlcic7XG5pbXBvcnQgeyBpbml0Q29weUNsaXBib2FyZHMgfSBmcm9tICcuL2NvbXBvbmVudHMvY2xpcGJvYXJkJztcbmltcG9ydCB7IGluaXREYXRlcGlja2VycyB9IGZyb20gJy4vY29tcG9uZW50cy9kYXRlcGlja2VyJztcbmltcG9ydCAnLi9jb21wb25lbnRzL2luZGV4JztcbmltcG9ydCAnLi90eXBlcy9kZWNsYXJhdGlvbnMnO1xuLy8gc2V0dXAgZXZlbnRzIGZvciBkYXRhIGF0dHJpYnV0ZXNcbnZhciBldmVudHMgPSBuZXcgRXZlbnRzKCdsb2FkJywgW1xuICAgIGluaXRBY2NvcmRpb25zLFxuICAgIGluaXRDb2xsYXBzZXMsXG4gICAgaW5pdENhcm91c2VscyxcbiAgICBpbml0RGlzbWlzc2VzLFxuICAgIGluaXREcm9wZG93bnMsXG4gICAgaW5pdE1vZGFscyxcbiAgICBpbml0RHJhd2VycyxcbiAgICBpbml0VGFicyxcbiAgICBpbml0VG9vbHRpcHMsXG4gICAgaW5pdFBvcG92ZXJzLFxuICAgIGluaXREaWFscyxcbiAgICBpbml0SW5wdXRDb3VudGVycyxcbiAgICBpbml0Q29weUNsaXBib2FyZHMsXG4gICAgaW5pdERhdGVwaWNrZXJzLFxuXSk7XG5ldmVudHMuaW5pdCgpO1xuLy8gZXhwb3J0IGFsbCBjb21wb25lbnRzXG5leHBvcnQgeyBkZWZhdWx0IGFzIEFjY29yZGlvbiB9IGZyb20gJy4vY29tcG9uZW50cy9hY2NvcmRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDYXJvdXNlbCB9IGZyb20gJy4vY29tcG9uZW50cy9jYXJvdXNlbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbGxhcHNlIH0gZnJvbSAnLi9jb21wb25lbnRzL2NvbGxhcHNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlhbCB9IGZyb20gJy4vY29tcG9uZW50cy9kaWFsJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGlzbWlzcyB9IGZyb20gJy4vY29tcG9uZW50cy9kaXNtaXNzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRHJhd2VyIH0gZnJvbSAnLi9jb21wb25lbnRzL2RyYXdlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERyb3Bkb3duIH0gZnJvbSAnLi9jb21wb25lbnRzL2Ryb3Bkb3duJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTW9kYWwgfSBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb3BvdmVyIH0gZnJvbSAnLi9jb21wb25lbnRzL3BvcG92ZXInO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUYWJzIH0gZnJvbSAnLi9jb21wb25lbnRzL3RhYnMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb29sdGlwIH0gZnJvbSAnLi9jb21wb25lbnRzL3Rvb2x0aXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBJbnB1dENvdW50ZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvaW5wdXQtY291bnRlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIENvcHlDbGlwYm9hcmQgfSBmcm9tICcuL2NvbXBvbmVudHMvY2xpcGJvYXJkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0ZXBpY2tlciB9IGZyb20gJy4vY29tcG9uZW50cy9kYXRlcGlja2VyJztcbi8vIGV4cG9ydCBhbGwgdHlwZXNcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9hY2NvcmRpb24vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2Nhcm91c2VsL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9jb2xsYXBzZS90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZGlhbC90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZGlzbWlzcy90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZHJhd2VyL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kcm9wZG93bi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvbW9kYWwvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL3BvcG92ZXIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL3RhYnMvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL3Rvb2x0aXAvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2lucHV0LWNvdW50ZXIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2NsaXBib2FyZC90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZGF0ZXBpY2tlci90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL2RvbS90eXBlcyc7XG4vLyBleHBvcnQgYWxsIGludGVyZmFjZXNcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9hY2NvcmRpb24vaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9jYXJvdXNlbC9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2NvbGxhcHNlL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvZGlhbC9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2Rpc21pc3MvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kcmF3ZXIvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy9kcm9wZG93bi9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL21vZGFsL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvcG9wb3Zlci9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL3RhYnMvaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwL2ludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvaW5wdXQtY291bnRlci9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2NsaXBib2FyZC9pbnRlcmZhY2UnO1xuZXhwb3J0ICogZnJvbSAnLi9jb21wb25lbnRzL2RhdGVwaWNrZXIvaW50ZXJmYWNlJztcbi8vIGV4cG9ydCBpbml0IGZ1bmN0aW9uc1xuZXhwb3J0IHsgaW5pdEFjY29yZGlvbnMgfSBmcm9tICcuL2NvbXBvbmVudHMvYWNjb3JkaW9uJztcbmV4cG9ydCB7IGluaXRDYXJvdXNlbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvY2Fyb3VzZWwnO1xuZXhwb3J0IHsgaW5pdENvbGxhcHNlcyB9IGZyb20gJy4vY29tcG9uZW50cy9jb2xsYXBzZSc7XG5leHBvcnQgeyBpbml0RGlhbHMgfSBmcm9tICcuL2NvbXBvbmVudHMvZGlhbCc7XG5leHBvcnQgeyBpbml0RGlzbWlzc2VzIH0gZnJvbSAnLi9jb21wb25lbnRzL2Rpc21pc3MnO1xuZXhwb3J0IHsgaW5pdERyYXdlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvZHJhd2VyJztcbmV4cG9ydCB7IGluaXREcm9wZG93bnMgfSBmcm9tICcuL2NvbXBvbmVudHMvZHJvcGRvd24nO1xuZXhwb3J0IHsgaW5pdE1vZGFscyB9IGZyb20gJy4vY29tcG9uZW50cy9tb2RhbCc7XG5leHBvcnQgeyBpbml0UG9wb3ZlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvcG9wb3Zlcic7XG5leHBvcnQgeyBpbml0VGFicyB9IGZyb20gJy4vY29tcG9uZW50cy90YWJzJztcbmV4cG9ydCB7IGluaXRUb29sdGlwcyB9IGZyb20gJy4vY29tcG9uZW50cy90b29sdGlwJztcbmV4cG9ydCB7IGluaXRJbnB1dENvdW50ZXJzIH0gZnJvbSAnLi9jb21wb25lbnRzL2lucHV0LWNvdW50ZXInO1xuZXhwb3J0IHsgaW5pdENvcHlDbGlwYm9hcmRzIH0gZnJvbSAnLi9jb21wb25lbnRzL2NsaXBib2FyZCc7XG5leHBvcnQgeyBpbml0RGF0ZXBpY2tlcnMgfSBmcm9tICcuL2NvbXBvbmVudHMvZGF0ZXBpY2tlcic7XG4vLyBleHBvcnQgYWxsIGluaXQgZnVuY3Rpb25zXG5leHBvcnQgeyBpbml0Rmxvd2JpdGUgfSBmcm9tICcuL2NvbXBvbmVudHMvaW5kZXgnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gcHV0IHNpdGUtd2lkZSBkZXBlbmRlbmNpZXMgaGVyZS5cbi8vIEhUTVggc2V0dXA6IGh0dHBzOi8vaHRteC5vcmcvZG9jcy8jaW5zdGFsbGluZ1xuaW1wb3J0ICcuL2h0bXgnO1xuaW1wb3J0ICcuL2FscGluZSc7XG5pbXBvcnQgJ2Zsb3diaXRlJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5293\n")},4037:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar htmx = (function() {\n  'use strict'\n\n  // Public API\n  const htmx = {\n    // Tsc madness here, assigning the functions directly results in an invalid TypeScript output, but reassigning is fine\n    /* Event processing */\n    /** @type {typeof onLoadHelper} */\n    onLoad: null,\n    /** @type {typeof processNode} */\n    process: null,\n    /** @type {typeof addEventListenerImpl} */\n    on: null,\n    /** @type {typeof removeEventListenerImpl} */\n    off: null,\n    /** @type {typeof triggerEvent} */\n    trigger: null,\n    /** @type {typeof ajaxHelper} */\n    ajax: null,\n    /* DOM querying helpers */\n    /** @type {typeof find} */\n    find: null,\n    /** @type {typeof findAll} */\n    findAll: null,\n    /** @type {typeof closest} */\n    closest: null,\n    /**\n     * Returns the input values that would resolve for a given element via the htmx value resolution mechanism\n     *\n     * @see https://htmx.org/api/#values\n     *\n     * @param {Element} elt the element to resolve values on\n     * @param {HttpVerb} type the request type (e.g. **get** or **post**) non-GET's will include the enclosing form of the element. Defaults to **post**\n     * @returns {Object}\n     */\n    values: function(elt, type) {\n      const inputValues = getInputValues(elt, type || 'post')\n      return inputValues.values\n    },\n    /* DOM manipulation helpers */\n    /** @type {typeof removeElement} */\n    remove: null,\n    /** @type {typeof addClassToElement} */\n    addClass: null,\n    /** @type {typeof removeClassFromElement} */\n    removeClass: null,\n    /** @type {typeof toggleClassOnElement} */\n    toggleClass: null,\n    /** @type {typeof takeClassForElement} */\n    takeClass: null,\n    /** @type {typeof swap} */\n    swap: null,\n    /* Extension entrypoints */\n    /** @type {typeof defineExtension} */\n    defineExtension: null,\n    /** @type {typeof removeExtension} */\n    removeExtension: null,\n    /* Debugging */\n    /** @type {typeof logAll} */\n    logAll: null,\n    /** @type {typeof logNone} */\n    logNone: null,\n    /* Debugging */\n    /**\n     * The logger htmx uses to log with\n     *\n     * @see https://htmx.org/api/#logger\n     */\n    logger: null,\n    /**\n     * A property holding the configuration htmx uses at runtime.\n     *\n     * Note that using a [meta tag](https://htmx.org/docs/#config) is the preferred mechanism for setting these properties.\n     *\n     * @see https://htmx.org/api/#config\n     */\n    config: {\n      /**\n       * Whether to use history.\n       * @type boolean\n       * @default true\n       */\n      historyEnabled: true,\n      /**\n       * The number of pages to keep in **localStorage** for history support.\n       * @type number\n       * @default 10\n       */\n      historyCacheSize: 10,\n      /**\n       * @type boolean\n       * @default false\n       */\n      refreshOnHistoryMiss: false,\n      /**\n       * The default swap style to use if **[hx-swap](https://htmx.org/attributes/hx-swap)** is omitted.\n       * @type HtmxSwapStyle\n       * @default 'innerHTML'\n       */\n      defaultSwapStyle: 'innerHTML',\n      /**\n       * The default delay between receiving a response from the server and doing the swap.\n       * @type number\n       * @default 0\n       */\n      defaultSwapDelay: 0,\n      /**\n       * The default delay between completing the content swap and settling attributes.\n       * @type number\n       * @default 20\n       */\n      defaultSettleDelay: 20,\n      /**\n       * If true, htmx will inject a small amount of CSS into the page to make indicators invisible unless the **htmx-indicator** class is present.\n       * @type boolean\n       * @default true\n       */\n      includeIndicatorStyles: true,\n      /**\n       * The class to place on indicators when a request is in flight.\n       * @type string\n       * @default 'htmx-indicator'\n       */\n      indicatorClass: 'htmx-indicator',\n      /**\n       * The class to place on triggering elements when a request is in flight.\n       * @type string\n       * @default 'htmx-request'\n       */\n      requestClass: 'htmx-request',\n      /**\n       * The class to temporarily place on elements that htmx has added to the DOM.\n       * @type string\n       * @default 'htmx-added'\n       */\n      addedClass: 'htmx-added',\n      /**\n       * The class to place on target elements when htmx is in the settling phase.\n       * @type string\n       * @default 'htmx-settling'\n       */\n      settlingClass: 'htmx-settling',\n      /**\n       * The class to place on target elements when htmx is in the swapping phase.\n       * @type string\n       * @default 'htmx-swapping'\n       */\n      swappingClass: 'htmx-swapping',\n      /**\n       * Allows the use of eval-like functionality in htmx, to enable **hx-vars**, trigger conditions & script tag evaluation. Can be set to **false** for CSP compatibility.\n       * @type boolean\n       * @default true\n       */\n      allowEval: true,\n      /**\n       * If set to false, disables the interpretation of script tags.\n       * @type boolean\n       * @default true\n       */\n      allowScriptTags: true,\n      /**\n       * If set, the nonce will be added to inline scripts.\n       * @type string\n       * @default ''\n       */\n      inlineScriptNonce: '',\n      /**\n       * If set, the nonce will be added to inline styles.\n       * @type string\n       * @default ''\n       */\n      inlineStyleNonce: '',\n      /**\n       * The attributes to settle during the settling phase.\n       * @type string[]\n       * @default ['class', 'style', 'width', 'height']\n       */\n      attributesToSettle: ['class', 'style', 'width', 'height'],\n      /**\n       * Allow cross-site Access-Control requests using credentials such as cookies, authorization headers or TLS client certificates.\n       * @type boolean\n       * @default false\n       */\n      withCredentials: false,\n      /**\n       * @type number\n       * @default 0\n       */\n      timeout: 0,\n      /**\n       * The default implementation of **getWebSocketReconnectDelay** for reconnecting after unexpected connection loss by the event code **Abnormal Closure**, **Service Restart** or **Try Again Later**.\n       * @type {'full-jitter' | ((retryCount:number) => number)}\n       * @default \"full-jitter\"\n       */\n      wsReconnectDelay: 'full-jitter',\n      /**\n       * The type of binary data being received over the WebSocket connection\n       * @type BinaryType\n       * @default 'blob'\n       */\n      wsBinaryType: 'blob',\n      /**\n       * @type string\n       * @default '[hx-disable], [data-hx-disable]'\n       */\n      disableSelector: '[hx-disable], [data-hx-disable]',\n      /**\n       * @type {'auto' | 'instant' | 'smooth'}\n       * @default 'instant'\n       */\n      scrollBehavior: 'instant',\n      /**\n       * If the focused element should be scrolled into view.\n       * @type boolean\n       * @default false\n       */\n      defaultFocusScroll: false,\n      /**\n       * If set to true htmx will include a cache-busting parameter in GET requests to avoid caching partial responses by the browser\n       * @type boolean\n       * @default false\n       */\n      getCacheBusterParam: false,\n      /**\n       * If set to true, htmx will use the View Transition API when swapping in new content.\n       * @type boolean\n       * @default false\n       */\n      globalViewTransitions: false,\n      /**\n       * htmx will format requests with these methods by encoding their parameters in the URL, not the request body\n       * @type {(HttpVerb)[]}\n       * @default ['get', 'delete']\n       */\n      methodsThatUseUrlParams: ['get', 'delete'],\n      /**\n       * If set to true, disables htmx-based requests to non-origin hosts.\n       * @type boolean\n       * @default false\n       */\n      selfRequestsOnly: true,\n      /**\n       * If set to true htmx will not update the title of the document when a title tag is found in new content\n       * @type boolean\n       * @default false\n       */\n      ignoreTitle: false,\n      /**\n       * Whether the target of a boosted element is scrolled into the viewport.\n       * @type boolean\n       * @default true\n       */\n      scrollIntoViewOnBoost: true,\n      /**\n       * The cache to store evaluated trigger specifications into.\n       * You may define a simple object to use a never-clearing cache, or implement your own system using a [proxy object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n       * @type {Object|null}\n       * @default null\n       */\n      triggerSpecsCache: null,\n      /** @type boolean */\n      disableInheritance: false,\n      /** @type HtmxResponseHandlingConfig[] */\n      responseHandling: [\n        { code: '204', swap: false },\n        { code: '[23]..', swap: true },\n        { code: '[45]..', swap: false, error: true }\n      ],\n      /**\n       * Whether to process OOB swaps on elements that are nested within the main response element.\n       * @type boolean\n       * @default true\n       */\n      allowNestedOobSwaps: true\n    },\n    /** @type {typeof parseInterval} */\n    parseInterval: null,\n    /** @type {typeof internalEval} */\n    _: null,\n    version: '2.0.3'\n  }\n  // Tsc madness part 2\n  htmx.onLoad = onLoadHelper\n  htmx.process = processNode\n  htmx.on = addEventListenerImpl\n  htmx.off = removeEventListenerImpl\n  htmx.trigger = triggerEvent\n  htmx.ajax = ajaxHelper\n  htmx.find = find\n  htmx.findAll = findAll\n  htmx.closest = closest\n  htmx.remove = removeElement\n  htmx.addClass = addClassToElement\n  htmx.removeClass = removeClassFromElement\n  htmx.toggleClass = toggleClassOnElement\n  htmx.takeClass = takeClassForElement\n  htmx.swap = swap\n  htmx.defineExtension = defineExtension\n  htmx.removeExtension = removeExtension\n  htmx.logAll = logAll\n  htmx.logNone = logNone\n  htmx.parseInterval = parseInterval\n  htmx._ = internalEval\n\n  const internalAPI = {\n    addTriggerHandler,\n    bodyContains,\n    canAccessLocalStorage,\n    findThisElement,\n    filterValues,\n    swap,\n    hasAttribute,\n    getAttributeValue,\n    getClosestAttributeValue,\n    getClosestMatch,\n    getExpressionVars,\n    getHeaders,\n    getInputValues,\n    getInternalData,\n    getSwapSpecification,\n    getTriggerSpecs,\n    getTarget,\n    makeFragment,\n    mergeObjects,\n    makeSettleInfo,\n    oobSwap,\n    querySelectorExt,\n    settleImmediately,\n    shouldCancel,\n    triggerEvent,\n    triggerErrorEvent,\n    withExtensions\n  }\n\n  const VERBS = ['get', 'post', 'put', 'delete', 'patch']\n  const VERB_SELECTOR = VERBS.map(function(verb) {\n    return '[hx-' + verb + '], [data-hx-' + verb + ']'\n  }).join(', ')\n\n  //= ===================================================================\n  // Utilities\n  //= ===================================================================\n\n  /**\n   * Parses an interval string consistent with the way htmx does. Useful for plugins that have timing-related attributes.\n   *\n   * Caution: Accepts an int followed by either **s** or **ms**. All other values use **parseFloat**\n   *\n   * @see https://htmx.org/api/#parseInterval\n   *\n   * @param {string} str timing string\n   * @returns {number|undefined}\n   */\n  function parseInterval(str) {\n    if (str == undefined) {\n      return undefined\n    }\n\n    let interval = NaN\n    if (str.slice(-2) == 'ms') {\n      interval = parseFloat(str.slice(0, -2))\n    } else if (str.slice(-1) == 's') {\n      interval = parseFloat(str.slice(0, -1)) * 1000\n    } else if (str.slice(-1) == 'm') {\n      interval = parseFloat(str.slice(0, -1)) * 1000 * 60\n    } else {\n      interval = parseFloat(str)\n    }\n    return isNaN(interval) ? undefined : interval\n  }\n\n  /**\n   * @param {Node} elt\n   * @param {string} name\n   * @returns {(string | null)}\n   */\n  function getRawAttribute(elt, name) {\n    return elt instanceof Element && elt.getAttribute(name)\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {string} qualifiedName\n   * @returns {boolean}\n   */\n  // resolve with both hx and data-hx prefixes\n  function hasAttribute(elt, qualifiedName) {\n    return !!elt.hasAttribute && (elt.hasAttribute(qualifiedName) ||\n      elt.hasAttribute('data-' + qualifiedName))\n  }\n\n  /**\n   *\n   * @param {Node} elt\n   * @param {string} qualifiedName\n   * @returns {(string | null)}\n   */\n  function getAttributeValue(elt, qualifiedName) {\n    return getRawAttribute(elt, qualifiedName) || getRawAttribute(elt, 'data-' + qualifiedName)\n  }\n\n  /**\n   * @param {Node} elt\n   * @returns {Node | null}\n   */\n  function parentElt(elt) {\n    const parent = elt.parentElement\n    if (!parent && elt.parentNode instanceof ShadowRoot) return elt.parentNode\n    return parent\n  }\n\n  /**\n   * @returns {Document}\n   */\n  function getDocument() {\n    return document\n  }\n\n  /**\n   * @param {Node} elt\n   * @param {boolean} global\n   * @returns {Node|Document}\n   */\n  function getRootNode(elt, global) {\n    return elt.getRootNode ? elt.getRootNode({ composed: global }) : getDocument()\n  }\n\n  /**\n   * @param {Node} elt\n   * @param {(e:Node) => boolean} condition\n   * @returns {Node | null}\n   */\n  function getClosestMatch(elt, condition) {\n    while (elt && !condition(elt)) {\n      elt = parentElt(elt)\n    }\n\n    return elt || null\n  }\n\n  /**\n   * @param {Element} initialElement\n   * @param {Element} ancestor\n   * @param {string} attributeName\n   * @returns {string|null}\n   */\n  function getAttributeValueWithDisinheritance(initialElement, ancestor, attributeName) {\n    const attributeValue = getAttributeValue(ancestor, attributeName)\n    const disinherit = getAttributeValue(ancestor, 'hx-disinherit')\n    var inherit = getAttributeValue(ancestor, 'hx-inherit')\n    if (initialElement !== ancestor) {\n      if (htmx.config.disableInheritance) {\n        if (inherit && (inherit === '*' || inherit.split(' ').indexOf(attributeName) >= 0)) {\n          return attributeValue\n        } else {\n          return null\n        }\n      }\n      if (disinherit && (disinherit === '*' || disinherit.split(' ').indexOf(attributeName) >= 0)) {\n        return 'unset'\n      }\n    }\n    return attributeValue\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {string} attributeName\n   * @returns {string | null}\n   */\n  function getClosestAttributeValue(elt, attributeName) {\n    let closestAttr = null\n    getClosestMatch(elt, function(e) {\n      return !!(closestAttr = getAttributeValueWithDisinheritance(elt, asElement(e), attributeName))\n    })\n    if (closestAttr !== 'unset') {\n      return closestAttr\n    }\n  }\n\n  /**\n   * @param {Node} elt\n   * @param {string} selector\n   * @returns {boolean}\n   */\n  function matches(elt, selector) {\n    // @ts-ignore: non-standard properties for browser compatibility\n    // noinspection JSUnresolvedVariable\n    const matchesFunction = elt instanceof Element && (elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector)\n    return !!matchesFunction && matchesFunction.call(elt, selector)\n  }\n\n  /**\n   * @param {string} str\n   * @returns {string}\n   */\n  function getStartTag(str) {\n    const tagMatcher = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i\n    const match = tagMatcher.exec(str)\n    if (match) {\n      return match[1].toLowerCase()\n    } else {\n      return ''\n    }\n  }\n\n  /**\n   * @param {string} resp\n   * @returns {Document}\n   */\n  function parseHTML(resp) {\n    const parser = new DOMParser()\n    return parser.parseFromString(resp, 'text/html')\n  }\n\n  /**\n   * @param {DocumentFragment} fragment\n   * @param {Node} elt\n   */\n  function takeChildrenFor(fragment, elt) {\n    while (elt.childNodes.length > 0) {\n      fragment.append(elt.childNodes[0])\n    }\n  }\n\n  /**\n   * @param {HTMLScriptElement} script\n   * @returns {HTMLScriptElement}\n   */\n  function duplicateScript(script) {\n    const newScript = getDocument().createElement('script')\n    forEach(script.attributes, function(attr) {\n      newScript.setAttribute(attr.name, attr.value)\n    })\n    newScript.textContent = script.textContent\n    newScript.async = false\n    if (htmx.config.inlineScriptNonce) {\n      newScript.nonce = htmx.config.inlineScriptNonce\n    }\n    return newScript\n  }\n\n  /**\n   * @param {HTMLScriptElement} script\n   * @returns {boolean}\n   */\n  function isJavaScriptScriptNode(script) {\n    return script.matches('script') && (script.type === 'text/javascript' || script.type === 'module' || script.type === '')\n  }\n\n  /**\n   * we have to make new copies of script tags that we are going to insert because\n   * SOME browsers (not saying who, but it involves an element and an animal) don't\n   * execute scripts created in <template> tags when they are inserted into the DOM\n   * and all the others do lmao\n   * @param {DocumentFragment} fragment\n   */\n  function normalizeScriptTags(fragment) {\n    Array.from(fragment.querySelectorAll('script')).forEach(/** @param {HTMLScriptElement} script */ (script) => {\n      if (isJavaScriptScriptNode(script)) {\n        const newScript = duplicateScript(script)\n        const parent = script.parentNode\n        try {\n          parent.insertBefore(newScript, script)\n        } catch (e) {\n          logError(e)\n        } finally {\n          script.remove()\n        }\n      }\n    })\n  }\n\n  /**\n   * @typedef {DocumentFragment & {title?: string}} DocumentFragmentWithTitle\n   * @description  a document fragment representing the response HTML, including\n   * a `title` property for any title information found\n   */\n\n  /**\n   * @param {string} response HTML\n   * @returns {DocumentFragmentWithTitle}\n   */\n  function makeFragment(response) {\n    // strip head tag to determine shape of response we are dealing with\n    const responseWithNoHead = response.replace(/<head(\\s[^>]*)?>[\\s\\S]*?<\\/head>/i, '')\n    const startTag = getStartTag(responseWithNoHead)\n    /** @type DocumentFragmentWithTitle */\n    let fragment\n    if (startTag === 'html') {\n      // if it is a full document, parse it and return the body\n      fragment = /** @type DocumentFragmentWithTitle */ (new DocumentFragment())\n      const doc = parseHTML(response)\n      takeChildrenFor(fragment, doc.body)\n      fragment.title = doc.title\n    } else if (startTag === 'body') {\n      // parse body w/o wrapping in template\n      fragment = /** @type DocumentFragmentWithTitle */ (new DocumentFragment())\n      const doc = parseHTML(responseWithNoHead)\n      takeChildrenFor(fragment, doc.body)\n      fragment.title = doc.title\n    } else {\n      // otherwise we have non-body partial HTML content, so wrap it in a template to maximize parsing flexibility\n      const doc = parseHTML('<body><template class=\"internal-htmx-wrapper\">' + responseWithNoHead + '</template></body>')\n      fragment = /** @type DocumentFragmentWithTitle */ (doc.querySelector('template').content)\n      // extract title into fragment for later processing\n      fragment.title = doc.title\n\n      // for legacy reasons we support a title tag at the root level of non-body responses, so we need to handle it\n      var titleElement = fragment.querySelector('title')\n      if (titleElement && titleElement.parentNode === fragment) {\n        titleElement.remove()\n        fragment.title = titleElement.innerText\n      }\n    }\n    if (fragment) {\n      if (htmx.config.allowScriptTags) {\n        normalizeScriptTags(fragment)\n      } else {\n        // remove all script tags if scripts are disabled\n        fragment.querySelectorAll('script').forEach((script) => script.remove())\n      }\n    }\n    return fragment\n  }\n\n  /**\n   * @param {Function} func\n   */\n  function maybeCall(func) {\n    if (func) {\n      func()\n    }\n  }\n\n  /**\n   * @param {any} o\n   * @param {string} type\n   * @returns\n   */\n  function isType(o, type) {\n    return Object.prototype.toString.call(o) === '[object ' + type + ']'\n  }\n\n  /**\n   * @param {*} o\n   * @returns {o is Function}\n   */\n  function isFunction(o) {\n    return typeof o === 'function'\n  }\n\n  /**\n   * @param {*} o\n   * @returns {o is Object}\n   */\n  function isRawObject(o) {\n    return isType(o, 'Object')\n  }\n\n  /**\n   * @typedef {Object} OnHandler\n   * @property {(keyof HTMLElementEventMap)|string} event\n   * @property {EventListener} listener\n   */\n\n  /**\n   * @typedef {Object} ListenerInfo\n   * @property {string} trigger\n   * @property {EventListener} listener\n   * @property {EventTarget} on\n   */\n\n  /**\n   * @typedef {Object} HtmxNodeInternalData\n   * Element data\n   * @property {number} [initHash]\n   * @property {boolean} [boosted]\n   * @property {OnHandler[]} [onHandlers]\n   * @property {number} [timeout]\n   * @property {ListenerInfo[]} [listenerInfos]\n   * @property {boolean} [cancelled]\n   * @property {boolean} [triggeredOnce]\n   * @property {number} [delayed]\n   * @property {number|null} [throttle]\n   * @property {WeakMap<HtmxTriggerSpecification,WeakMap<EventTarget,string>>} [lastValue]\n   * @property {boolean} [loaded]\n   * @property {string} [path]\n   * @property {string} [verb]\n   * @property {boolean} [polling]\n   * @property {HTMLButtonElement|HTMLInputElement|null} [lastButtonClicked]\n   * @property {number} [requestCount]\n   * @property {XMLHttpRequest} [xhr]\n   * @property {(() => void)[]} [queuedRequests]\n   * @property {boolean} [abortable]\n   *\n   * Event data\n   * @property {HtmxTriggerSpecification} [triggerSpec]\n   * @property {EventTarget[]} [handledFor]\n   */\n\n  /**\n   * getInternalData retrieves \"private\" data stored by htmx within an element\n   * @param {EventTarget|Event} elt\n   * @returns {HtmxNodeInternalData}\n   */\n  function getInternalData(elt) {\n    const dataProp = 'htmx-internal-data'\n    let data = elt[dataProp]\n    if (!data) {\n      data = elt[dataProp] = {}\n    }\n    return data\n  }\n\n  /**\n   * toArray converts an ArrayLike object into a real array.\n   * @template T\n   * @param {ArrayLike<T>} arr\n   * @returns {T[]}\n   */\n  function toArray(arr) {\n    const returnArr = []\n    if (arr) {\n      for (let i = 0; i < arr.length; i++) {\n        returnArr.push(arr[i])\n      }\n    }\n    return returnArr\n  }\n\n  /**\n   * @template T\n   * @param {T[]|NamedNodeMap|HTMLCollection|HTMLFormControlsCollection|ArrayLike<T>} arr\n   * @param {(T) => void} func\n   */\n  function forEach(arr, func) {\n    if (arr) {\n      for (let i = 0; i < arr.length; i++) {\n        func(arr[i])\n      }\n    }\n  }\n\n  /**\n   * @param {Element} el\n   * @returns {boolean}\n   */\n  function isScrolledIntoView(el) {\n    const rect = el.getBoundingClientRect()\n    const elemTop = rect.top\n    const elemBottom = rect.bottom\n    return elemTop < window.innerHeight && elemBottom >= 0\n  }\n\n  /**\n   * @param {Node} elt\n   * @returns {boolean}\n   */\n  function bodyContains(elt) {\n    // IE Fix\n    const rootNode = elt.getRootNode && elt.getRootNode()\n    if (rootNode && rootNode instanceof window.ShadowRoot) {\n      return getDocument().body.contains(rootNode.host)\n    } else {\n      return getDocument().body.contains(elt)\n    }\n  }\n\n  /**\n   * @param {string} trigger\n   * @returns {string[]}\n   */\n  function splitOnWhitespace(trigger) {\n    return trigger.trim().split(/\\s+/)\n  }\n\n  /**\n   * mergeObjects takes all the keys from\n   * obj2 and duplicates them into obj1\n   * @template T1\n   * @template T2\n   * @param {T1} obj1\n   * @param {T2} obj2\n   * @returns {T1 & T2}\n   */\n  function mergeObjects(obj1, obj2) {\n    for (const key in obj2) {\n      if (obj2.hasOwnProperty(key)) {\n        // @ts-ignore tsc doesn't seem to properly handle types merging\n        obj1[key] = obj2[key]\n      }\n    }\n    // @ts-ignore tsc doesn't seem to properly handle types merging\n    return obj1\n  }\n\n  /**\n   * @param {string} jString\n   * @returns {any|null}\n   */\n  function parseJSON(jString) {\n    try {\n      return JSON.parse(jString)\n    } catch (error) {\n      logError(error)\n      return null\n    }\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  function canAccessLocalStorage() {\n    const test = 'htmx:localStorageTest'\n    try {\n      localStorage.setItem(test, test)\n      localStorage.removeItem(test)\n      return true\n    } catch (e) {\n      return false\n    }\n  }\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  function normalizePath(path) {\n    try {\n      const url = new URL(path)\n      if (url) {\n        path = url.pathname + url.search\n      }\n      // remove trailing slash, unless index page\n      if (!(/^\\/$/.test(path))) {\n        path = path.replace(/\\/+$/, '')\n      }\n      return path\n    } catch (e) {\n      // be kind to IE11, which doesn't support URL()\n      return path\n    }\n  }\n\n  //= =========================================================================================\n  // public API\n  //= =========================================================================================\n\n  /**\n   * @param {string} str\n   * @returns {any}\n   */\n  function internalEval(str) {\n    return maybeEval(getDocument().body, function() {\n      return eval(str)\n    })\n  }\n\n  /**\n   * Adds a callback for the **htmx:load** event. This can be used to process new content, for example initializing the content with a javascript library\n   *\n   * @see https://htmx.org/api/#onLoad\n   *\n   * @param {(elt: Node) => void} callback the callback to call on newly loaded content\n   * @returns {EventListener}\n   */\n  function onLoadHelper(callback) {\n    const value = htmx.on('htmx:load', /** @param {CustomEvent} evt */ function(evt) {\n      callback(evt.detail.elt)\n    })\n    return value\n  }\n\n  /**\n   * Log all htmx events, useful for debugging.\n   *\n   * @see https://htmx.org/api/#logAll\n   */\n  function logAll() {\n    htmx.logger = function(elt, event, data) {\n      if (console) {\n        console.log(event, elt, data)\n      }\n    }\n  }\n\n  function logNone() {\n    htmx.logger = null\n  }\n\n  /**\n   * Finds an element matching the selector\n   *\n   * @see https://htmx.org/api/#find\n   *\n   * @param {ParentNode|string} eltOrSelector  the root element to find the matching element in, inclusive | the selector to match\n   * @param {string} [selector] the selector to match\n   * @returns {Element|null}\n   */\n  function find(eltOrSelector, selector) {\n    if (typeof eltOrSelector !== 'string') {\n      return eltOrSelector.querySelector(selector)\n    } else {\n      return find(getDocument(), eltOrSelector)\n    }\n  }\n\n  /**\n   * Finds all elements matching the selector\n   *\n   * @see https://htmx.org/api/#findAll\n   *\n   * @param {ParentNode|string} eltOrSelector the root element to find the matching elements in, inclusive | the selector to match\n   * @param {string} [selector] the selector to match\n   * @returns {NodeListOf<Element>}\n   */\n  function findAll(eltOrSelector, selector) {\n    if (typeof eltOrSelector !== 'string') {\n      return eltOrSelector.querySelectorAll(selector)\n    } else {\n      return findAll(getDocument(), eltOrSelector)\n    }\n  }\n\n  /**\n   * @returns Window\n   */\n  function getWindow() {\n    return window\n  }\n\n  /**\n   * Removes an element from the DOM\n   *\n   * @see https://htmx.org/api/#remove\n   *\n   * @param {Node} elt\n   * @param {number} [delay]\n   */\n  function removeElement(elt, delay) {\n    elt = resolveTarget(elt)\n    if (delay) {\n      getWindow().setTimeout(function() {\n        removeElement(elt)\n        elt = null\n      }, delay)\n    } else {\n      parentElt(elt).removeChild(elt)\n    }\n  }\n\n  /**\n   * @param {any} elt\n   * @return {Element|null}\n   */\n  function asElement(elt) {\n    return elt instanceof Element ? elt : null\n  }\n\n  /**\n   * @param {any} elt\n   * @return {HTMLElement|null}\n   */\n  function asHtmlElement(elt) {\n    return elt instanceof HTMLElement ? elt : null\n  }\n\n  /**\n   * @param {any} value\n   * @return {string|null}\n   */\n  function asString(value) {\n    return typeof value === 'string' ? value : null\n  }\n\n  /**\n   * @param {EventTarget} elt\n   * @return {ParentNode|null}\n   */\n  function asParentNode(elt) {\n    return elt instanceof Element || elt instanceof Document || elt instanceof DocumentFragment ? elt : null\n  }\n\n  /**\n   * This method adds a class to the given element.\n   *\n   * @see https://htmx.org/api/#addClass\n   *\n   * @param {Element|string} elt the element to add the class to\n   * @param {string} clazz the class to add\n   * @param {number} [delay] the delay (in milliseconds) before class is added\n   */\n  function addClassToElement(elt, clazz, delay) {\n    elt = asElement(resolveTarget(elt))\n    if (!elt) {\n      return\n    }\n    if (delay) {\n      getWindow().setTimeout(function() {\n        addClassToElement(elt, clazz)\n        elt = null\n      }, delay)\n    } else {\n      elt.classList && elt.classList.add(clazz)\n    }\n  }\n\n  /**\n   * Removes a class from the given element\n   *\n   * @see https://htmx.org/api/#removeClass\n   *\n   * @param {Node|string} node element to remove the class from\n   * @param {string} clazz the class to remove\n   * @param {number} [delay] the delay (in milliseconds before class is removed)\n   */\n  function removeClassFromElement(node, clazz, delay) {\n    let elt = asElement(resolveTarget(node))\n    if (!elt) {\n      return\n    }\n    if (delay) {\n      getWindow().setTimeout(function() {\n        removeClassFromElement(elt, clazz)\n        elt = null\n      }, delay)\n    } else {\n      if (elt.classList) {\n        elt.classList.remove(clazz)\n        // if there are no classes left, remove the class attribute\n        if (elt.classList.length === 0) {\n          elt.removeAttribute('class')\n        }\n      }\n    }\n  }\n\n  /**\n   * Toggles the given class on an element\n   *\n   * @see https://htmx.org/api/#toggleClass\n   *\n   * @param {Element|string} elt the element to toggle the class on\n   * @param {string} clazz the class to toggle\n   */\n  function toggleClassOnElement(elt, clazz) {\n    elt = resolveTarget(elt)\n    elt.classList.toggle(clazz)\n  }\n\n  /**\n   * Takes the given class from its siblings, so that among its siblings, only the given element will have the class.\n   *\n   * @see https://htmx.org/api/#takeClass\n   *\n   * @param {Node|string} elt the element that will take the class\n   * @param {string} clazz the class to take\n   */\n  function takeClassForElement(elt, clazz) {\n    elt = resolveTarget(elt)\n    forEach(elt.parentElement.children, function(child) {\n      removeClassFromElement(child, clazz)\n    })\n    addClassToElement(asElement(elt), clazz)\n  }\n\n  /**\n   * Finds the closest matching element in the given elements parentage, inclusive of the element\n   *\n   * @see https://htmx.org/api/#closest\n   *\n   * @param {Element|string} elt the element to find the selector from\n   * @param {string} selector the selector to find\n   * @returns {Element|null}\n   */\n  function closest(elt, selector) {\n    elt = asElement(resolveTarget(elt))\n    if (elt && elt.closest) {\n      return elt.closest(selector)\n    } else {\n      // TODO remove when IE goes away\n      do {\n        if (elt == null || matches(elt, selector)) {\n          return elt\n        }\n      }\n      while (elt = elt && asElement(parentElt(elt)))\n      return null\n    }\n  }\n\n  /**\n   * @param {string} str\n   * @param {string} prefix\n   * @returns {boolean}\n   */\n  function startsWith(str, prefix) {\n    return str.substring(0, prefix.length) === prefix\n  }\n\n  /**\n   * @param {string} str\n   * @param {string} suffix\n   * @returns {boolean}\n   */\n  function endsWith(str, suffix) {\n    return str.substring(str.length - suffix.length) === suffix\n  }\n\n  /**\n   * @param {string} selector\n   * @returns {string}\n   */\n  function normalizeSelector(selector) {\n    const trimmedSelector = selector.trim()\n    if (startsWith(trimmedSelector, '<') && endsWith(trimmedSelector, '/>')) {\n      return trimmedSelector.substring(1, trimmedSelector.length - 2)\n    } else {\n      return trimmedSelector\n    }\n  }\n\n  /**\n   * @param {Node|Element|Document|string} elt\n   * @param {string} selector\n   * @param {boolean=} global\n   * @returns {(Node|Window)[]}\n   */\n  function querySelectorAllExt(elt, selector, global) {\n    elt = resolveTarget(elt)\n    if (selector.indexOf('closest ') === 0) {\n      return [closest(asElement(elt), normalizeSelector(selector.substr(8)))]\n    } else if (selector.indexOf('find ') === 0) {\n      return [find(asParentNode(elt), normalizeSelector(selector.substr(5)))]\n    } else if (selector === 'next') {\n      return [asElement(elt).nextElementSibling]\n    } else if (selector.indexOf('next ') === 0) {\n      return [scanForwardQuery(elt, normalizeSelector(selector.substr(5)), !!global)]\n    } else if (selector === 'previous') {\n      return [asElement(elt).previousElementSibling]\n    } else if (selector.indexOf('previous ') === 0) {\n      return [scanBackwardsQuery(elt, normalizeSelector(selector.substr(9)), !!global)]\n    } else if (selector === 'document') {\n      return [document]\n    } else if (selector === 'window') {\n      return [window]\n    } else if (selector === 'body') {\n      return [document.body]\n    } else if (selector === 'root') {\n      return [getRootNode(elt, !!global)]\n    } else if (selector === 'host') {\n      return [(/** @type ShadowRoot */(elt.getRootNode())).host]\n    } else if (selector.indexOf('global ') === 0) {\n      return querySelectorAllExt(elt, selector.slice(7), true)\n    } else {\n      return toArray(asParentNode(getRootNode(elt, !!global)).querySelectorAll(normalizeSelector(selector)))\n    }\n  }\n\n  /**\n   * @param {Node} start\n   * @param {string} match\n   * @param {boolean} global\n   * @returns {Element}\n   */\n  var scanForwardQuery = function(start, match, global) {\n    const results = asParentNode(getRootNode(start, global)).querySelectorAll(match)\n    for (let i = 0; i < results.length; i++) {\n      const elt = results[i]\n      if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n        return elt\n      }\n    }\n  }\n\n  /**\n   * @param {Node} start\n   * @param {string} match\n   * @param {boolean} global\n   * @returns {Element}\n   */\n  var scanBackwardsQuery = function(start, match, global) {\n    const results = asParentNode(getRootNode(start, global)).querySelectorAll(match)\n    for (let i = results.length - 1; i >= 0; i--) {\n      const elt = results[i]\n      if (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n        return elt\n      }\n    }\n  }\n\n  /**\n   * @param {Node|string} eltOrSelector\n   * @param {string=} selector\n   * @returns {Node|Window}\n   */\n  function querySelectorExt(eltOrSelector, selector) {\n    if (typeof eltOrSelector !== 'string') {\n      return querySelectorAllExt(eltOrSelector, selector)[0]\n    } else {\n      return querySelectorAllExt(getDocument().body, eltOrSelector)[0]\n    }\n  }\n\n  /**\n   * @template {EventTarget} T\n   * @param {T|string} eltOrSelector\n   * @param {T} [context]\n   * @returns {Element|T|null}\n   */\n  function resolveTarget(eltOrSelector, context) {\n    if (typeof eltOrSelector === 'string') {\n      return find(asParentNode(context) || document, eltOrSelector)\n    } else {\n      return eltOrSelector\n    }\n  }\n\n  /**\n   * @typedef {keyof HTMLElementEventMap|string} AnyEventName\n   */\n\n  /**\n   * @typedef {Object} EventArgs\n   * @property {EventTarget} target\n   * @property {AnyEventName} event\n   * @property {EventListener} listener\n   * @property {Object|boolean} options\n   */\n\n  /**\n   * @param {EventTarget|AnyEventName} arg1\n   * @param {AnyEventName|EventListener} arg2\n   * @param {EventListener|Object|boolean} [arg3]\n   * @param {Object|boolean} [arg4]\n   * @returns {EventArgs}\n   */\n  function processEventArgs(arg1, arg2, arg3, arg4) {\n    if (isFunction(arg2)) {\n      return {\n        target: getDocument().body,\n        event: asString(arg1),\n        listener: arg2,\n        options: arg3\n      }\n    } else {\n      return {\n        target: resolveTarget(arg1),\n        event: asString(arg2),\n        listener: arg3,\n        options: arg4\n      }\n    }\n  }\n\n  /**\n   * Adds an event listener to an element\n   *\n   * @see https://htmx.org/api/#on\n   *\n   * @param {EventTarget|string} arg1 the element to add the listener to | the event name to add the listener for\n   * @param {string|EventListener} arg2 the event name to add the listener for | the listener to add\n   * @param {EventListener|Object|boolean} [arg3] the listener to add | options to add\n   * @param {Object|boolean} [arg4] options to add\n   * @returns {EventListener}\n   */\n  function addEventListenerImpl(arg1, arg2, arg3, arg4) {\n    ready(function() {\n      const eventArgs = processEventArgs(arg1, arg2, arg3, arg4)\n      eventArgs.target.addEventListener(eventArgs.event, eventArgs.listener, eventArgs.options)\n    })\n    const b = isFunction(arg2)\n    return b ? arg2 : arg3\n  }\n\n  /**\n   * Removes an event listener from an element\n   *\n   * @see https://htmx.org/api/#off\n   *\n   * @param {EventTarget|string} arg1 the element to remove the listener from | the event name to remove the listener from\n   * @param {string|EventListener} arg2 the event name to remove the listener from | the listener to remove\n   * @param {EventListener} [arg3] the listener to remove\n   * @returns {EventListener}\n   */\n  function removeEventListenerImpl(arg1, arg2, arg3) {\n    ready(function() {\n      const eventArgs = processEventArgs(arg1, arg2, arg3)\n      eventArgs.target.removeEventListener(eventArgs.event, eventArgs.listener)\n    })\n    return isFunction(arg2) ? arg2 : arg3\n  }\n\n  //= ===================================================================\n  // Node processing\n  //= ===================================================================\n\n  const DUMMY_ELT = getDocument().createElement('output') // dummy element for bad selectors\n  /**\n   * @param {Element} elt\n   * @param {string} attrName\n   * @returns {(Node|Window)[]}\n   */\n  function findAttributeTargets(elt, attrName) {\n    const attrTarget = getClosestAttributeValue(elt, attrName)\n    if (attrTarget) {\n      if (attrTarget === 'this') {\n        return [findThisElement(elt, attrName)]\n      } else {\n        const result = querySelectorAllExt(elt, attrTarget)\n        if (result.length === 0) {\n          logError('The selector \"' + attrTarget + '\" on ' + attrName + ' returned no matches!')\n          return [DUMMY_ELT]\n        } else {\n          return result\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {string} attribute\n   * @returns {Element|null}\n   */\n  function findThisElement(elt, attribute) {\n    return asElement(getClosestMatch(elt, function(elt) {\n      return getAttributeValue(asElement(elt), attribute) != null\n    }))\n  }\n\n  /**\n   * @param {Element} elt\n   * @returns {Node|Window|null}\n   */\n  function getTarget(elt) {\n    const targetStr = getClosestAttributeValue(elt, 'hx-target')\n    if (targetStr) {\n      if (targetStr === 'this') {\n        return findThisElement(elt, 'hx-target')\n      } else {\n        return querySelectorExt(elt, targetStr)\n      }\n    } else {\n      const data = getInternalData(elt)\n      if (data.boosted) {\n        return getDocument().body\n      } else {\n        return elt\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @returns {boolean}\n   */\n  function shouldSettleAttribute(name) {\n    const attributesToSettle = htmx.config.attributesToSettle\n    for (let i = 0; i < attributesToSettle.length; i++) {\n      if (name === attributesToSettle[i]) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {Element} mergeTo\n   * @param {Element} mergeFrom\n   */\n  function cloneAttributes(mergeTo, mergeFrom) {\n    forEach(mergeTo.attributes, function(attr) {\n      if (!mergeFrom.hasAttribute(attr.name) && shouldSettleAttribute(attr.name)) {\n        mergeTo.removeAttribute(attr.name)\n      }\n    })\n    forEach(mergeFrom.attributes, function(attr) {\n      if (shouldSettleAttribute(attr.name)) {\n        mergeTo.setAttribute(attr.name, attr.value)\n      }\n    })\n  }\n\n  /**\n   * @param {HtmxSwapStyle} swapStyle\n   * @param {Element} target\n   * @returns {boolean}\n   */\n  function isInlineSwap(swapStyle, target) {\n    const extensions = getExtensions(target)\n    for (let i = 0; i < extensions.length; i++) {\n      const extension = extensions[i]\n      try {\n        if (extension.isInlineSwap(swapStyle)) {\n          return true\n        }\n      } catch (e) {\n        logError(e)\n      }\n    }\n    return swapStyle === 'outerHTML'\n  }\n\n  /**\n   * @param {string} oobValue\n   * @param {Element} oobElement\n   * @param {HtmxSettleInfo} settleInfo\n   * @param {Node|Document} [rootNode]\n   * @returns\n   */\n  function oobSwap(oobValue, oobElement, settleInfo, rootNode) {\n    rootNode = rootNode || getDocument()\n    let selector = '#' + getRawAttribute(oobElement, 'id')\n    /** @type HtmxSwapStyle */\n    let swapStyle = 'outerHTML'\n    if (oobValue === 'true') {\n      // do nothing\n    } else if (oobValue.indexOf(':') > 0) {\n      swapStyle = oobValue.substr(0, oobValue.indexOf(':'))\n      selector = oobValue.substr(oobValue.indexOf(':') + 1, oobValue.length)\n    } else {\n      swapStyle = oobValue\n    }\n    oobElement.removeAttribute('hx-swap-oob')\n    oobElement.removeAttribute('data-hx-swap-oob')\n\n    const targets = querySelectorAllExt(rootNode, selector, false)\n    if (targets) {\n      forEach(\n        targets,\n        function(target) {\n          let fragment\n          const oobElementClone = oobElement.cloneNode(true)\n          fragment = getDocument().createDocumentFragment()\n          fragment.appendChild(oobElementClone)\n          if (!isInlineSwap(swapStyle, target)) {\n            fragment = asParentNode(oobElementClone) // if this is not an inline swap, we use the content of the node, not the node itself\n          }\n\n          const beforeSwapDetails = { shouldSwap: true, target, fragment }\n          if (!triggerEvent(target, 'htmx:oobBeforeSwap', beforeSwapDetails)) return\n\n          target = beforeSwapDetails.target // allow re-targeting\n          if (beforeSwapDetails.shouldSwap) {\n            handlePreservedElements(fragment)\n            swapWithStyle(swapStyle, target, target, fragment, settleInfo)\n            restorePreservedElements()\n          }\n          forEach(settleInfo.elts, function(elt) {\n            triggerEvent(elt, 'htmx:oobAfterSwap', beforeSwapDetails)\n          })\n        }\n      )\n      oobElement.parentNode.removeChild(oobElement)\n    } else {\n      oobElement.parentNode.removeChild(oobElement)\n      triggerErrorEvent(getDocument().body, 'htmx:oobErrorNoTarget', { content: oobElement })\n    }\n    return oobValue\n  }\n\n  function restorePreservedElements() {\n    const pantry = find('#--htmx-preserve-pantry--')\n    if (pantry) {\n      for (const preservedElt of [...pantry.children]) {\n        const existingElement = find('#' + preservedElt.id)\n        // @ts-ignore - use proposed moveBefore feature\n        existingElement.parentNode.moveBefore(preservedElt, existingElement)\n        existingElement.remove()\n      }\n      pantry.remove()\n    }\n  }\n\n  /**\n   * @param {DocumentFragment|ParentNode} fragment\n   */\n  function handlePreservedElements(fragment) {\n    forEach(findAll(fragment, '[hx-preserve], [data-hx-preserve]'), function(preservedElt) {\n      const id = getAttributeValue(preservedElt, 'id')\n      const existingElement = getDocument().getElementById(id)\n      if (existingElement != null) {\n        if (preservedElt.moveBefore) { // if the moveBefore API exists, use it\n          // get or create a storage spot for stuff\n          let pantry = find('#--htmx-preserve-pantry--')\n          if (pantry == null) {\n            getDocument().body.insertAdjacentHTML('afterend', \"<div id='--htmx-preserve-pantry--'></div>\")\n            pantry = find('#--htmx-preserve-pantry--')\n          }\n          // @ts-ignore - use proposed moveBefore feature\n          pantry.moveBefore(existingElement, null)\n        } else {\n          preservedElt.parentNode.replaceChild(existingElement, preservedElt)\n        }\n      }\n    })\n  }\n\n  /**\n   * @param {Node} parentNode\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function handleAttributes(parentNode, fragment, settleInfo) {\n    forEach(fragment.querySelectorAll('[id]'), function(newNode) {\n      const id = getRawAttribute(newNode, 'id')\n      if (id && id.length > 0) {\n        const normalizedId = id.replace(\"'\", \"\\\\'\")\n        const normalizedTag = newNode.tagName.replace(':', '\\\\:')\n        const parentElt = asParentNode(parentNode)\n        const oldNode = parentElt && parentElt.querySelector(normalizedTag + \"[id='\" + normalizedId + \"']\")\n        if (oldNode && oldNode !== parentElt) {\n          const newAttributes = newNode.cloneNode()\n          cloneAttributes(newNode, oldNode)\n          settleInfo.tasks.push(function() {\n            cloneAttributes(newNode, newAttributes)\n          })\n        }\n      }\n    })\n  }\n\n  /**\n   * @param {Node} child\n   * @returns {HtmxSettleTask}\n   */\n  function makeAjaxLoadTask(child) {\n    return function() {\n      removeClassFromElement(child, htmx.config.addedClass)\n      processNode(asElement(child))\n      processFocus(asParentNode(child))\n      triggerEvent(child, 'htmx:load')\n    }\n  }\n\n  /**\n   * @param {ParentNode} child\n   */\n  function processFocus(child) {\n    const autofocus = '[autofocus]'\n    const autoFocusedElt = asHtmlElement(matches(child, autofocus) ? child : child.querySelector(autofocus))\n    if (autoFocusedElt != null) {\n      autoFocusedElt.focus()\n    }\n  }\n\n  /**\n   * @param {Node} parentNode\n   * @param {Node} insertBefore\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function insertNodesBefore(parentNode, insertBefore, fragment, settleInfo) {\n    handleAttributes(parentNode, fragment, settleInfo)\n    while (fragment.childNodes.length > 0) {\n      const child = fragment.firstChild\n      addClassToElement(asElement(child), htmx.config.addedClass)\n      parentNode.insertBefore(child, insertBefore)\n      if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n        settleInfo.tasks.push(makeAjaxLoadTask(child))\n      }\n    }\n  }\n\n  /**\n   * based on https://gist.github.com/hyamamoto/fd435505d29ebfa3d9716fd2be8d42f0,\n   * derived from Java's string hashcode implementation\n   * @param {string} string\n   * @param {number} hash\n   * @returns {number}\n   */\n  function stringHash(string, hash) {\n    let char = 0\n    while (char < string.length) {\n      hash = (hash << 5) - hash + string.charCodeAt(char++) | 0 // bitwise or ensures we have a 32-bit int\n    }\n    return hash\n  }\n\n  /**\n   * @param {Element} elt\n   * @returns {number}\n   */\n  function attributeHash(elt) {\n    let hash = 0\n    // IE fix\n    if (elt.attributes) {\n      for (let i = 0; i < elt.attributes.length; i++) {\n        const attribute = elt.attributes[i]\n        if (attribute.value) { // only include attributes w/ actual values (empty is same as non-existent)\n          hash = stringHash(attribute.name, hash)\n          hash = stringHash(attribute.value, hash)\n        }\n      }\n    }\n    return hash\n  }\n\n  /**\n   * @param {EventTarget} elt\n   */\n  function deInitOnHandlers(elt) {\n    const internalData = getInternalData(elt)\n    if (internalData.onHandlers) {\n      for (let i = 0; i < internalData.onHandlers.length; i++) {\n        const handlerInfo = internalData.onHandlers[i]\n        removeEventListenerImpl(elt, handlerInfo.event, handlerInfo.listener)\n      }\n      delete internalData.onHandlers\n    }\n  }\n\n  /**\n   * @param {Node} element\n   */\n  function deInitNode(element) {\n    const internalData = getInternalData(element)\n    if (internalData.timeout) {\n      clearTimeout(internalData.timeout)\n    }\n    if (internalData.listenerInfos) {\n      forEach(internalData.listenerInfos, function(info) {\n        if (info.on) {\n          removeEventListenerImpl(info.on, info.trigger, info.listener)\n        }\n      })\n    }\n    deInitOnHandlers(element)\n    forEach(Object.keys(internalData), function(key) { delete internalData[key] })\n  }\n\n  /**\n   * @param {Node} element\n   */\n  function cleanUpElement(element) {\n    triggerEvent(element, 'htmx:beforeCleanupElement')\n    deInitNode(element)\n    // @ts-ignore IE11 code\n    // noinspection JSUnresolvedReference\n    if (element.children) { // IE\n      // @ts-ignore\n      forEach(element.children, function(child) { cleanUpElement(child) })\n    }\n  }\n\n  /**\n   * @param {Node} target\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function swapOuterHTML(target, fragment, settleInfo) {\n    if (target instanceof Element && target.tagName === 'BODY') { // special case the body to innerHTML because DocumentFragments can't contain a body elt unfortunately\n      return swapInnerHTML(target, fragment, settleInfo)\n    }\n    /** @type {Node} */\n    let newElt\n    const eltBeforeNewContent = target.previousSibling\n    const parentNode = parentElt(target)\n    if (!parentNode) { // when parent node disappears, we can't do anything\n      return\n    }\n    insertNodesBefore(parentNode, target, fragment, settleInfo)\n    if (eltBeforeNewContent == null) {\n      newElt = parentNode.firstChild\n    } else {\n      newElt = eltBeforeNewContent.nextSibling\n    }\n    settleInfo.elts = settleInfo.elts.filter(function(e) { return e !== target })\n    // scan through all newly added content and add all elements to the settle info so we trigger\n    // events properly on them\n    while (newElt && newElt !== target) {\n      if (newElt instanceof Element) {\n        settleInfo.elts.push(newElt)\n      }\n      newElt = newElt.nextSibling\n    }\n    cleanUpElement(target)\n    if (target instanceof Element) {\n      target.remove()\n    } else {\n      target.parentNode.removeChild(target)\n    }\n  }\n\n  /**\n   * @param {Node} target\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function swapAfterBegin(target, fragment, settleInfo) {\n    return insertNodesBefore(target, target.firstChild, fragment, settleInfo)\n  }\n\n  /**\n   * @param {Node} target\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function swapBeforeBegin(target, fragment, settleInfo) {\n    return insertNodesBefore(parentElt(target), target, fragment, settleInfo)\n  }\n\n  /**\n   * @param {Node} target\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function swapBeforeEnd(target, fragment, settleInfo) {\n    return insertNodesBefore(target, null, fragment, settleInfo)\n  }\n\n  /**\n   * @param {Node} target\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function swapAfterEnd(target, fragment, settleInfo) {\n    return insertNodesBefore(parentElt(target), target.nextSibling, fragment, settleInfo)\n  }\n\n  /**\n   * @param {Node} target\n   */\n  function swapDelete(target) {\n    cleanUpElement(target)\n    const parent = parentElt(target)\n    if (parent) {\n      return parent.removeChild(target)\n    }\n  }\n\n  /**\n   * @param {Node} target\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function swapInnerHTML(target, fragment, settleInfo) {\n    const firstChild = target.firstChild\n    insertNodesBefore(target, firstChild, fragment, settleInfo)\n    if (firstChild) {\n      while (firstChild.nextSibling) {\n        cleanUpElement(firstChild.nextSibling)\n        target.removeChild(firstChild.nextSibling)\n      }\n      cleanUpElement(firstChild)\n      target.removeChild(firstChild)\n    }\n  }\n\n  /**\n   * @param {HtmxSwapStyle} swapStyle\n   * @param {Element} elt\n   * @param {Node} target\n   * @param {ParentNode} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   */\n  function swapWithStyle(swapStyle, elt, target, fragment, settleInfo) {\n    switch (swapStyle) {\n      case 'none':\n        return\n      case 'outerHTML':\n        swapOuterHTML(target, fragment, settleInfo)\n        return\n      case 'afterbegin':\n        swapAfterBegin(target, fragment, settleInfo)\n        return\n      case 'beforebegin':\n        swapBeforeBegin(target, fragment, settleInfo)\n        return\n      case 'beforeend':\n        swapBeforeEnd(target, fragment, settleInfo)\n        return\n      case 'afterend':\n        swapAfterEnd(target, fragment, settleInfo)\n        return\n      case 'delete':\n        swapDelete(target)\n        return\n      default:\n        var extensions = getExtensions(elt)\n        for (let i = 0; i < extensions.length; i++) {\n          const ext = extensions[i]\n          try {\n            const newElements = ext.handleSwap(swapStyle, target, fragment, settleInfo)\n            if (newElements) {\n              if (Array.isArray(newElements)) {\n                // if handleSwap returns an array (like) of elements, we handle them\n                for (let j = 0; j < newElements.length; j++) {\n                  const child = newElements[j]\n                  if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {\n                    settleInfo.tasks.push(makeAjaxLoadTask(child))\n                  }\n                }\n              }\n              return\n            }\n          } catch (e) {\n            logError(e)\n          }\n        }\n        if (swapStyle === 'innerHTML') {\n          swapInnerHTML(target, fragment, settleInfo)\n        } else {\n          swapWithStyle(htmx.config.defaultSwapStyle, elt, target, fragment, settleInfo)\n        }\n    }\n  }\n\n  /**\n   * @param {DocumentFragment} fragment\n   * @param {HtmxSettleInfo} settleInfo\n   * @param {Node|Document} [rootNode]\n   */\n  function findAndSwapOobElements(fragment, settleInfo, rootNode) {\n    var oobElts = findAll(fragment, '[hx-swap-oob], [data-hx-swap-oob]')\n    forEach(oobElts, function(oobElement) {\n      if (htmx.config.allowNestedOobSwaps || oobElement.parentElement === null) {\n        const oobValue = getAttributeValue(oobElement, 'hx-swap-oob')\n        if (oobValue != null) {\n          oobSwap(oobValue, oobElement, settleInfo, rootNode)\n        }\n      } else {\n        oobElement.removeAttribute('hx-swap-oob')\n        oobElement.removeAttribute('data-hx-swap-oob')\n      }\n    })\n    return oobElts.length > 0\n  }\n\n  /**\n   * Implements complete swapping pipeline, including: focus and selection preservation,\n   * title updates, scroll, OOB swapping, normal swapping and settling\n   * @param {string|Element} target\n   * @param {string} content\n   * @param {HtmxSwapSpecification} swapSpec\n   * @param {SwapOptions} [swapOptions]\n   */\n  function swap(target, content, swapSpec, swapOptions) {\n    if (!swapOptions) {\n      swapOptions = {}\n    }\n\n    target = resolveTarget(target)\n    const rootNode = swapOptions.contextElement ? getRootNode(swapOptions.contextElement, false) : getDocument()\n\n    // preserve focus and selection\n    const activeElt = document.activeElement\n    let selectionInfo = {}\n    try {\n      selectionInfo = {\n        elt: activeElt,\n        // @ts-ignore\n        start: activeElt ? activeElt.selectionStart : null,\n        // @ts-ignore\n        end: activeElt ? activeElt.selectionEnd : null\n      }\n    } catch (e) {\n      // safari issue - see https://github.com/microsoft/playwright/issues/5894\n    }\n    const settleInfo = makeSettleInfo(target)\n\n    // For text content swaps, don't parse the response as HTML, just insert it\n    if (swapSpec.swapStyle === 'textContent') {\n      target.textContent = content\n    // Otherwise, make the fragment and process it\n    } else {\n      let fragment = makeFragment(content)\n\n      settleInfo.title = fragment.title\n\n      // select-oob swaps\n      if (swapOptions.selectOOB) {\n        const oobSelectValues = swapOptions.selectOOB.split(',')\n        for (let i = 0; i < oobSelectValues.length; i++) {\n          const oobSelectValue = oobSelectValues[i].split(':', 2)\n          let id = oobSelectValue[0].trim()\n          if (id.indexOf('#') === 0) {\n            id = id.substring(1)\n          }\n          const oobValue = oobSelectValue[1] || 'true'\n          const oobElement = fragment.querySelector('#' + id)\n          if (oobElement) {\n            oobSwap(oobValue, oobElement, settleInfo, rootNode)\n          }\n        }\n      }\n      // oob swaps\n      findAndSwapOobElements(fragment, settleInfo, rootNode)\n      forEach(findAll(fragment, 'template'), /** @param {HTMLTemplateElement} template */function(template) {\n        if (findAndSwapOobElements(template.content, settleInfo, rootNode)) {\n          // Avoid polluting the DOM with empty templates that were only used to encapsulate oob swap\n          template.remove()\n        }\n      })\n\n      // normal swap\n      if (swapOptions.select) {\n        const newFragment = getDocument().createDocumentFragment()\n        forEach(fragment.querySelectorAll(swapOptions.select), function(node) {\n          newFragment.appendChild(node)\n        })\n        fragment = newFragment\n      }\n      handlePreservedElements(fragment)\n      swapWithStyle(swapSpec.swapStyle, swapOptions.contextElement, target, fragment, settleInfo)\n      restorePreservedElements()\n    }\n\n    // apply saved focus and selection information to swapped content\n    if (selectionInfo.elt &&\n      !bodyContains(selectionInfo.elt) &&\n      getRawAttribute(selectionInfo.elt, 'id')) {\n      const newActiveElt = document.getElementById(getRawAttribute(selectionInfo.elt, 'id'))\n      const focusOptions = { preventScroll: swapSpec.focusScroll !== undefined ? !swapSpec.focusScroll : !htmx.config.defaultFocusScroll }\n      if (newActiveElt) {\n        // @ts-ignore\n        if (selectionInfo.start && newActiveElt.setSelectionRange) {\n          try {\n            // @ts-ignore\n            newActiveElt.setSelectionRange(selectionInfo.start, selectionInfo.end)\n          } catch (e) {\n            // the setSelectionRange method is present on fields that don't support it, so just let this fail\n          }\n        }\n        newActiveElt.focus(focusOptions)\n      }\n    }\n\n    target.classList.remove(htmx.config.swappingClass)\n    forEach(settleInfo.elts, function(elt) {\n      if (elt.classList) {\n        elt.classList.add(htmx.config.settlingClass)\n      }\n      triggerEvent(elt, 'htmx:afterSwap', swapOptions.eventInfo)\n    })\n    if (swapOptions.afterSwapCallback) {\n      swapOptions.afterSwapCallback()\n    }\n\n    // merge in new title after swap but before settle\n    if (!swapSpec.ignoreTitle) {\n      handleTitle(settleInfo.title)\n    }\n\n    // settle\n    const doSettle = function() {\n      forEach(settleInfo.tasks, function(task) {\n        task.call()\n      })\n      forEach(settleInfo.elts, function(elt) {\n        if (elt.classList) {\n          elt.classList.remove(htmx.config.settlingClass)\n        }\n        triggerEvent(elt, 'htmx:afterSettle', swapOptions.eventInfo)\n      })\n\n      if (swapOptions.anchor) {\n        const anchorTarget = asElement(resolveTarget('#' + swapOptions.anchor))\n        if (anchorTarget) {\n          anchorTarget.scrollIntoView({ block: 'start', behavior: 'auto' })\n        }\n      }\n\n      updateScrollState(settleInfo.elts, swapSpec)\n      if (swapOptions.afterSettleCallback) {\n        swapOptions.afterSettleCallback()\n      }\n    }\n\n    if (swapSpec.settleDelay > 0) {\n      getWindow().setTimeout(doSettle, swapSpec.settleDelay)\n    } else {\n      doSettle()\n    }\n  }\n\n  /**\n   * @param {XMLHttpRequest} xhr\n   * @param {string} header\n   * @param {EventTarget} elt\n   */\n  function handleTriggerHeader(xhr, header, elt) {\n    const triggerBody = xhr.getResponseHeader(header)\n    if (triggerBody.indexOf('{') === 0) {\n      const triggers = parseJSON(triggerBody)\n      for (const eventName in triggers) {\n        if (triggers.hasOwnProperty(eventName)) {\n          let detail = triggers[eventName]\n          if (isRawObject(detail)) {\n            // @ts-ignore\n            elt = detail.target !== undefined ? detail.target : elt\n          } else {\n            detail = { value: detail }\n          }\n          triggerEvent(elt, eventName, detail)\n        }\n      }\n    } else {\n      const eventNames = triggerBody.split(',')\n      for (let i = 0; i < eventNames.length; i++) {\n        triggerEvent(elt, eventNames[i].trim(), [])\n      }\n    }\n  }\n\n  const WHITESPACE = /\\s/\n  const WHITESPACE_OR_COMMA = /[\\s,]/\n  const SYMBOL_START = /[_$a-zA-Z]/\n  const SYMBOL_CONT = /[_$a-zA-Z0-9]/\n  const STRINGISH_START = ['\"', \"'\", '/']\n  const NOT_WHITESPACE = /[^\\s]/\n  const COMBINED_SELECTOR_START = /[{(]/\n  const COMBINED_SELECTOR_END = /[})]/\n\n  /**\n   * @param {string} str\n   * @returns {string[]}\n   */\n  function tokenizeString(str) {\n    /** @type string[] */\n    const tokens = []\n    let position = 0\n    while (position < str.length) {\n      if (SYMBOL_START.exec(str.charAt(position))) {\n        var startPosition = position\n        while (SYMBOL_CONT.exec(str.charAt(position + 1))) {\n          position++\n        }\n        tokens.push(str.substr(startPosition, position - startPosition + 1))\n      } else if (STRINGISH_START.indexOf(str.charAt(position)) !== -1) {\n        const startChar = str.charAt(position)\n        var startPosition = position\n        position++\n        while (position < str.length && str.charAt(position) !== startChar) {\n          if (str.charAt(position) === '\\\\') {\n            position++\n          }\n          position++\n        }\n        tokens.push(str.substr(startPosition, position - startPosition + 1))\n      } else {\n        const symbol = str.charAt(position)\n        tokens.push(symbol)\n      }\n      position++\n    }\n    return tokens\n  }\n\n  /**\n   * @param {string} token\n   * @param {string|null} last\n   * @param {string} paramName\n   * @returns {boolean}\n   */\n  function isPossibleRelativeReference(token, last, paramName) {\n    return SYMBOL_START.exec(token.charAt(0)) &&\n      token !== 'true' &&\n      token !== 'false' &&\n      token !== 'this' &&\n      token !== paramName &&\n      last !== '.'\n  }\n\n  /**\n   * @param {EventTarget|string} elt\n   * @param {string[]} tokens\n   * @param {string} paramName\n   * @returns {ConditionalFunction|null}\n   */\n  function maybeGenerateConditional(elt, tokens, paramName) {\n    if (tokens[0] === '[') {\n      tokens.shift()\n      let bracketCount = 1\n      let conditionalSource = ' return (function(' + paramName + '){ return ('\n      let last = null\n      while (tokens.length > 0) {\n        const token = tokens[0]\n        // @ts-ignore For some reason tsc doesn't understand the shift call, and thinks we're comparing the same value here, i.e. '[' vs ']'\n        if (token === ']') {\n          bracketCount--\n          if (bracketCount === 0) {\n            if (last === null) {\n              conditionalSource = conditionalSource + 'true'\n            }\n            tokens.shift()\n            conditionalSource += ')})'\n            try {\n              const conditionFunction = maybeEval(elt, function() {\n                return Function(conditionalSource)()\n              },\n              function() { return true })\n              conditionFunction.source = conditionalSource\n              return conditionFunction\n            } catch (e) {\n              triggerErrorEvent(getDocument().body, 'htmx:syntax:error', { error: e, source: conditionalSource })\n              return null\n            }\n          }\n        } else if (token === '[') {\n          bracketCount++\n        }\n        if (isPossibleRelativeReference(token, last, paramName)) {\n          conditionalSource += '((' + paramName + '.' + token + ') ? (' + paramName + '.' + token + ') : (window.' + token + '))'\n        } else {\n          conditionalSource = conditionalSource + token\n        }\n        last = tokens.shift()\n      }\n    }\n  }\n\n  /**\n   * @param {string[]} tokens\n   * @param {RegExp} match\n   * @returns {string}\n   */\n  function consumeUntil(tokens, match) {\n    let result = ''\n    while (tokens.length > 0 && !match.test(tokens[0])) {\n      result += tokens.shift()\n    }\n    return result\n  }\n\n  /**\n   * @param {string[]} tokens\n   * @returns {string}\n   */\n  function consumeCSSSelector(tokens) {\n    let result\n    if (tokens.length > 0 && COMBINED_SELECTOR_START.test(tokens[0])) {\n      tokens.shift()\n      result = consumeUntil(tokens, COMBINED_SELECTOR_END).trim()\n      tokens.shift()\n    } else {\n      result = consumeUntil(tokens, WHITESPACE_OR_COMMA)\n    }\n    return result\n  }\n\n  const INPUT_SELECTOR = 'input, textarea, select'\n\n  /**\n   * @param {Element} elt\n   * @param {string} explicitTrigger\n   * @param {Object} cache for trigger specs\n   * @returns {HtmxTriggerSpecification[]}\n   */\n  function parseAndCacheTrigger(elt, explicitTrigger, cache) {\n    /** @type HtmxTriggerSpecification[] */\n    const triggerSpecs = []\n    const tokens = tokenizeString(explicitTrigger)\n    do {\n      consumeUntil(tokens, NOT_WHITESPACE)\n      const initialLength = tokens.length\n      const trigger = consumeUntil(tokens, /[,\\[\\s]/)\n      if (trigger !== '') {\n        if (trigger === 'every') {\n          /** @type HtmxTriggerSpecification */\n          const every = { trigger: 'every' }\n          consumeUntil(tokens, NOT_WHITESPACE)\n          every.pollInterval = parseInterval(consumeUntil(tokens, /[,\\[\\s]/))\n          consumeUntil(tokens, NOT_WHITESPACE)\n          var eventFilter = maybeGenerateConditional(elt, tokens, 'event')\n          if (eventFilter) {\n            every.eventFilter = eventFilter\n          }\n          triggerSpecs.push(every)\n        } else {\n          /** @type HtmxTriggerSpecification */\n          const triggerSpec = { trigger }\n          var eventFilter = maybeGenerateConditional(elt, tokens, 'event')\n          if (eventFilter) {\n            triggerSpec.eventFilter = eventFilter\n          }\n          consumeUntil(tokens, NOT_WHITESPACE)\n          while (tokens.length > 0 && tokens[0] !== ',') {\n            const token = tokens.shift()\n            if (token === 'changed') {\n              triggerSpec.changed = true\n            } else if (token === 'once') {\n              triggerSpec.once = true\n            } else if (token === 'consume') {\n              triggerSpec.consume = true\n            } else if (token === 'delay' && tokens[0] === ':') {\n              tokens.shift()\n              triggerSpec.delay = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA))\n            } else if (token === 'from' && tokens[0] === ':') {\n              tokens.shift()\n              if (COMBINED_SELECTOR_START.test(tokens[0])) {\n                var from_arg = consumeCSSSelector(tokens)\n              } else {\n                var from_arg = consumeUntil(tokens, WHITESPACE_OR_COMMA)\n                if (from_arg === 'closest' || from_arg === 'find' || from_arg === 'next' || from_arg === 'previous') {\n                  tokens.shift()\n                  const selector = consumeCSSSelector(tokens)\n                  // `next` and `previous` allow a selector-less syntax\n                  if (selector.length > 0) {\n                    from_arg += ' ' + selector\n                  }\n                }\n              }\n              triggerSpec.from = from_arg\n            } else if (token === 'target' && tokens[0] === ':') {\n              tokens.shift()\n              triggerSpec.target = consumeCSSSelector(tokens)\n            } else if (token === 'throttle' && tokens[0] === ':') {\n              tokens.shift()\n              triggerSpec.throttle = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA))\n            } else if (token === 'queue' && tokens[0] === ':') {\n              tokens.shift()\n              triggerSpec.queue = consumeUntil(tokens, WHITESPACE_OR_COMMA)\n            } else if (token === 'root' && tokens[0] === ':') {\n              tokens.shift()\n              triggerSpec[token] = consumeCSSSelector(tokens)\n            } else if (token === 'threshold' && tokens[0] === ':') {\n              tokens.shift()\n              triggerSpec[token] = consumeUntil(tokens, WHITESPACE_OR_COMMA)\n            } else {\n              triggerErrorEvent(elt, 'htmx:syntax:error', { token: tokens.shift() })\n            }\n            consumeUntil(tokens, NOT_WHITESPACE)\n          }\n          triggerSpecs.push(triggerSpec)\n        }\n      }\n      if (tokens.length === initialLength) {\n        triggerErrorEvent(elt, 'htmx:syntax:error', { token: tokens.shift() })\n      }\n      consumeUntil(tokens, NOT_WHITESPACE)\n    } while (tokens[0] === ',' && tokens.shift())\n    if (cache) {\n      cache[explicitTrigger] = triggerSpecs\n    }\n    return triggerSpecs\n  }\n\n  /**\n   * @param {Element} elt\n   * @returns {HtmxTriggerSpecification[]}\n   */\n  function getTriggerSpecs(elt) {\n    const explicitTrigger = getAttributeValue(elt, 'hx-trigger')\n    let triggerSpecs = []\n    if (explicitTrigger) {\n      const cache = htmx.config.triggerSpecsCache\n      triggerSpecs = (cache && cache[explicitTrigger]) || parseAndCacheTrigger(elt, explicitTrigger, cache)\n    }\n\n    if (triggerSpecs.length > 0) {\n      return triggerSpecs\n    } else if (matches(elt, 'form')) {\n      return [{ trigger: 'submit' }]\n    } else if (matches(elt, 'input[type=\"button\"], input[type=\"submit\"]')) {\n      return [{ trigger: 'click' }]\n    } else if (matches(elt, INPUT_SELECTOR)) {\n      return [{ trigger: 'change' }]\n    } else {\n      return [{ trigger: 'click' }]\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   */\n  function cancelPolling(elt) {\n    getInternalData(elt).cancelled = true\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {TriggerHandler} handler\n   * @param {HtmxTriggerSpecification} spec\n   */\n  function processPolling(elt, handler, spec) {\n    const nodeData = getInternalData(elt)\n    nodeData.timeout = getWindow().setTimeout(function() {\n      if (bodyContains(elt) && nodeData.cancelled !== true) {\n        if (!maybeFilterEvent(spec, elt, makeEvent('hx:poll:trigger', {\n          triggerSpec: spec,\n          target: elt\n        }))) {\n          handler(elt)\n        }\n        processPolling(elt, handler, spec)\n      }\n    }, spec.pollInterval)\n  }\n\n  /**\n   * @param {HTMLAnchorElement} elt\n   * @returns {boolean}\n   */\n  function isLocalLink(elt) {\n    return location.hostname === elt.hostname &&\n      getRawAttribute(elt, 'href') &&\n      getRawAttribute(elt, 'href').indexOf('#') !== 0\n  }\n\n  /**\n   * @param {Element} elt\n   */\n  function eltIsDisabled(elt) {\n    return closest(elt, htmx.config.disableSelector)\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {HtmxNodeInternalData} nodeData\n   * @param {HtmxTriggerSpecification[]} triggerSpecs\n   */\n  function boostElement(elt, nodeData, triggerSpecs) {\n    if ((elt instanceof HTMLAnchorElement && isLocalLink(elt) && (elt.target === '' || elt.target === '_self')) || (elt.tagName === 'FORM' && String(getRawAttribute(elt, 'method')).toLowerCase() !== 'dialog')) {\n      nodeData.boosted = true\n      let verb, path\n      if (elt.tagName === 'A') {\n        verb = (/** @type HttpVerb */('get'))\n        path = getRawAttribute(elt, 'href')\n      } else {\n        const rawAttribute = getRawAttribute(elt, 'method')\n        verb = (/** @type HttpVerb */(rawAttribute ? rawAttribute.toLowerCase() : 'get'))\n        path = getRawAttribute(elt, 'action')\n        if (verb === 'get' && path.includes('?')) {\n          path = path.replace(/\\?[^#]+/, '')\n        }\n      }\n      triggerSpecs.forEach(function(triggerSpec) {\n        addEventListener(elt, function(node, evt) {\n          const elt = asElement(node)\n          if (eltIsDisabled(elt)) {\n            cleanUpElement(elt)\n            return\n          }\n          issueAjaxRequest(verb, path, elt, evt)\n        }, nodeData, triggerSpec, true)\n      })\n    }\n  }\n\n  /**\n   * @param {Event} evt\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function shouldCancel(evt, node) {\n    const elt = asElement(node)\n    if (!elt) {\n      return false\n    }\n    if (evt.type === 'submit' || evt.type === 'click') {\n      if (elt.tagName === 'FORM') {\n        return true\n      }\n      if (matches(elt, 'input[type=\"submit\"], button') && closest(elt, 'form') !== null) {\n        return true\n      }\n      if (elt instanceof HTMLAnchorElement && elt.href &&\n        (elt.getAttribute('href') === '#' || elt.getAttribute('href').indexOf('#') !== 0)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {Node} elt\n   * @param {Event|MouseEvent|KeyboardEvent|TouchEvent} evt\n   * @returns {boolean}\n   */\n  function ignoreBoostedAnchorCtrlClick(elt, evt) {\n    return getInternalData(elt).boosted && elt instanceof HTMLAnchorElement && evt.type === 'click' &&\n      // @ts-ignore this will resolve to undefined for events that don't define those properties, which is fine\n      (evt.ctrlKey || evt.metaKey)\n  }\n\n  /**\n   * @param {HtmxTriggerSpecification} triggerSpec\n   * @param {Node} elt\n   * @param {Event} evt\n   * @returns {boolean}\n   */\n  function maybeFilterEvent(triggerSpec, elt, evt) {\n    const eventFilter = triggerSpec.eventFilter\n    if (eventFilter) {\n      try {\n        return eventFilter.call(elt, evt) !== true\n      } catch (e) {\n        const source = eventFilter.source\n        triggerErrorEvent(getDocument().body, 'htmx:eventFilter:error', { error: e, source })\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {Node} elt\n   * @param {TriggerHandler} handler\n   * @param {HtmxNodeInternalData} nodeData\n   * @param {HtmxTriggerSpecification} triggerSpec\n   * @param {boolean} [explicitCancel]\n   */\n  function addEventListener(elt, handler, nodeData, triggerSpec, explicitCancel) {\n    const elementData = getInternalData(elt)\n    /** @type {(Node|Window)[]} */\n    let eltsToListenOn\n    if (triggerSpec.from) {\n      eltsToListenOn = querySelectorAllExt(elt, triggerSpec.from)\n    } else {\n      eltsToListenOn = [elt]\n    }\n    // store the initial values of the elements, so we can tell if they change\n    if (triggerSpec.changed) {\n      if (!('lastValue' in elementData)) {\n        elementData.lastValue = new WeakMap()\n      }\n      eltsToListenOn.forEach(function(eltToListenOn) {\n        if (!elementData.lastValue.has(triggerSpec)) {\n          elementData.lastValue.set(triggerSpec, new WeakMap())\n        }\n        // @ts-ignore value will be undefined for non-input elements, which is fine\n        elementData.lastValue.get(triggerSpec).set(eltToListenOn, eltToListenOn.value)\n      })\n    }\n    forEach(eltsToListenOn, function(eltToListenOn) {\n      /** @type EventListener */\n      const eventListener = function(evt) {\n        if (!bodyContains(elt)) {\n          eltToListenOn.removeEventListener(triggerSpec.trigger, eventListener)\n          return\n        }\n        if (ignoreBoostedAnchorCtrlClick(elt, evt)) {\n          return\n        }\n        if (explicitCancel || shouldCancel(evt, elt)) {\n          evt.preventDefault()\n        }\n        if (maybeFilterEvent(triggerSpec, elt, evt)) {\n          return\n        }\n        const eventData = getInternalData(evt)\n        eventData.triggerSpec = triggerSpec\n        if (eventData.handledFor == null) {\n          eventData.handledFor = []\n        }\n        if (eventData.handledFor.indexOf(elt) < 0) {\n          eventData.handledFor.push(elt)\n          if (triggerSpec.consume) {\n            evt.stopPropagation()\n          }\n          if (triggerSpec.target && evt.target) {\n            if (!matches(asElement(evt.target), triggerSpec.target)) {\n              return\n            }\n          }\n          if (triggerSpec.once) {\n            if (elementData.triggeredOnce) {\n              return\n            } else {\n              elementData.triggeredOnce = true\n            }\n          }\n          if (triggerSpec.changed) {\n            const node = event.target\n            // @ts-ignore value will be undefined for non-input elements, which is fine\n            const value = node.value\n            const lastValue = elementData.lastValue.get(triggerSpec)\n            if (lastValue.has(node) && lastValue.get(node) === value) {\n              return\n            }\n            lastValue.set(node, value)\n          }\n          if (elementData.delayed) {\n            clearTimeout(elementData.delayed)\n          }\n          if (elementData.throttle) {\n            return\n          }\n\n          if (triggerSpec.throttle > 0) {\n            if (!elementData.throttle) {\n              triggerEvent(elt, 'htmx:trigger')\n              handler(elt, evt)\n              elementData.throttle = getWindow().setTimeout(function() {\n                elementData.throttle = null\n              }, triggerSpec.throttle)\n            }\n          } else if (triggerSpec.delay > 0) {\n            elementData.delayed = getWindow().setTimeout(function() {\n              triggerEvent(elt, 'htmx:trigger')\n              handler(elt, evt)\n            }, triggerSpec.delay)\n          } else {\n            triggerEvent(elt, 'htmx:trigger')\n            handler(elt, evt)\n          }\n        }\n      }\n      if (nodeData.listenerInfos == null) {\n        nodeData.listenerInfos = []\n      }\n      nodeData.listenerInfos.push({\n        trigger: triggerSpec.trigger,\n        listener: eventListener,\n        on: eltToListenOn\n      })\n      eltToListenOn.addEventListener(triggerSpec.trigger, eventListener)\n    })\n  }\n\n  let windowIsScrolling = false // used by initScrollHandler\n  let scrollHandler = null\n  function initScrollHandler() {\n    if (!scrollHandler) {\n      scrollHandler = function() {\n        windowIsScrolling = true\n      }\n      window.addEventListener('scroll', scrollHandler)\n      window.addEventListener('resize', scrollHandler)\n      setInterval(function() {\n        if (windowIsScrolling) {\n          windowIsScrolling = false\n          forEach(getDocument().querySelectorAll(\"[hx-trigger*='revealed'],[data-hx-trigger*='revealed']\"), function(elt) {\n            maybeReveal(elt)\n          })\n        }\n      }, 200)\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   */\n  function maybeReveal(elt) {\n    if (!hasAttribute(elt, 'data-hx-revealed') && isScrolledIntoView(elt)) {\n      elt.setAttribute('data-hx-revealed', 'true')\n      const nodeData = getInternalData(elt)\n      if (nodeData.initHash) {\n        triggerEvent(elt, 'revealed')\n      } else {\n        // if the node isn't initialized, wait for it before triggering the request\n        elt.addEventListener('htmx:afterProcessNode', function() { triggerEvent(elt, 'revealed') }, { once: true })\n      }\n    }\n  }\n\n  //= ===================================================================\n\n  /**\n   * @param {Element} elt\n   * @param {TriggerHandler} handler\n   * @param {HtmxNodeInternalData} nodeData\n   * @param {number} delay\n   */\n  function loadImmediately(elt, handler, nodeData, delay) {\n    const load = function() {\n      if (!nodeData.loaded) {\n        nodeData.loaded = true\n        handler(elt)\n      }\n    }\n    if (delay > 0) {\n      getWindow().setTimeout(load, delay)\n    } else {\n      load()\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {HtmxNodeInternalData} nodeData\n   * @param {HtmxTriggerSpecification[]} triggerSpecs\n   * @returns {boolean}\n   */\n  function processVerbs(elt, nodeData, triggerSpecs) {\n    let explicitAction = false\n    forEach(VERBS, function(verb) {\n      if (hasAttribute(elt, 'hx-' + verb)) {\n        const path = getAttributeValue(elt, 'hx-' + verb)\n        explicitAction = true\n        nodeData.path = path\n        nodeData.verb = verb\n        triggerSpecs.forEach(function(triggerSpec) {\n          addTriggerHandler(elt, triggerSpec, nodeData, function(node, evt) {\n            const elt = asElement(node)\n            if (closest(elt, htmx.config.disableSelector)) {\n              cleanUpElement(elt)\n              return\n            }\n            issueAjaxRequest(verb, path, elt, evt)\n          })\n        })\n      }\n    })\n    return explicitAction\n  }\n\n  /**\n   * @callback TriggerHandler\n   * @param {Node} elt\n   * @param {Event} [evt]\n   */\n\n  /**\n   * @param {Node} elt\n   * @param {HtmxTriggerSpecification} triggerSpec\n   * @param {HtmxNodeInternalData} nodeData\n   * @param {TriggerHandler} handler\n   */\n  function addTriggerHandler(elt, triggerSpec, nodeData, handler) {\n    if (triggerSpec.trigger === 'revealed') {\n      initScrollHandler()\n      addEventListener(elt, handler, nodeData, triggerSpec)\n      maybeReveal(asElement(elt))\n    } else if (triggerSpec.trigger === 'intersect') {\n      const observerOptions = {}\n      if (triggerSpec.root) {\n        observerOptions.root = querySelectorExt(elt, triggerSpec.root)\n      }\n      if (triggerSpec.threshold) {\n        observerOptions.threshold = parseFloat(triggerSpec.threshold)\n      }\n      const observer = new IntersectionObserver(function(entries) {\n        for (let i = 0; i < entries.length; i++) {\n          const entry = entries[i]\n          if (entry.isIntersecting) {\n            triggerEvent(elt, 'intersect')\n            break\n          }\n        }\n      }, observerOptions)\n      observer.observe(asElement(elt))\n      addEventListener(asElement(elt), handler, nodeData, triggerSpec)\n    } else if (triggerSpec.trigger === 'load') {\n      if (!maybeFilterEvent(triggerSpec, elt, makeEvent('load', { elt }))) {\n        loadImmediately(asElement(elt), handler, nodeData, triggerSpec.delay)\n      }\n    } else if (triggerSpec.pollInterval > 0) {\n      nodeData.polling = true\n      processPolling(asElement(elt), handler, triggerSpec)\n    } else {\n      addEventListener(elt, handler, nodeData, triggerSpec)\n    }\n  }\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function shouldProcessHxOn(node) {\n    const elt = asElement(node)\n    if (!elt) {\n      return false\n    }\n    const attributes = elt.attributes\n    for (let j = 0; j < attributes.length; j++) {\n      const attrName = attributes[j].name\n      if (startsWith(attrName, 'hx-on:') || startsWith(attrName, 'data-hx-on:') ||\n        startsWith(attrName, 'hx-on-') || startsWith(attrName, 'data-hx-on-')) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {Node} elt\n   * @returns {Element[]}\n   */\n  const HX_ON_QUERY = new XPathEvaluator()\n    .createExpression('.//*[@*[ starts-with(name(), \"hx-on:\") or starts-with(name(), \"data-hx-on:\") or' +\n      ' starts-with(name(), \"hx-on-\") or starts-with(name(), \"data-hx-on-\") ]]')\n\n  function processHXOnRoot(elt, elements) {\n    if (shouldProcessHxOn(elt)) {\n      elements.push(asElement(elt))\n    }\n    const iter = HX_ON_QUERY.evaluate(elt)\n    let node = null\n    while (node = iter.iterateNext()) elements.push(asElement(node))\n  }\n\n  function findHxOnWildcardElements(elt) {\n    /** @type {Element[]} */\n    const elements = []\n    if (elt instanceof DocumentFragment) {\n      for (const child of elt.childNodes) {\n        processHXOnRoot(child, elements)\n      }\n    } else {\n      processHXOnRoot(elt, elements)\n    }\n    return elements\n  }\n\n  /**\n   * @param {Element} elt\n   * @returns {NodeListOf<Element>|[]}\n   */\n  function findElementsToProcess(elt) {\n    if (elt.querySelectorAll) {\n      const boostedSelector = ', [hx-boost] a, [data-hx-boost] a, a[hx-boost], a[data-hx-boost]'\n\n      const extensionSelectors = []\n      for (const e in extensions) {\n        const extension = extensions[e]\n        if (extension.getSelectors) {\n          var selectors = extension.getSelectors()\n          if (selectors) {\n            extensionSelectors.push(selectors)\n          }\n        }\n      }\n\n      const results = elt.querySelectorAll(VERB_SELECTOR + boostedSelector + \", form, [type='submit'],\" +\n        ' [hx-ext], [data-hx-ext], [hx-trigger], [data-hx-trigger]' + extensionSelectors.flat().map(s => ', ' + s).join(''))\n\n      return results\n    } else {\n      return []\n    }\n  }\n\n  /**\n   * Handle submit buttons/inputs that have the form attribute set\n   * see https://developer.mozilla.org/docs/Web/HTML/Element/button\n   * @param {Event} evt\n   */\n  function maybeSetLastButtonClicked(evt) {\n    const elt = /** @type {HTMLButtonElement|HTMLInputElement} */ (closest(asElement(evt.target), \"button, input[type='submit']\"))\n    const internalData = getRelatedFormData(evt)\n    if (internalData) {\n      internalData.lastButtonClicked = elt\n    }\n  }\n\n  /**\n   * @param {Event} evt\n   */\n  function maybeUnsetLastButtonClicked(evt) {\n    const internalData = getRelatedFormData(evt)\n    if (internalData) {\n      internalData.lastButtonClicked = null\n    }\n  }\n\n  /**\n   * @param {Event} evt\n   * @returns {HtmxNodeInternalData|undefined}\n   */\n  function getRelatedFormData(evt) {\n    const elt = closest(asElement(evt.target), \"button, input[type='submit']\")\n    if (!elt) {\n      return\n    }\n    const form = resolveTarget('#' + getRawAttribute(elt, 'form'), elt.getRootNode()) || closest(elt, 'form')\n    if (!form) {\n      return\n    }\n    return getInternalData(form)\n  }\n\n  /**\n   * @param {EventTarget} elt\n   */\n  function initButtonTracking(elt) {\n    // need to handle both click and focus in:\n    //   focusin - in case someone tabs in to a button and hits the space bar\n    //   click - on OSX buttons do not focus on click see https://bugs.webkit.org/show_bug.cgi?id=13724\n    elt.addEventListener('click', maybeSetLastButtonClicked)\n    elt.addEventListener('focusin', maybeSetLastButtonClicked)\n    elt.addEventListener('focusout', maybeUnsetLastButtonClicked)\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {string} eventName\n   * @param {string} code\n   */\n  function addHxOnEventHandler(elt, eventName, code) {\n    const nodeData = getInternalData(elt)\n    if (!Array.isArray(nodeData.onHandlers)) {\n      nodeData.onHandlers = []\n    }\n    let func\n    /** @type EventListener */\n    const listener = function(e) {\n      maybeEval(elt, function() {\n        if (eltIsDisabled(elt)) {\n          return\n        }\n        if (!func) {\n          func = new Function('event', code)\n        }\n        func.call(elt, e)\n      })\n    }\n    elt.addEventListener(eventName, listener)\n    nodeData.onHandlers.push({ event: eventName, listener })\n  }\n\n  /**\n   * @param {Element} elt\n   */\n  function processHxOnWildcard(elt) {\n    // wipe any previous on handlers so that this function takes precedence\n    deInitOnHandlers(elt)\n\n    for (let i = 0; i < elt.attributes.length; i++) {\n      const name = elt.attributes[i].name\n      const value = elt.attributes[i].value\n      if (startsWith(name, 'hx-on') || startsWith(name, 'data-hx-on')) {\n        const afterOnPosition = name.indexOf('-on') + 3\n        const nextChar = name.slice(afterOnPosition, afterOnPosition + 1)\n        if (nextChar === '-' || nextChar === ':') {\n          let eventName = name.slice(afterOnPosition + 1)\n          // if the eventName starts with a colon or dash, prepend \"htmx\" for shorthand support\n          if (startsWith(eventName, ':')) {\n            eventName = 'htmx' + eventName\n          } else if (startsWith(eventName, '-')) {\n            eventName = 'htmx:' + eventName.slice(1)\n          } else if (startsWith(eventName, 'htmx-')) {\n            eventName = 'htmx:' + eventName.slice(5)\n          }\n\n          addHxOnEventHandler(elt, eventName, value)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Element|HTMLInputElement} elt\n   */\n  function initNode(elt) {\n    if (closest(elt, htmx.config.disableSelector)) {\n      cleanUpElement(elt)\n      return\n    }\n    const nodeData = getInternalData(elt)\n    if (nodeData.initHash !== attributeHash(elt)) {\n      // clean up any previously processed info\n      deInitNode(elt)\n\n      nodeData.initHash = attributeHash(elt)\n\n      triggerEvent(elt, 'htmx:beforeProcessNode')\n\n      const triggerSpecs = getTriggerSpecs(elt)\n      const hasExplicitHttpAction = processVerbs(elt, nodeData, triggerSpecs)\n\n      if (!hasExplicitHttpAction) {\n        if (getClosestAttributeValue(elt, 'hx-boost') === 'true') {\n          boostElement(elt, nodeData, triggerSpecs)\n        } else if (hasAttribute(elt, 'hx-trigger')) {\n          triggerSpecs.forEach(function(triggerSpec) {\n            // For \"naked\" triggers, don't do anything at all\n            addTriggerHandler(elt, triggerSpec, nodeData, function() {\n            })\n          })\n        }\n      }\n\n      // Handle submit buttons/inputs that have the form attribute set\n      // see https://developer.mozilla.org/docs/Web/HTML/Element/button\n      if (elt.tagName === 'FORM' || (getRawAttribute(elt, 'type') === 'submit' && hasAttribute(elt, 'form'))) {\n        initButtonTracking(elt)\n      }\n\n      triggerEvent(elt, 'htmx:afterProcessNode')\n    }\n  }\n\n  /**\n   * Processes new content, enabling htmx behavior. This can be useful if you have content that is added to the DOM outside of the normal htmx request cycle but still want htmx attributes to work.\n   *\n   * @see https://htmx.org/api/#process\n   *\n   * @param {Element|string} elt element to process\n   */\n  function processNode(elt) {\n    elt = resolveTarget(elt)\n    if (closest(elt, htmx.config.disableSelector)) {\n      cleanUpElement(elt)\n      return\n    }\n    initNode(elt)\n    forEach(findElementsToProcess(elt), function(child) { initNode(child) })\n    forEach(findHxOnWildcardElements(elt), processHxOnWildcard)\n  }\n\n  //= ===================================================================\n  // Event/Log Support\n  //= ===================================================================\n\n  /**\n   * @param {string} str\n   * @returns {string}\n   */\n  function kebabEventName(str) {\n    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {any} detail\n   * @returns {CustomEvent}\n   */\n  function makeEvent(eventName, detail) {\n    let evt\n    if (window.CustomEvent && typeof window.CustomEvent === 'function') {\n      // TODO: `composed: true` here is a hack to make global event handlers work with events in shadow DOM\n      // This breaks expected encapsulation but needs to be here until decided otherwise by core devs\n      evt = new CustomEvent(eventName, { bubbles: true, cancelable: true, composed: true, detail })\n    } else {\n      evt = getDocument().createEvent('CustomEvent')\n      evt.initCustomEvent(eventName, true, true, detail)\n    }\n    return evt\n  }\n\n  /**\n   * @param {EventTarget|string} elt\n   * @param {string} eventName\n   * @param {any=} detail\n   */\n  function triggerErrorEvent(elt, eventName, detail) {\n    triggerEvent(elt, eventName, mergeObjects({ error: eventName }, detail))\n  }\n\n  /**\n   * @param {string} eventName\n   * @returns {boolean}\n   */\n  function ignoreEventForLogging(eventName) {\n    return eventName === 'htmx:afterProcessNode'\n  }\n\n  /**\n   * `withExtensions` locates all active extensions for a provided element, then\n   * executes the provided function using each of the active extensions.  It should\n   * be called internally at every extendable execution point in htmx.\n   *\n   * @param {Element} elt\n   * @param {(extension:HtmxExtension) => void} toDo\n   * @returns void\n   */\n  function withExtensions(elt, toDo) {\n    forEach(getExtensions(elt), function(extension) {\n      try {\n        toDo(extension)\n      } catch (e) {\n        logError(e)\n      }\n    })\n  }\n\n  function logError(msg) {\n    if (console.error) {\n      console.error(msg)\n    } else if (console.log) {\n      console.log('ERROR: ', msg)\n    }\n  }\n\n  /**\n   * Triggers a given event on an element\n   *\n   * @see https://htmx.org/api/#trigger\n   *\n   * @param {EventTarget|string} elt the element to trigger the event on\n   * @param {string} eventName the name of the event to trigger\n   * @param {any=} detail details for the event\n   * @returns {boolean}\n   */\n  function triggerEvent(elt, eventName, detail) {\n    elt = resolveTarget(elt)\n    if (detail == null) {\n      detail = {}\n    }\n    detail.elt = elt\n    const event = makeEvent(eventName, detail)\n    if (htmx.logger && !ignoreEventForLogging(eventName)) {\n      htmx.logger(elt, eventName, detail)\n    }\n    if (detail.error) {\n      logError(detail.error)\n      triggerEvent(elt, 'htmx:error', { errorInfo: detail })\n    }\n    let eventResult = elt.dispatchEvent(event)\n    const kebabName = kebabEventName(eventName)\n    if (eventResult && kebabName !== eventName) {\n      const kebabedEvent = makeEvent(kebabName, event.detail)\n      eventResult = eventResult && elt.dispatchEvent(kebabedEvent)\n    }\n    withExtensions(asElement(elt), function(extension) {\n      eventResult = eventResult && (extension.onEvent(eventName, event) !== false && !event.defaultPrevented)\n    })\n    return eventResult\n  }\n\n  //= ===================================================================\n  // History Support\n  //= ===================================================================\n  let currentPathForHistory = location.pathname + location.search\n\n  /**\n   * @returns {Element}\n   */\n  function getHistoryElement() {\n    const historyElt = getDocument().querySelector('[hx-history-elt],[data-hx-history-elt]')\n    return historyElt || getDocument().body\n  }\n\n  /**\n   * @param {string} url\n   * @param {Element} rootElt\n   */\n  function saveToHistoryCache(url, rootElt) {\n    if (!canAccessLocalStorage()) {\n      return\n    }\n\n    // get state to save\n    const innerHTML = cleanInnerHtmlForHistory(rootElt)\n    const title = getDocument().title\n    const scroll = window.scrollY\n\n    if (htmx.config.historyCacheSize <= 0) {\n      // make sure that an eventually already existing cache is purged\n      localStorage.removeItem('htmx-history-cache')\n      return\n    }\n\n    url = normalizePath(url)\n\n    const historyCache = parseJSON(localStorage.getItem('htmx-history-cache')) || []\n    for (let i = 0; i < historyCache.length; i++) {\n      if (historyCache[i].url === url) {\n        historyCache.splice(i, 1)\n        break\n      }\n    }\n\n    /** @type HtmxHistoryItem */\n    const newHistoryItem = { url, content: innerHTML, title, scroll }\n\n    triggerEvent(getDocument().body, 'htmx:historyItemCreated', { item: newHistoryItem, cache: historyCache })\n\n    historyCache.push(newHistoryItem)\n    while (historyCache.length > htmx.config.historyCacheSize) {\n      historyCache.shift()\n    }\n\n    // keep trying to save the cache until it succeeds or is empty\n    while (historyCache.length > 0) {\n      try {\n        localStorage.setItem('htmx-history-cache', JSON.stringify(historyCache))\n        break\n      } catch (e) {\n        triggerErrorEvent(getDocument().body, 'htmx:historyCacheError', { cause: e, cache: historyCache })\n        historyCache.shift() // shrink the cache and retry\n      }\n    }\n  }\n\n  /**\n   * @typedef {Object} HtmxHistoryItem\n   * @property {string} url\n   * @property {string} content\n   * @property {string} title\n   * @property {number} scroll\n   */\n\n  /**\n   * @param {string} url\n   * @returns {HtmxHistoryItem|null}\n   */\n  function getCachedHistory(url) {\n    if (!canAccessLocalStorage()) {\n      return null\n    }\n\n    url = normalizePath(url)\n\n    const historyCache = parseJSON(localStorage.getItem('htmx-history-cache')) || []\n    for (let i = 0; i < historyCache.length; i++) {\n      if (historyCache[i].url === url) {\n        return historyCache[i]\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Element} elt\n   * @returns {string}\n   */\n  function cleanInnerHtmlForHistory(elt) {\n    const className = htmx.config.requestClass\n    const clone = /** @type Element */ (elt.cloneNode(true))\n    forEach(findAll(clone, '.' + className), function(child) {\n      removeClassFromElement(child, className)\n    })\n    // remove the disabled attribute for any element disabled due to an htmx request\n    forEach(findAll(clone, '[data-disabled-by-htmx]'), function(child) {\n      child.removeAttribute('disabled')\n    })\n    return clone.innerHTML\n  }\n\n  function saveCurrentPageToHistory() {\n    const elt = getHistoryElement()\n    const path = currentPathForHistory || location.pathname + location.search\n\n    // Allow history snapshot feature to be disabled where hx-history=\"false\"\n    // is present *anywhere* in the current document we're about to save,\n    // so we can prevent privileged data entering the cache.\n    // The page will still be reachable as a history entry, but htmx will fetch it\n    // live from the server onpopstate rather than look in the localStorage cache\n    let disableHistoryCache\n    try {\n      disableHistoryCache = getDocument().querySelector('[hx-history=\"false\" i],[data-hx-history=\"false\" i]')\n    } catch (e) {\n    // IE11: insensitive modifier not supported so fallback to case sensitive selector\n      disableHistoryCache = getDocument().querySelector('[hx-history=\"false\"],[data-hx-history=\"false\"]')\n    }\n    if (!disableHistoryCache) {\n      triggerEvent(getDocument().body, 'htmx:beforeHistorySave', { path, historyElt: elt })\n      saveToHistoryCache(path, elt)\n    }\n\n    if (htmx.config.historyEnabled) history.replaceState({ htmx: true }, getDocument().title, window.location.href)\n  }\n\n  /**\n   * @param {string} path\n   */\n  function pushUrlIntoHistory(path) {\n  // remove the cache buster parameter, if any\n    if (htmx.config.getCacheBusterParam) {\n      path = path.replace(/org\\.htmx\\.cache-buster=[^&]*&?/, '')\n      if (endsWith(path, '&') || endsWith(path, '?')) {\n        path = path.slice(0, -1)\n      }\n    }\n    if (htmx.config.historyEnabled) {\n      history.pushState({ htmx: true }, '', path)\n    }\n    currentPathForHistory = path\n  }\n\n  /**\n   * @param {string} path\n   */\n  function replaceUrlInHistory(path) {\n    if (htmx.config.historyEnabled) history.replaceState({ htmx: true }, '', path)\n    currentPathForHistory = path\n  }\n\n  /**\n   * @param {HtmxSettleTask[]} tasks\n   */\n  function settleImmediately(tasks) {\n    forEach(tasks, function(task) {\n      task.call(undefined)\n    })\n  }\n\n  /**\n   * @param {string} path\n   */\n  function loadHistoryFromServer(path) {\n    const request = new XMLHttpRequest()\n    const details = { path, xhr: request }\n    triggerEvent(getDocument().body, 'htmx:historyCacheMiss', details)\n    request.open('GET', path, true)\n    request.setRequestHeader('HX-Request', 'true')\n    request.setRequestHeader('HX-History-Restore-Request', 'true')\n    request.setRequestHeader('HX-Current-URL', getDocument().location.href)\n    request.onload = function() {\n      if (this.status >= 200 && this.status < 400) {\n        triggerEvent(getDocument().body, 'htmx:historyCacheMissLoad', details)\n        const fragment = makeFragment(this.response)\n        /** @type ParentNode */\n        const content = fragment.querySelector('[hx-history-elt],[data-hx-history-elt]') || fragment\n        const historyElement = getHistoryElement()\n        const settleInfo = makeSettleInfo(historyElement)\n        handleTitle(fragment.title)\n\n        handlePreservedElements(fragment)\n        swapInnerHTML(historyElement, content, settleInfo)\n        restorePreservedElements()\n        settleImmediately(settleInfo.tasks)\n        currentPathForHistory = path\n        triggerEvent(getDocument().body, 'htmx:historyRestore', { path, cacheMiss: true, serverResponse: this.response })\n      } else {\n        triggerErrorEvent(getDocument().body, 'htmx:historyCacheMissLoadError', details)\n      }\n    }\n    request.send()\n  }\n\n  /**\n   * @param {string} [path]\n   */\n  function restoreHistory(path) {\n    saveCurrentPageToHistory()\n    path = path || location.pathname + location.search\n    const cached = getCachedHistory(path)\n    if (cached) {\n      const fragment = makeFragment(cached.content)\n      const historyElement = getHistoryElement()\n      const settleInfo = makeSettleInfo(historyElement)\n      handleTitle(cached.title)\n      handlePreservedElements(fragment)\n      swapInnerHTML(historyElement, fragment, settleInfo)\n      restorePreservedElements()\n      settleImmediately(settleInfo.tasks)\n      getWindow().setTimeout(function() {\n        window.scrollTo(0, cached.scroll)\n      }, 0) // next 'tick', so browser has time to render layout\n      currentPathForHistory = path\n      triggerEvent(getDocument().body, 'htmx:historyRestore', { path, item: cached })\n    } else {\n      if (htmx.config.refreshOnHistoryMiss) {\n        // @ts-ignore: optional parameter in reload() function throws error\n        // noinspection JSUnresolvedReference\n        window.location.reload(true)\n      } else {\n        loadHistoryFromServer(path)\n      }\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   * @returns {Element[]}\n   */\n  function addRequestIndicatorClasses(elt) {\n    let indicators = /** @type Element[] */ (findAttributeTargets(elt, 'hx-indicator'))\n    if (indicators == null) {\n      indicators = [elt]\n    }\n    forEach(indicators, function(ic) {\n      const internalData = getInternalData(ic)\n      internalData.requestCount = (internalData.requestCount || 0) + 1\n      ic.classList.add.call(ic.classList, htmx.config.requestClass)\n    })\n    return indicators\n  }\n\n  /**\n   * @param {Element} elt\n   * @returns {Element[]}\n   */\n  function disableElements(elt) {\n    let disabledElts = /** @type Element[] */ (findAttributeTargets(elt, 'hx-disabled-elt'))\n    if (disabledElts == null) {\n      disabledElts = []\n    }\n    forEach(disabledElts, function(disabledElement) {\n      const internalData = getInternalData(disabledElement)\n      internalData.requestCount = (internalData.requestCount || 0) + 1\n      disabledElement.setAttribute('disabled', '')\n      disabledElement.setAttribute('data-disabled-by-htmx', '')\n    })\n    return disabledElts\n  }\n\n  /**\n   * @param {Element[]} indicators\n   * @param {Element[]} disabled\n   */\n  function removeRequestIndicators(indicators, disabled) {\n    forEach(indicators.concat(disabled), function(ele) {\n      const internalData = getInternalData(ele)\n      internalData.requestCount = (internalData.requestCount || 1) - 1\n    })\n    forEach(indicators, function(ic) {\n      const internalData = getInternalData(ic)\n      if (internalData.requestCount === 0) {\n        ic.classList.remove.call(ic.classList, htmx.config.requestClass)\n      }\n    })\n    forEach(disabled, function(disabledElement) {\n      const internalData = getInternalData(disabledElement)\n      if (internalData.requestCount === 0) {\n        disabledElement.removeAttribute('disabled')\n        disabledElement.removeAttribute('data-disabled-by-htmx')\n      }\n    })\n  }\n\n  //= ===================================================================\n  // Input Value Processing\n  //= ===================================================================\n\n  /**\n   * @param {Element[]} processed\n   * @param {Element} elt\n   * @returns {boolean}\n   */\n  function haveSeenNode(processed, elt) {\n    for (let i = 0; i < processed.length; i++) {\n      const node = processed[i]\n      if (node.isSameNode(elt)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * @param {Element} element\n   * @return {boolean}\n   */\n  function shouldInclude(element) {\n    // Cast to trick tsc, undefined values will work fine here\n    const elt = /** @type {HTMLInputElement} */ (element)\n    if (elt.name === '' || elt.name == null || elt.disabled || closest(elt, 'fieldset[disabled]')) {\n      return false\n    }\n    // ignore \"submitter\" types (see jQuery src/serialize.js)\n    if (elt.type === 'button' || elt.type === 'submit' || elt.tagName === 'image' || elt.tagName === 'reset' || elt.tagName === 'file') {\n      return false\n    }\n    if (elt.type === 'checkbox' || elt.type === 'radio') {\n      return elt.checked\n    }\n    return true\n  }\n\n  /** @param {string} name\n   * @param {string|Array|FormDataEntryValue} value\n   * @param {FormData} formData */\n  function addValueToFormData(name, value, formData) {\n    if (name != null && value != null) {\n      if (Array.isArray(value)) {\n        value.forEach(function(v) { formData.append(name, v) })\n      } else {\n        formData.append(name, value)\n      }\n    }\n  }\n\n  /** @param {string} name\n   * @param {string|Array} value\n   * @param {FormData} formData */\n  function removeValueFromFormData(name, value, formData) {\n    if (name != null && value != null) {\n      let values = formData.getAll(name)\n      if (Array.isArray(value)) {\n        values = values.filter(v => value.indexOf(v) < 0)\n      } else {\n        values = values.filter(v => v !== value)\n      }\n      formData.delete(name)\n      forEach(values, v => formData.append(name, v))\n    }\n  }\n\n  /**\n   * @param {Element[]} processed\n   * @param {FormData} formData\n   * @param {HtmxElementValidationError[]} errors\n   * @param {Element|HTMLInputElement|HTMLSelectElement|HTMLFormElement} elt\n   * @param {boolean} validate\n   */\n  function processInputValue(processed, formData, errors, elt, validate) {\n    if (elt == null || haveSeenNode(processed, elt)) {\n      return\n    } else {\n      processed.push(elt)\n    }\n    if (shouldInclude(elt)) {\n      const name = getRawAttribute(elt, 'name')\n      // @ts-ignore value will be undefined for non-input elements, which is fine\n      let value = elt.value\n      if (elt instanceof HTMLSelectElement && elt.multiple) {\n        value = toArray(elt.querySelectorAll('option:checked')).map(function(e) { return (/** @type HTMLOptionElement */(e)).value })\n      }\n      // include file inputs\n      if (elt instanceof HTMLInputElement && elt.files) {\n        value = toArray(elt.files)\n      }\n      addValueToFormData(name, value, formData)\n      if (validate) {\n        validateElement(elt, errors)\n      }\n    }\n    if (elt instanceof HTMLFormElement) {\n      forEach(elt.elements, function(input) {\n        if (processed.indexOf(input) >= 0) {\n          // The input has already been processed and added to the values, but the FormData that will be\n          //  constructed right after on the form, will include it once again. So remove that input's value\n          //  now to avoid duplicates\n          removeValueFromFormData(input.name, input.value, formData)\n        } else {\n          processed.push(input)\n        }\n        if (validate) {\n          validateElement(input, errors)\n        }\n      })\n      new FormData(elt).forEach(function(value, name) {\n        if (value instanceof File && value.name === '') {\n          return // ignore no-name files\n        }\n        addValueToFormData(name, value, formData)\n      })\n    }\n  }\n\n  /**\n   *\n   * @param {Element} elt\n   * @param {HtmxElementValidationError[]} errors\n   */\n  function validateElement(elt, errors) {\n    const element = /** @type {HTMLElement & ElementInternals} */ (elt)\n    if (element.willValidate) {\n      triggerEvent(element, 'htmx:validation:validate')\n      if (!element.checkValidity()) {\n        errors.push({ elt: element, message: element.validationMessage, validity: element.validity })\n        triggerEvent(element, 'htmx:validation:failed', { message: element.validationMessage, validity: element.validity })\n      }\n    }\n  }\n\n  /**\n   * Override values in the one FormData with those from another.\n   * @param {FormData} receiver the formdata that will be mutated\n   * @param {FormData} donor the formdata that will provide the overriding values\n   * @returns {FormData} the {@linkcode receiver}\n   */\n  function overrideFormData(receiver, donor) {\n    for (const key of donor.keys()) {\n      receiver.delete(key)\n    }\n    donor.forEach(function(value, key) {\n      receiver.append(key, value)\n    })\n    return receiver\n  }\n\n  /**\n * @param {Element|HTMLFormElement} elt\n * @param {HttpVerb} verb\n * @returns {{errors: HtmxElementValidationError[], formData: FormData, values: Object}}\n */\n  function getInputValues(elt, verb) {\n    /** @type Element[] */\n    const processed = []\n    const formData = new FormData()\n    const priorityFormData = new FormData()\n    /** @type HtmxElementValidationError[] */\n    const errors = []\n    const internalData = getInternalData(elt)\n    if (internalData.lastButtonClicked && !bodyContains(internalData.lastButtonClicked)) {\n      internalData.lastButtonClicked = null\n    }\n\n    // only validate when form is directly submitted and novalidate or formnovalidate are not set\n    // or if the element has an explicit hx-validate=\"true\" on it\n    let validate = (elt instanceof HTMLFormElement && elt.noValidate !== true) || getAttributeValue(elt, 'hx-validate') === 'true'\n    if (internalData.lastButtonClicked) {\n      validate = validate && internalData.lastButtonClicked.formNoValidate !== true\n    }\n\n    // for a non-GET include the closest form\n    if (verb !== 'get') {\n      processInputValue(processed, priorityFormData, errors, closest(elt, 'form'), validate)\n    }\n\n    // include the element itself\n    processInputValue(processed, formData, errors, elt, validate)\n\n    // if a button or submit was clicked last, include its value\n    if (internalData.lastButtonClicked || elt.tagName === 'BUTTON' ||\n    (elt.tagName === 'INPUT' && getRawAttribute(elt, 'type') === 'submit')) {\n      const button = internalData.lastButtonClicked || (/** @type HTMLInputElement|HTMLButtonElement */(elt))\n      const name = getRawAttribute(button, 'name')\n      addValueToFormData(name, button.value, priorityFormData)\n    }\n\n    // include any explicit includes\n    const includes = findAttributeTargets(elt, 'hx-include')\n    forEach(includes, function(node) {\n      processInputValue(processed, formData, errors, asElement(node), validate)\n      // if a non-form is included, include any input values within it\n      if (!matches(node, 'form')) {\n        forEach(asParentNode(node).querySelectorAll(INPUT_SELECTOR), function(descendant) {\n          processInputValue(processed, formData, errors, descendant, validate)\n        })\n      }\n    })\n\n    // values from a <form> take precedence, overriding the regular values\n    overrideFormData(formData, priorityFormData)\n\n    return { errors, formData, values: formDataProxy(formData) }\n  }\n\n  /**\n   * @param {string} returnStr\n   * @param {string} name\n   * @param {any} realValue\n   * @returns {string}\n   */\n  function appendParam(returnStr, name, realValue) {\n    if (returnStr !== '') {\n      returnStr += '&'\n    }\n    if (String(realValue) === '[object Object]') {\n      realValue = JSON.stringify(realValue)\n    }\n    const s = encodeURIComponent(realValue)\n    returnStr += encodeURIComponent(name) + '=' + s\n    return returnStr\n  }\n\n  /**\n   * @param {FormData|Object} values\n   * @returns string\n   */\n  function urlEncode(values) {\n    values = formDataFromObject(values)\n    let returnStr = ''\n    values.forEach(function(value, key) {\n      returnStr = appendParam(returnStr, key, value)\n    })\n    return returnStr\n  }\n\n  //= ===================================================================\n  // Ajax\n  //= ===================================================================\n\n  /**\n * @param {Element} elt\n * @param {Element} target\n * @param {string} prompt\n * @returns {HtmxHeaderSpecification}\n */\n  function getHeaders(elt, target, prompt) {\n    /** @type HtmxHeaderSpecification */\n    const headers = {\n      'HX-Request': 'true',\n      'HX-Trigger': getRawAttribute(elt, 'id'),\n      'HX-Trigger-Name': getRawAttribute(elt, 'name'),\n      'HX-Target': getAttributeValue(target, 'id'),\n      'HX-Current-URL': getDocument().location.href\n    }\n    getValuesForElement(elt, 'hx-headers', false, headers)\n    if (prompt !== undefined) {\n      headers['HX-Prompt'] = prompt\n    }\n    if (getInternalData(elt).boosted) {\n      headers['HX-Boosted'] = 'true'\n    }\n    return headers\n  }\n\n  /**\n * filterValues takes an object containing form input values\n * and returns a new object that only contains keys that are\n * specified by the closest \"hx-params\" attribute\n * @param {FormData} inputValues\n * @param {Element} elt\n * @returns {FormData}\n */\n  function filterValues(inputValues, elt) {\n    const paramsValue = getClosestAttributeValue(elt, 'hx-params')\n    if (paramsValue) {\n      if (paramsValue === 'none') {\n        return new FormData()\n      } else if (paramsValue === '*') {\n        return inputValues\n      } else if (paramsValue.indexOf('not ') === 0) {\n        forEach(paramsValue.substr(4).split(','), function(name) {\n          name = name.trim()\n          inputValues.delete(name)\n        })\n        return inputValues\n      } else {\n        const newValues = new FormData()\n        forEach(paramsValue.split(','), function(name) {\n          name = name.trim()\n          if (inputValues.has(name)) {\n            inputValues.getAll(name).forEach(function(value) { newValues.append(name, value) })\n          }\n        })\n        return newValues\n      }\n    } else {\n      return inputValues\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   * @return {boolean}\n   */\n  function isAnchorLink(elt) {\n    return !!getRawAttribute(elt, 'href') && getRawAttribute(elt, 'href').indexOf('#') >= 0\n  }\n\n  /**\n * @param {Element} elt\n * @param {HtmxSwapStyle} [swapInfoOverride]\n * @returns {HtmxSwapSpecification}\n */\n  function getSwapSpecification(elt, swapInfoOverride) {\n    const swapInfo = swapInfoOverride || getClosestAttributeValue(elt, 'hx-swap')\n    /** @type HtmxSwapSpecification */\n    const swapSpec = {\n      swapStyle: getInternalData(elt).boosted ? 'innerHTML' : htmx.config.defaultSwapStyle,\n      swapDelay: htmx.config.defaultSwapDelay,\n      settleDelay: htmx.config.defaultSettleDelay\n    }\n    if (htmx.config.scrollIntoViewOnBoost && getInternalData(elt).boosted && !isAnchorLink(elt)) {\n      swapSpec.show = 'top'\n    }\n    if (swapInfo) {\n      const split = splitOnWhitespace(swapInfo)\n      if (split.length > 0) {\n        for (let i = 0; i < split.length; i++) {\n          const value = split[i]\n          if (value.indexOf('swap:') === 0) {\n            swapSpec.swapDelay = parseInterval(value.substr(5))\n          } else if (value.indexOf('settle:') === 0) {\n            swapSpec.settleDelay = parseInterval(value.substr(7))\n          } else if (value.indexOf('transition:') === 0) {\n            swapSpec.transition = value.substr(11) === 'true'\n          } else if (value.indexOf('ignoreTitle:') === 0) {\n            swapSpec.ignoreTitle = value.substr(12) === 'true'\n          } else if (value.indexOf('scroll:') === 0) {\n            const scrollSpec = value.substr(7)\n            var splitSpec = scrollSpec.split(':')\n            const scrollVal = splitSpec.pop()\n            var selectorVal = splitSpec.length > 0 ? splitSpec.join(':') : null\n            // @ts-ignore\n            swapSpec.scroll = scrollVal\n            swapSpec.scrollTarget = selectorVal\n          } else if (value.indexOf('show:') === 0) {\n            const showSpec = value.substr(5)\n            var splitSpec = showSpec.split(':')\n            const showVal = splitSpec.pop()\n            var selectorVal = splitSpec.length > 0 ? splitSpec.join(':') : null\n            swapSpec.show = showVal\n            swapSpec.showTarget = selectorVal\n          } else if (value.indexOf('focus-scroll:') === 0) {\n            const focusScrollVal = value.substr('focus-scroll:'.length)\n            swapSpec.focusScroll = focusScrollVal == 'true'\n          } else if (i == 0) {\n            swapSpec.swapStyle = value\n          } else {\n            logError('Unknown modifier in hx-swap: ' + value)\n          }\n        }\n      }\n    }\n    return swapSpec\n  }\n\n  /**\n   * @param {Element} elt\n   * @return {boolean}\n   */\n  function usesFormData(elt) {\n    return getClosestAttributeValue(elt, 'hx-encoding') === 'multipart/form-data' ||\n    (matches(elt, 'form') && getRawAttribute(elt, 'enctype') === 'multipart/form-data')\n  }\n\n  /**\n   * @param {XMLHttpRequest} xhr\n   * @param {Element} elt\n   * @param {FormData} filteredParameters\n   * @returns {*|string|null}\n   */\n  function encodeParamsForBody(xhr, elt, filteredParameters) {\n    let encodedParameters = null\n    withExtensions(elt, function(extension) {\n      if (encodedParameters == null) {\n        encodedParameters = extension.encodeParameters(xhr, filteredParameters, elt)\n      }\n    })\n    if (encodedParameters != null) {\n      return encodedParameters\n    } else {\n      if (usesFormData(elt)) {\n        // Force conversion to an actual FormData object in case filteredParameters is a formDataProxy\n        // See https://github.com/bigskysoftware/htmx/issues/2317\n        return overrideFormData(new FormData(), formDataFromObject(filteredParameters))\n      } else {\n        return urlEncode(filteredParameters)\n      }\n    }\n  }\n\n  /**\n *\n * @param {Element} target\n * @returns {HtmxSettleInfo}\n */\n  function makeSettleInfo(target) {\n    return { tasks: [], elts: [target] }\n  }\n\n  /**\n   * @param {Element[]} content\n   * @param {HtmxSwapSpecification} swapSpec\n   */\n  function updateScrollState(content, swapSpec) {\n    const first = content[0]\n    const last = content[content.length - 1]\n    if (swapSpec.scroll) {\n      var target = null\n      if (swapSpec.scrollTarget) {\n        target = asElement(querySelectorExt(first, swapSpec.scrollTarget))\n      }\n      if (swapSpec.scroll === 'top' && (first || target)) {\n        target = target || first\n        target.scrollTop = 0\n      }\n      if (swapSpec.scroll === 'bottom' && (last || target)) {\n        target = target || last\n        target.scrollTop = target.scrollHeight\n      }\n    }\n    if (swapSpec.show) {\n      var target = null\n      if (swapSpec.showTarget) {\n        let targetStr = swapSpec.showTarget\n        if (swapSpec.showTarget === 'window') {\n          targetStr = 'body'\n        }\n        target = asElement(querySelectorExt(first, targetStr))\n      }\n      if (swapSpec.show === 'top' && (first || target)) {\n        target = target || first\n        // @ts-ignore For some reason tsc doesn't recognize \"instant\" as a valid option for now\n        target.scrollIntoView({ block: 'start', behavior: htmx.config.scrollBehavior })\n      }\n      if (swapSpec.show === 'bottom' && (last || target)) {\n        target = target || last\n        // @ts-ignore For some reason tsc doesn't recognize \"instant\" as a valid option for now\n        target.scrollIntoView({ block: 'end', behavior: htmx.config.scrollBehavior })\n      }\n    }\n  }\n\n  /**\n * @param {Element} elt\n * @param {string} attr\n * @param {boolean=} evalAsDefault\n * @param {Object=} values\n * @returns {Object}\n */\n  function getValuesForElement(elt, attr, evalAsDefault, values) {\n    if (values == null) {\n      values = {}\n    }\n    if (elt == null) {\n      return values\n    }\n    const attributeValue = getAttributeValue(elt, attr)\n    if (attributeValue) {\n      let str = attributeValue.trim()\n      let evaluateValue = evalAsDefault\n      if (str === 'unset') {\n        return null\n      }\n      if (str.indexOf('javascript:') === 0) {\n        str = str.substr(11)\n        evaluateValue = true\n      } else if (str.indexOf('js:') === 0) {\n        str = str.substr(3)\n        evaluateValue = true\n      }\n      if (str.indexOf('{') !== 0) {\n        str = '{' + str + '}'\n      }\n      let varsValues\n      if (evaluateValue) {\n        varsValues = maybeEval(elt, function() { return Function('return (' + str + ')')() }, {})\n      } else {\n        varsValues = parseJSON(str)\n      }\n      for (const key in varsValues) {\n        if (varsValues.hasOwnProperty(key)) {\n          if (values[key] == null) {\n            values[key] = varsValues[key]\n          }\n        }\n      }\n    }\n    return getValuesForElement(asElement(parentElt(elt)), attr, evalAsDefault, values)\n  }\n\n  /**\n   * @param {EventTarget|string} elt\n   * @param {() => any} toEval\n   * @param {any=} defaultVal\n   * @returns {any}\n   */\n  function maybeEval(elt, toEval, defaultVal) {\n    if (htmx.config.allowEval) {\n      return toEval()\n    } else {\n      triggerErrorEvent(elt, 'htmx:evalDisallowedError')\n      return defaultVal\n    }\n  }\n\n  /**\n * @param {Element} elt\n * @param {*?} expressionVars\n * @returns\n */\n  function getHXVarsForElement(elt, expressionVars) {\n    return getValuesForElement(elt, 'hx-vars', true, expressionVars)\n  }\n\n  /**\n * @param {Element} elt\n * @param {*?} expressionVars\n * @returns\n */\n  function getHXValsForElement(elt, expressionVars) {\n    return getValuesForElement(elt, 'hx-vals', false, expressionVars)\n  }\n\n  /**\n * @param {Element} elt\n * @returns {FormData}\n */\n  function getExpressionVars(elt) {\n    return mergeObjects(getHXVarsForElement(elt), getHXValsForElement(elt))\n  }\n\n  /**\n   * @param {XMLHttpRequest} xhr\n   * @param {string} header\n   * @param {string|null} headerValue\n   */\n  function safelySetHeaderValue(xhr, header, headerValue) {\n    if (headerValue !== null) {\n      try {\n        xhr.setRequestHeader(header, headerValue)\n      } catch (e) {\n      // On an exception, try to set the header URI encoded instead\n        xhr.setRequestHeader(header, encodeURIComponent(headerValue))\n        xhr.setRequestHeader(header + '-URI-AutoEncoded', 'true')\n      }\n    }\n  }\n\n  /**\n   * @param {XMLHttpRequest} xhr\n   * @return {string}\n   */\n  function getPathFromResponse(xhr) {\n  // NB: IE11 does not support this stuff\n    if (xhr.responseURL && typeof (URL) !== 'undefined') {\n      try {\n        const url = new URL(xhr.responseURL)\n        return url.pathname + url.search\n      } catch (e) {\n        triggerErrorEvent(getDocument().body, 'htmx:badResponseUrl', { url: xhr.responseURL })\n      }\n    }\n  }\n\n  /**\n   * @param {XMLHttpRequest} xhr\n   * @param {RegExp} regexp\n   * @return {boolean}\n   */\n  function hasHeader(xhr, regexp) {\n    return regexp.test(xhr.getAllResponseHeaders())\n  }\n\n  /**\n   * Issues an htmx-style AJAX request\n   *\n   * @see https://htmx.org/api/#ajax\n   *\n   * @param {HttpVerb} verb\n   * @param {string} path the URL path to make the AJAX\n   * @param {Element|string|HtmxAjaxHelperContext} context the element to target (defaults to the **body**) | a selector for the target | a context object that contains any of the following\n   * @return {Promise<void>} Promise that resolves immediately if no request is sent, or when the request is complete\n   */\n  function ajaxHelper(verb, path, context) {\n    verb = (/** @type HttpVerb */(verb.toLowerCase()))\n    if (context) {\n      if (context instanceof Element || typeof context === 'string') {\n        return issueAjaxRequest(verb, path, null, null, {\n          targetOverride: resolveTarget(context) || DUMMY_ELT,\n          returnPromise: true\n        })\n      } else {\n        let resolvedTarget = resolveTarget(context.target)\n        // If target is supplied but can't resolve OR both target and source can't be resolved\n        // then use DUMMY_ELT to abort the request with htmx:targetError to avoid it replacing body by mistake\n        if ((context.target && !resolvedTarget) || (!resolvedTarget && !resolveTarget(context.source))) {\n          resolvedTarget = DUMMY_ELT\n        }\n        return issueAjaxRequest(verb, path, resolveTarget(context.source), context.event,\n          {\n            handler: context.handler,\n            headers: context.headers,\n            values: context.values,\n            targetOverride: resolvedTarget,\n            swapOverride: context.swap,\n            select: context.select,\n            returnPromise: true\n          })\n      }\n    } else {\n      return issueAjaxRequest(verb, path, null, null, {\n        returnPromise: true\n      })\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   * @return {Element[]}\n   */\n  function hierarchyForElt(elt) {\n    const arr = []\n    while (elt) {\n      arr.push(elt)\n      elt = elt.parentElement\n    }\n    return arr\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {string} path\n   * @param {HtmxRequestConfig} requestConfig\n   * @return {boolean}\n   */\n  function verifyPath(elt, path, requestConfig) {\n    let sameHost\n    let url\n    if (typeof URL === 'function') {\n      url = new URL(path, document.location.href)\n      const origin = document.location.origin\n      sameHost = origin === url.origin\n    } else {\n    // IE11 doesn't support URL\n      url = path\n      sameHost = startsWith(path, document.location.origin)\n    }\n\n    if (htmx.config.selfRequestsOnly) {\n      if (!sameHost) {\n        return false\n      }\n    }\n    return triggerEvent(elt, 'htmx:validateUrl', mergeObjects({ url, sameHost }, requestConfig))\n  }\n\n  /**\n   * @param {Object|FormData} obj\n   * @return {FormData}\n   */\n  function formDataFromObject(obj) {\n    if (obj instanceof FormData) return obj\n    const formData = new FormData()\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        if (obj[key] && typeof obj[key].forEach === 'function') {\n          obj[key].forEach(function(v) { formData.append(key, v) })\n        } else if (typeof obj[key] === 'object' && !(obj[key] instanceof Blob)) {\n          formData.append(key, JSON.stringify(obj[key]))\n        } else {\n          formData.append(key, obj[key])\n        }\n      }\n    }\n    return formData\n  }\n\n  /**\n   * @param {FormData} formData\n   * @param {string} name\n   * @param {Array} array\n   * @returns {Array}\n   */\n  function formDataArrayProxy(formData, name, array) {\n    // mutating the array should mutate the underlying form data\n    return new Proxy(array, {\n      get: function(target, key) {\n        if (typeof key === 'number') return target[key]\n        if (key === 'length') return target.length\n        if (key === 'push') {\n          return function(value) {\n            target.push(value)\n            formData.append(name, value)\n          }\n        }\n        if (typeof target[key] === 'function') {\n          return function() {\n            target[key].apply(target, arguments)\n            formData.delete(name)\n            target.forEach(function(v) { formData.append(name, v) })\n          }\n        }\n\n        if (target[key] && target[key].length === 1) {\n          return target[key][0]\n        } else {\n          return target[key]\n        }\n      },\n      set: function(target, index, value) {\n        target[index] = value\n        formData.delete(name)\n        target.forEach(function(v) { formData.append(name, v) })\n        return true\n      }\n    })\n  }\n\n  /**\n   * @param {FormData} formData\n   * @returns {Object}\n   */\n  function formDataProxy(formData) {\n    return new Proxy(formData, {\n      get: function(target, name) {\n        if (typeof name === 'symbol') {\n          // Forward symbol calls to the FormData itself directly\n          return Reflect.get(target, name)\n        }\n        if (name === 'toJSON') {\n          // Support JSON.stringify call on proxy\n          return () => Object.fromEntries(formData)\n        }\n        if (name in target) {\n          // Wrap in function with apply to correctly bind the FormData context, as a direct call would result in an illegal invocation error\n          if (typeof target[name] === 'function') {\n            return function() {\n              return formData[name].apply(formData, arguments)\n            }\n          } else {\n            return target[name]\n          }\n        }\n        const array = formData.getAll(name)\n        // Those 2 undefined & single value returns are for retro-compatibility as we weren't using FormData before\n        if (array.length === 0) {\n          return undefined\n        } else if (array.length === 1) {\n          return array[0]\n        } else {\n          return formDataArrayProxy(target, name, array)\n        }\n      },\n      set: function(target, name, value) {\n        if (typeof name !== 'string') {\n          return false\n        }\n        target.delete(name)\n        if (value && typeof value.forEach === 'function') {\n          value.forEach(function(v) { target.append(name, v) })\n        } else if (typeof value === 'object' && !(value instanceof Blob)) {\n          target.append(name, JSON.stringify(value))\n        } else {\n          target.append(name, value)\n        }\n        return true\n      },\n      deleteProperty: function(target, name) {\n        if (typeof name === 'string') {\n          target.delete(name)\n        }\n        return true\n      },\n      // Support Object.assign call from proxy\n      ownKeys: function(target) {\n        return Reflect.ownKeys(Object.fromEntries(target))\n      },\n      getOwnPropertyDescriptor: function(target, prop) {\n        return Reflect.getOwnPropertyDescriptor(Object.fromEntries(target), prop)\n      }\n    })\n  }\n\n  /**\n   * @param {HttpVerb} verb\n   * @param {string} path\n   * @param {Element} elt\n   * @param {Event} event\n   * @param {HtmxAjaxEtc} [etc]\n   * @param {boolean} [confirmed]\n   * @return {Promise<void>}\n   */\n  function issueAjaxRequest(verb, path, elt, event, etc, confirmed) {\n    let resolve = null\n    let reject = null\n    etc = etc != null ? etc : {}\n    if (etc.returnPromise && typeof Promise !== 'undefined') {\n      var promise = new Promise(function(_resolve, _reject) {\n        resolve = _resolve\n        reject = _reject\n      })\n    }\n    if (elt == null) {\n      elt = getDocument().body\n    }\n    const responseHandler = etc.handler || handleAjaxResponse\n    const select = etc.select || null\n\n    if (!bodyContains(elt)) {\n    // do not issue requests for elements removed from the DOM\n      maybeCall(resolve)\n      return promise\n    }\n    const target = etc.targetOverride || asElement(getTarget(elt))\n    if (target == null || target == DUMMY_ELT) {\n      triggerErrorEvent(elt, 'htmx:targetError', { target: getAttributeValue(elt, 'hx-target') })\n      maybeCall(reject)\n      return promise\n    }\n\n    let eltData = getInternalData(elt)\n    const submitter = eltData.lastButtonClicked\n\n    if (submitter) {\n      const buttonPath = getRawAttribute(submitter, 'formaction')\n      if (buttonPath != null) {\n        path = buttonPath\n      }\n\n      const buttonVerb = getRawAttribute(submitter, 'formmethod')\n      if (buttonVerb != null) {\n      // ignore buttons with formmethod=\"dialog\"\n        if (buttonVerb.toLowerCase() !== 'dialog') {\n          verb = (/** @type HttpVerb */(buttonVerb))\n        }\n      }\n    }\n\n    const confirmQuestion = getClosestAttributeValue(elt, 'hx-confirm')\n    // allow event-based confirmation w/ a callback\n    if (confirmed === undefined) {\n      const issueRequest = function(skipConfirmation) {\n        return issueAjaxRequest(verb, path, elt, event, etc, !!skipConfirmation)\n      }\n      const confirmDetails = { target, elt, path, verb, triggeringEvent: event, etc, issueRequest, question: confirmQuestion }\n      if (triggerEvent(elt, 'htmx:confirm', confirmDetails) === false) {\n        maybeCall(resolve)\n        return promise\n      }\n    }\n\n    let syncElt = elt\n    let syncStrategy = getClosestAttributeValue(elt, 'hx-sync')\n    let queueStrategy = null\n    let abortable = false\n    if (syncStrategy) {\n      const syncStrings = syncStrategy.split(':')\n      const selector = syncStrings[0].trim()\n      if (selector === 'this') {\n        syncElt = findThisElement(elt, 'hx-sync')\n      } else {\n        syncElt = asElement(querySelectorExt(elt, selector))\n      }\n      // default to the drop strategy\n      syncStrategy = (syncStrings[1] || 'drop').trim()\n      eltData = getInternalData(syncElt)\n      if (syncStrategy === 'drop' && eltData.xhr && eltData.abortable !== true) {\n        maybeCall(resolve)\n        return promise\n      } else if (syncStrategy === 'abort') {\n        if (eltData.xhr) {\n          maybeCall(resolve)\n          return promise\n        } else {\n          abortable = true\n        }\n      } else if (syncStrategy === 'replace') {\n        triggerEvent(syncElt, 'htmx:abort') // abort the current request and continue\n      } else if (syncStrategy.indexOf('queue') === 0) {\n        const queueStrArray = syncStrategy.split(' ')\n        queueStrategy = (queueStrArray[1] || 'last').trim()\n      }\n    }\n\n    if (eltData.xhr) {\n      if (eltData.abortable) {\n        triggerEvent(syncElt, 'htmx:abort') // abort the current request and continue\n      } else {\n        if (queueStrategy == null) {\n          if (event) {\n            const eventData = getInternalData(event)\n            if (eventData && eventData.triggerSpec && eventData.triggerSpec.queue) {\n              queueStrategy = eventData.triggerSpec.queue\n            }\n          }\n          if (queueStrategy == null) {\n            queueStrategy = 'last'\n          }\n        }\n        if (eltData.queuedRequests == null) {\n          eltData.queuedRequests = []\n        }\n        if (queueStrategy === 'first' && eltData.queuedRequests.length === 0) {\n          eltData.queuedRequests.push(function() {\n            issueAjaxRequest(verb, path, elt, event, etc)\n          })\n        } else if (queueStrategy === 'all') {\n          eltData.queuedRequests.push(function() {\n            issueAjaxRequest(verb, path, elt, event, etc)\n          })\n        } else if (queueStrategy === 'last') {\n          eltData.queuedRequests = [] // dump existing queue\n          eltData.queuedRequests.push(function() {\n            issueAjaxRequest(verb, path, elt, event, etc)\n          })\n        }\n        maybeCall(resolve)\n        return promise\n      }\n    }\n\n    const xhr = new XMLHttpRequest()\n    eltData.xhr = xhr\n    eltData.abortable = abortable\n    const endRequestLock = function() {\n      eltData.xhr = null\n      eltData.abortable = false\n      if (eltData.queuedRequests != null &&\n      eltData.queuedRequests.length > 0) {\n        const queuedRequest = eltData.queuedRequests.shift()\n        queuedRequest()\n      }\n    }\n    const promptQuestion = getClosestAttributeValue(elt, 'hx-prompt')\n    if (promptQuestion) {\n      var promptResponse = prompt(promptQuestion)\n      // prompt returns null if cancelled and empty string if accepted with no entry\n      if (promptResponse === null ||\n      !triggerEvent(elt, 'htmx:prompt', { prompt: promptResponse, target })) {\n        maybeCall(resolve)\n        endRequestLock()\n        return promise\n      }\n    }\n\n    if (confirmQuestion && !confirmed) {\n      if (!confirm(confirmQuestion)) {\n        maybeCall(resolve)\n        endRequestLock()\n        return promise\n      }\n    }\n\n    let headers = getHeaders(elt, target, promptResponse)\n\n    if (verb !== 'get' && !usesFormData(elt)) {\n      headers['Content-Type'] = 'application/x-www-form-urlencoded'\n    }\n\n    if (etc.headers) {\n      headers = mergeObjects(headers, etc.headers)\n    }\n    const results = getInputValues(elt, verb)\n    let errors = results.errors\n    const rawFormData = results.formData\n    if (etc.values) {\n      overrideFormData(rawFormData, formDataFromObject(etc.values))\n    }\n    const expressionVars = formDataFromObject(getExpressionVars(elt))\n    const allFormData = overrideFormData(rawFormData, expressionVars)\n    let filteredFormData = filterValues(allFormData, elt)\n\n    if (htmx.config.getCacheBusterParam && verb === 'get') {\n      filteredFormData.set('org.htmx.cache-buster', getRawAttribute(target, 'id') || 'true')\n    }\n\n    // behavior of anchors w/ empty href is to use the current URL\n    if (path == null || path === '') {\n      path = getDocument().location.href\n    }\n\n    /**\n     * @type {Object}\n     * @property {boolean} [credentials]\n     * @property {number} [timeout]\n     * @property {boolean} [noHeaders]\n     */\n    const requestAttrValues = getValuesForElement(elt, 'hx-request')\n\n    const eltIsBoosted = getInternalData(elt).boosted\n\n    let useUrlParams = htmx.config.methodsThatUseUrlParams.indexOf(verb) >= 0\n\n    /** @type HtmxRequestConfig */\n    const requestConfig = {\n      boosted: eltIsBoosted,\n      useUrlParams,\n      formData: filteredFormData,\n      parameters: formDataProxy(filteredFormData),\n      unfilteredFormData: allFormData,\n      unfilteredParameters: formDataProxy(allFormData),\n      headers,\n      target,\n      verb,\n      errors,\n      withCredentials: etc.credentials || requestAttrValues.credentials || htmx.config.withCredentials,\n      timeout: etc.timeout || requestAttrValues.timeout || htmx.config.timeout,\n      path,\n      triggeringEvent: event\n    }\n\n    if (!triggerEvent(elt, 'htmx:configRequest', requestConfig)) {\n      maybeCall(resolve)\n      endRequestLock()\n      return promise\n    }\n\n    // copy out in case the object was overwritten\n    path = requestConfig.path\n    verb = requestConfig.verb\n    headers = requestConfig.headers\n    filteredFormData = formDataFromObject(requestConfig.parameters)\n    errors = requestConfig.errors\n    useUrlParams = requestConfig.useUrlParams\n\n    if (errors && errors.length > 0) {\n      triggerEvent(elt, 'htmx:validation:halted', requestConfig)\n      maybeCall(resolve)\n      endRequestLock()\n      return promise\n    }\n\n    const splitPath = path.split('#')\n    const pathNoAnchor = splitPath[0]\n    const anchor = splitPath[1]\n\n    let finalPath = path\n    if (useUrlParams) {\n      finalPath = pathNoAnchor\n      const hasValues = !filteredFormData.keys().next().done\n      if (hasValues) {\n        if (finalPath.indexOf('?') < 0) {\n          finalPath += '?'\n        } else {\n          finalPath += '&'\n        }\n        finalPath += urlEncode(filteredFormData)\n        if (anchor) {\n          finalPath += '#' + anchor\n        }\n      }\n    }\n\n    if (!verifyPath(elt, finalPath, requestConfig)) {\n      triggerErrorEvent(elt, 'htmx:invalidPath', requestConfig)\n      maybeCall(reject)\n      return promise\n    }\n\n    xhr.open(verb.toUpperCase(), finalPath, true)\n    xhr.overrideMimeType('text/html')\n    xhr.withCredentials = requestConfig.withCredentials\n    xhr.timeout = requestConfig.timeout\n\n    // request headers\n    if (requestAttrValues.noHeaders) {\n    // ignore all headers\n    } else {\n      for (const header in headers) {\n        if (headers.hasOwnProperty(header)) {\n          const headerValue = headers[header]\n          safelySetHeaderValue(xhr, header, headerValue)\n        }\n      }\n    }\n\n    /** @type {HtmxResponseInfo} */\n    const responseInfo = {\n      xhr,\n      target,\n      requestConfig,\n      etc,\n      boosted: eltIsBoosted,\n      select,\n      pathInfo: {\n        requestPath: path,\n        finalRequestPath: finalPath,\n        responsePath: null,\n        anchor\n      }\n    }\n\n    xhr.onload = function() {\n      try {\n        const hierarchy = hierarchyForElt(elt)\n        responseInfo.pathInfo.responsePath = getPathFromResponse(xhr)\n        responseHandler(elt, responseInfo)\n        if (responseInfo.keepIndicators !== true) {\n          removeRequestIndicators(indicators, disableElts)\n        }\n        triggerEvent(elt, 'htmx:afterRequest', responseInfo)\n        triggerEvent(elt, 'htmx:afterOnLoad', responseInfo)\n        // if the body no longer contains the element, trigger the event on the closest parent\n        // remaining in the DOM\n        if (!bodyContains(elt)) {\n          let secondaryTriggerElt = null\n          while (hierarchy.length > 0 && secondaryTriggerElt == null) {\n            const parentEltInHierarchy = hierarchy.shift()\n            if (bodyContains(parentEltInHierarchy)) {\n              secondaryTriggerElt = parentEltInHierarchy\n            }\n          }\n          if (secondaryTriggerElt) {\n            triggerEvent(secondaryTriggerElt, 'htmx:afterRequest', responseInfo)\n            triggerEvent(secondaryTriggerElt, 'htmx:afterOnLoad', responseInfo)\n          }\n        }\n        maybeCall(resolve)\n        endRequestLock()\n      } catch (e) {\n        triggerErrorEvent(elt, 'htmx:onLoadError', mergeObjects({ error: e }, responseInfo))\n        throw e\n      }\n    }\n    xhr.onerror = function() {\n      removeRequestIndicators(indicators, disableElts)\n      triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo)\n      triggerErrorEvent(elt, 'htmx:sendError', responseInfo)\n      maybeCall(reject)\n      endRequestLock()\n    }\n    xhr.onabort = function() {\n      removeRequestIndicators(indicators, disableElts)\n      triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo)\n      triggerErrorEvent(elt, 'htmx:sendAbort', responseInfo)\n      maybeCall(reject)\n      endRequestLock()\n    }\n    xhr.ontimeout = function() {\n      removeRequestIndicators(indicators, disableElts)\n      triggerErrorEvent(elt, 'htmx:afterRequest', responseInfo)\n      triggerErrorEvent(elt, 'htmx:timeout', responseInfo)\n      maybeCall(reject)\n      endRequestLock()\n    }\n    if (!triggerEvent(elt, 'htmx:beforeRequest', responseInfo)) {\n      maybeCall(resolve)\n      endRequestLock()\n      return promise\n    }\n    var indicators = addRequestIndicatorClasses(elt)\n    var disableElts = disableElements(elt)\n\n    forEach(['loadstart', 'loadend', 'progress', 'abort'], function(eventName) {\n      forEach([xhr, xhr.upload], function(target) {\n        target.addEventListener(eventName, function(event) {\n          triggerEvent(elt, 'htmx:xhr:' + eventName, {\n            lengthComputable: event.lengthComputable,\n            loaded: event.loaded,\n            total: event.total\n          })\n        })\n      })\n    })\n    triggerEvent(elt, 'htmx:beforeSend', responseInfo)\n    const params = useUrlParams ? null : encodeParamsForBody(xhr, elt, filteredFormData)\n    xhr.send(params)\n    return promise\n  }\n\n  /**\n   * @typedef {Object} HtmxHistoryUpdate\n   * @property {string|null} [type]\n   * @property {string|null} [path]\n   */\n\n  /**\n   * @param {Element} elt\n   * @param {HtmxResponseInfo} responseInfo\n   * @return {HtmxHistoryUpdate}\n   */\n  function determineHistoryUpdates(elt, responseInfo) {\n    const xhr = responseInfo.xhr\n\n    //= ==========================================\n    // First consult response headers\n    //= ==========================================\n    let pathFromHeaders = null\n    let typeFromHeaders = null\n    if (hasHeader(xhr, /HX-Push:/i)) {\n      pathFromHeaders = xhr.getResponseHeader('HX-Push')\n      typeFromHeaders = 'push'\n    } else if (hasHeader(xhr, /HX-Push-Url:/i)) {\n      pathFromHeaders = xhr.getResponseHeader('HX-Push-Url')\n      typeFromHeaders = 'push'\n    } else if (hasHeader(xhr, /HX-Replace-Url:/i)) {\n      pathFromHeaders = xhr.getResponseHeader('HX-Replace-Url')\n      typeFromHeaders = 'replace'\n    }\n\n    // if there was a response header, that has priority\n    if (pathFromHeaders) {\n      if (pathFromHeaders === 'false') {\n        return {}\n      } else {\n        return {\n          type: typeFromHeaders,\n          path: pathFromHeaders\n        }\n      }\n    }\n\n    //= ==========================================\n    // Next resolve via DOM values\n    //= ==========================================\n    const requestPath = responseInfo.pathInfo.finalRequestPath\n    const responsePath = responseInfo.pathInfo.responsePath\n\n    const pushUrl = getClosestAttributeValue(elt, 'hx-push-url')\n    const replaceUrl = getClosestAttributeValue(elt, 'hx-replace-url')\n    const elementIsBoosted = getInternalData(elt).boosted\n\n    let saveType = null\n    let path = null\n\n    if (pushUrl) {\n      saveType = 'push'\n      path = pushUrl\n    } else if (replaceUrl) {\n      saveType = 'replace'\n      path = replaceUrl\n    } else if (elementIsBoosted) {\n      saveType = 'push'\n      path = responsePath || requestPath // if there is no response path, go with the original request path\n    }\n\n    if (path) {\n    // false indicates no push, return empty object\n      if (path === 'false') {\n        return {}\n      }\n\n      // true indicates we want to follow wherever the server ended up sending us\n      if (path === 'true') {\n        path = responsePath || requestPath // if there is no response path, go with the original request path\n      }\n\n      // restore any anchor associated with the request\n      if (responseInfo.pathInfo.anchor && path.indexOf('#') === -1) {\n        path = path + '#' + responseInfo.pathInfo.anchor\n      }\n\n      return {\n        type: saveType,\n        path\n      }\n    } else {\n      return {}\n    }\n  }\n\n  /**\n   * @param {HtmxResponseHandlingConfig} responseHandlingConfig\n   * @param {number} status\n   * @return {boolean}\n   */\n  function codeMatches(responseHandlingConfig, status) {\n    var regExp = new RegExp(responseHandlingConfig.code)\n    return regExp.test(status.toString(10))\n  }\n\n  /**\n   * @param {XMLHttpRequest} xhr\n   * @return {HtmxResponseHandlingConfig}\n   */\n  function resolveResponseHandling(xhr) {\n    for (var i = 0; i < htmx.config.responseHandling.length; i++) {\n      /** @type HtmxResponseHandlingConfig */\n      var responseHandlingElement = htmx.config.responseHandling[i]\n      if (codeMatches(responseHandlingElement, xhr.status)) {\n        return responseHandlingElement\n      }\n    }\n    // no matches, return no swap\n    return {\n      swap: false\n    }\n  }\n\n  /**\n   * @param {string} title\n   */\n  function handleTitle(title) {\n    if (title) {\n      const titleElt = find('title')\n      if (titleElt) {\n        titleElt.innerHTML = title\n      } else {\n        window.document.title = title\n      }\n    }\n  }\n\n  /**\n   * @param {Element} elt\n   * @param {HtmxResponseInfo} responseInfo\n   */\n  function handleAjaxResponse(elt, responseInfo) {\n    const xhr = responseInfo.xhr\n    let target = responseInfo.target\n    const etc = responseInfo.etc\n    const responseInfoSelect = responseInfo.select\n\n    if (!triggerEvent(elt, 'htmx:beforeOnLoad', responseInfo)) return\n\n    if (hasHeader(xhr, /HX-Trigger:/i)) {\n      handleTriggerHeader(xhr, 'HX-Trigger', elt)\n    }\n\n    if (hasHeader(xhr, /HX-Location:/i)) {\n      saveCurrentPageToHistory()\n      let redirectPath = xhr.getResponseHeader('HX-Location')\n      /** @type {HtmxAjaxHelperContext&{path:string}} */\n      var redirectSwapSpec\n      if (redirectPath.indexOf('{') === 0) {\n        redirectSwapSpec = parseJSON(redirectPath)\n        // what's the best way to throw an error if the user didn't include this\n        redirectPath = redirectSwapSpec.path\n        delete redirectSwapSpec.path\n      }\n      ajaxHelper('get', redirectPath, redirectSwapSpec).then(function() {\n        pushUrlIntoHistory(redirectPath)\n      })\n      return\n    }\n\n    const shouldRefresh = hasHeader(xhr, /HX-Refresh:/i) && xhr.getResponseHeader('HX-Refresh') === 'true'\n\n    if (hasHeader(xhr, /HX-Redirect:/i)) {\n      responseInfo.keepIndicators = true\n      location.href = xhr.getResponseHeader('HX-Redirect')\n      shouldRefresh && location.reload()\n      return\n    }\n\n    if (shouldRefresh) {\n      responseInfo.keepIndicators = true\n      location.reload()\n      return\n    }\n\n    if (hasHeader(xhr, /HX-Retarget:/i)) {\n      if (xhr.getResponseHeader('HX-Retarget') === 'this') {\n        responseInfo.target = elt\n      } else {\n        responseInfo.target = asElement(querySelectorExt(elt, xhr.getResponseHeader('HX-Retarget')))\n      }\n    }\n\n    const historyUpdate = determineHistoryUpdates(elt, responseInfo)\n\n    const responseHandling = resolveResponseHandling(xhr)\n    const shouldSwap = responseHandling.swap\n    let isError = !!responseHandling.error\n    let ignoreTitle = htmx.config.ignoreTitle || responseHandling.ignoreTitle\n    let selectOverride = responseHandling.select\n    if (responseHandling.target) {\n      responseInfo.target = asElement(querySelectorExt(elt, responseHandling.target))\n    }\n    var swapOverride = etc.swapOverride\n    if (swapOverride == null && responseHandling.swapOverride) {\n      swapOverride = responseHandling.swapOverride\n    }\n\n    // response headers override response handling config\n    if (hasHeader(xhr, /HX-Retarget:/i)) {\n      if (xhr.getResponseHeader('HX-Retarget') === 'this') {\n        responseInfo.target = elt\n      } else {\n        responseInfo.target = asElement(querySelectorExt(elt, xhr.getResponseHeader('HX-Retarget')))\n      }\n    }\n    if (hasHeader(xhr, /HX-Reswap:/i)) {\n      swapOverride = xhr.getResponseHeader('HX-Reswap')\n    }\n\n    var serverResponse = xhr.response\n    /** @type HtmxBeforeSwapDetails */\n    var beforeSwapDetails = mergeObjects({\n      shouldSwap,\n      serverResponse,\n      isError,\n      ignoreTitle,\n      selectOverride,\n      swapOverride\n    }, responseInfo)\n\n    if (responseHandling.event && !triggerEvent(target, responseHandling.event, beforeSwapDetails)) return\n\n    if (!triggerEvent(target, 'htmx:beforeSwap', beforeSwapDetails)) return\n\n    target = beforeSwapDetails.target // allow re-targeting\n    serverResponse = beforeSwapDetails.serverResponse // allow updating content\n    isError = beforeSwapDetails.isError // allow updating error\n    ignoreTitle = beforeSwapDetails.ignoreTitle // allow updating ignoring title\n    selectOverride = beforeSwapDetails.selectOverride // allow updating select override\n    swapOverride = beforeSwapDetails.swapOverride // allow updating swap override\n\n    responseInfo.target = target // Make updated target available to response events\n    responseInfo.failed = isError // Make failed property available to response events\n    responseInfo.successful = !isError // Make successful property available to response events\n\n    if (beforeSwapDetails.shouldSwap) {\n      if (xhr.status === 286) {\n        cancelPolling(elt)\n      }\n\n      withExtensions(elt, function(extension) {\n        serverResponse = extension.transformResponse(serverResponse, xhr, elt)\n      })\n\n      // Save current page if there will be a history update\n      if (historyUpdate.type) {\n        saveCurrentPageToHistory()\n      }\n\n      var swapSpec = getSwapSpecification(elt, swapOverride)\n\n      if (!swapSpec.hasOwnProperty('ignoreTitle')) {\n        swapSpec.ignoreTitle = ignoreTitle\n      }\n\n      target.classList.add(htmx.config.swappingClass)\n\n      // optional transition API promise callbacks\n      let settleResolve = null\n      let settleReject = null\n\n      if (responseInfoSelect) {\n        selectOverride = responseInfoSelect\n      }\n\n      if (hasHeader(xhr, /HX-Reselect:/i)) {\n        selectOverride = xhr.getResponseHeader('HX-Reselect')\n      }\n\n      const selectOOB = getClosestAttributeValue(elt, 'hx-select-oob')\n      const select = getClosestAttributeValue(elt, 'hx-select')\n\n      let doSwap = function() {\n        try {\n          // if we need to save history, do so, before swapping so that relative resources have the correct base URL\n          if (historyUpdate.type) {\n            triggerEvent(getDocument().body, 'htmx:beforeHistoryUpdate', mergeObjects({ history: historyUpdate }, responseInfo))\n            if (historyUpdate.type === 'push') {\n              pushUrlIntoHistory(historyUpdate.path)\n              triggerEvent(getDocument().body, 'htmx:pushedIntoHistory', { path: historyUpdate.path })\n            } else {\n              replaceUrlInHistory(historyUpdate.path)\n              triggerEvent(getDocument().body, 'htmx:replacedInHistory', { path: historyUpdate.path })\n            }\n          }\n\n          swap(target, serverResponse, swapSpec, {\n            select: selectOverride || select,\n            selectOOB,\n            eventInfo: responseInfo,\n            anchor: responseInfo.pathInfo.anchor,\n            contextElement: elt,\n            afterSwapCallback: function() {\n              if (hasHeader(xhr, /HX-Trigger-After-Swap:/i)) {\n                let finalElt = elt\n                if (!bodyContains(elt)) {\n                  finalElt = getDocument().body\n                }\n                handleTriggerHeader(xhr, 'HX-Trigger-After-Swap', finalElt)\n              }\n            },\n            afterSettleCallback: function() {\n              if (hasHeader(xhr, /HX-Trigger-After-Settle:/i)) {\n                let finalElt = elt\n                if (!bodyContains(elt)) {\n                  finalElt = getDocument().body\n                }\n                handleTriggerHeader(xhr, 'HX-Trigger-After-Settle', finalElt)\n              }\n              maybeCall(settleResolve)\n            }\n          })\n        } catch (e) {\n          triggerErrorEvent(elt, 'htmx:swapError', responseInfo)\n          maybeCall(settleReject)\n          throw e\n        }\n      }\n\n      let shouldTransition = htmx.config.globalViewTransitions\n      if (swapSpec.hasOwnProperty('transition')) {\n        shouldTransition = swapSpec.transition\n      }\n\n      if (shouldTransition &&\n              triggerEvent(elt, 'htmx:beforeTransition', responseInfo) &&\n              typeof Promise !== 'undefined' &&\n              // @ts-ignore experimental feature atm\n              document.startViewTransition) {\n        const settlePromise = new Promise(function(_resolve, _reject) {\n          settleResolve = _resolve\n          settleReject = _reject\n        })\n        // wrap the original doSwap() in a call to startViewTransition()\n        const innerDoSwap = doSwap\n        doSwap = function() {\n          // @ts-ignore experimental feature atm\n          document.startViewTransition(function() {\n            innerDoSwap()\n            return settlePromise\n          })\n        }\n      }\n\n      if (swapSpec.swapDelay > 0) {\n        getWindow().setTimeout(doSwap, swapSpec.swapDelay)\n      } else {\n        doSwap()\n      }\n    }\n    if (isError) {\n      triggerErrorEvent(elt, 'htmx:responseError', mergeObjects({ error: 'Response Status Error Code ' + xhr.status + ' from ' + responseInfo.pathInfo.requestPath }, responseInfo))\n    }\n  }\n\n  //= ===================================================================\n  // Extensions API\n  //= ===================================================================\n\n  /** @type {Object<string, HtmxExtension>} */\n  const extensions = {}\n\n  /**\n   * extensionBase defines the default functions for all extensions.\n   * @returns {HtmxExtension}\n   */\n  function extensionBase() {\n    return {\n      init: function(api) { return null },\n      getSelectors: function() { return null },\n      onEvent: function(name, evt) { return true },\n      transformResponse: function(text, xhr, elt) { return text },\n      isInlineSwap: function(swapStyle) { return false },\n      handleSwap: function(swapStyle, target, fragment, settleInfo) { return false },\n      encodeParameters: function(xhr, parameters, elt) { return null }\n    }\n  }\n\n  /**\n   * defineExtension initializes the extension and adds it to the htmx registry\n   *\n   * @see https://htmx.org/api/#defineExtension\n   *\n   * @param {string} name the extension name\n   * @param {HtmxExtension} extension the extension definition\n   */\n  function defineExtension(name, extension) {\n    if (extension.init) {\n      extension.init(internalAPI)\n    }\n    extensions[name] = mergeObjects(extensionBase(), extension)\n  }\n\n  /**\n   * removeExtension removes an extension from the htmx registry\n   *\n   * @see https://htmx.org/api/#removeExtension\n   *\n   * @param {string} name\n   */\n  function removeExtension(name) {\n    delete extensions[name]\n  }\n\n  /**\n   * getExtensions searches up the DOM tree to return all extensions that can be applied to a given element\n   *\n   * @param {Element} elt\n   * @param {HtmxExtension[]=} extensionsToReturn\n   * @param {string[]=} extensionsToIgnore\n   * @returns {HtmxExtension[]}\n   */\n  function getExtensions(elt, extensionsToReturn, extensionsToIgnore) {\n    if (extensionsToReturn == undefined) {\n      extensionsToReturn = []\n    }\n    if (elt == undefined) {\n      return extensionsToReturn\n    }\n    if (extensionsToIgnore == undefined) {\n      extensionsToIgnore = []\n    }\n    const extensionsForElement = getAttributeValue(elt, 'hx-ext')\n    if (extensionsForElement) {\n      forEach(extensionsForElement.split(','), function(extensionName) {\n        extensionName = extensionName.replace(/ /g, '')\n        if (extensionName.slice(0, 7) == 'ignore:') {\n          extensionsToIgnore.push(extensionName.slice(7))\n          return\n        }\n        if (extensionsToIgnore.indexOf(extensionName) < 0) {\n          const extension = extensions[extensionName]\n          if (extension && extensionsToReturn.indexOf(extension) < 0) {\n            extensionsToReturn.push(extension)\n          }\n        }\n      })\n    }\n    return getExtensions(asElement(parentElt(elt)), extensionsToReturn, extensionsToIgnore)\n  }\n\n  //= ===================================================================\n  // Initialization\n  //= ===================================================================\n  var isReady = false\n  getDocument().addEventListener('DOMContentLoaded', function() {\n    isReady = true\n  })\n\n  /**\n   * Execute a function now if DOMContentLoaded has fired, otherwise listen for it.\n   *\n   * This function uses isReady because there is no reliable way to ask the browser whether\n   * the DOMContentLoaded event has already been fired; there's a gap between DOMContentLoaded\n   * firing and readystate=complete.\n   */\n  function ready(fn) {\n    // Checking readyState here is a failsafe in case the htmx script tag entered the DOM by\n    // some means other than the initial page load.\n    if (isReady || getDocument().readyState === 'complete') {\n      fn()\n    } else {\n      getDocument().addEventListener('DOMContentLoaded', fn)\n    }\n  }\n\n  function insertIndicatorStyles() {\n    if (htmx.config.includeIndicatorStyles !== false) {\n      const nonceAttribute = htmx.config.inlineStyleNonce ? ` nonce=\"${htmx.config.inlineStyleNonce}\"` : ''\n      getDocument().head.insertAdjacentHTML('beforeend',\n        '<style' + nonceAttribute + '>\\\n      .' + htmx.config.indicatorClass + '{opacity:0}\\\n      .' + htmx.config.requestClass + ' .' + htmx.config.indicatorClass + '{opacity:1; transition: opacity 200ms ease-in;}\\\n      .' + htmx.config.requestClass + '.' + htmx.config.indicatorClass + '{opacity:1; transition: opacity 200ms ease-in;}\\\n      </style>')\n    }\n  }\n\n  function getMetaConfig() {\n    /** @type HTMLMetaElement */\n    const element = getDocument().querySelector('meta[name=\"htmx-config\"]')\n    if (element) {\n      return parseJSON(element.content)\n    } else {\n      return null\n    }\n  }\n\n  function mergeMetaConfig() {\n    const metaConfig = getMetaConfig()\n    if (metaConfig) {\n      htmx.config = mergeObjects(htmx.config, metaConfig)\n    }\n  }\n\n  // initialize the document\n  ready(function() {\n    mergeMetaConfig()\n    insertIndicatorStyles()\n    let body = getDocument().body\n    processNode(body)\n    const restoredElts = getDocument().querySelectorAll(\n      \"[hx-trigger='restored'],[data-hx-trigger='restored']\"\n    )\n    body.addEventListener('htmx:abort', function(evt) {\n      const target = evt.target\n      const internalData = getInternalData(target)\n      if (internalData && internalData.xhr) {\n        internalData.xhr.abort()\n      }\n    })\n    /** @type {(ev: PopStateEvent) => any} */\n    const originalPopstate = window.onpopstate ? window.onpopstate.bind(window) : null\n    /** @type {(ev: PopStateEvent) => any} */\n    window.onpopstate = function(event) {\n      if (event.state && event.state.htmx) {\n        restoreHistory()\n        forEach(restoredElts, function(elt) {\n          triggerEvent(elt, 'htmx:restored', {\n            document: getDocument(),\n            triggerEvent\n          })\n        })\n      } else {\n        if (originalPopstate) {\n          originalPopstate(event)\n        }\n      }\n    }\n    getWindow().setTimeout(function() {\n      triggerEvent(body, 'htmx:load', {}) // give ready handlers a chance to load up before firing this event\n      body = null // kill reference for gc\n    }, 0)\n  })\n\n  return htmx\n})()\n\n/** @typedef {'get'|'head'|'post'|'put'|'delete'|'connect'|'options'|'trace'|'patch'} HttpVerb */\n\n/**\n * @typedef {Object} SwapOptions\n * @property {string} [select]\n * @property {string} [selectOOB]\n * @property {*} [eventInfo]\n * @property {string} [anchor]\n * @property {Element} [contextElement]\n * @property {swapCallback} [afterSwapCallback]\n * @property {swapCallback} [afterSettleCallback]\n */\n\n/**\n * @callback swapCallback\n */\n\n/**\n * @typedef {'innerHTML' | 'outerHTML' | 'beforebegin' | 'afterbegin' | 'beforeend' | 'afterend' | 'delete' | 'none' | string} HtmxSwapStyle\n */\n\n/**\n * @typedef HtmxSwapSpecification\n * @property {HtmxSwapStyle} swapStyle\n * @property {number} swapDelay\n * @property {number} settleDelay\n * @property {boolean} [transition]\n * @property {boolean} [ignoreTitle]\n * @property {string} [head]\n * @property {'top' | 'bottom'} [scroll]\n * @property {string} [scrollTarget]\n * @property {string} [show]\n * @property {string} [showTarget]\n * @property {boolean} [focusScroll]\n */\n\n/**\n * @typedef {((this:Node, evt:Event) => boolean) & {source: string}} ConditionalFunction\n */\n\n/**\n * @typedef {Object} HtmxTriggerSpecification\n * @property {string} trigger\n * @property {number} [pollInterval]\n * @property {ConditionalFunction} [eventFilter]\n * @property {boolean} [changed]\n * @property {boolean} [once]\n * @property {boolean} [consume]\n * @property {number} [delay]\n * @property {string} [from]\n * @property {string} [target]\n * @property {number} [throttle]\n * @property {string} [queue]\n * @property {string} [root]\n * @property {string} [threshold]\n */\n\n/**\n * @typedef {{elt: Element, message: string, validity: ValidityState}} HtmxElementValidationError\n */\n\n/**\n * @typedef {Record<string, string>} HtmxHeaderSpecification\n * @property {'true'} HX-Request\n * @property {string|null} HX-Trigger\n * @property {string|null} HX-Trigger-Name\n * @property {string|null} HX-Target\n * @property {string} HX-Current-URL\n * @property {string} [HX-Prompt]\n * @property {'true'} [HX-Boosted]\n * @property {string} [Content-Type]\n * @property {'true'} [HX-History-Restore-Request]\n */\n\n/** @typedef HtmxAjaxHelperContext\n * @property {Element|string} [source]\n * @property {Event} [event]\n * @property {HtmxAjaxHandler} [handler]\n * @property {Element|string} [target]\n * @property {HtmxSwapStyle} [swap]\n * @property {Object|FormData} [values]\n * @property {Record<string,string>} [headers]\n * @property {string} [select]\n */\n\n/**\n * @typedef {Object} HtmxRequestConfig\n * @property {boolean} boosted\n * @property {boolean} useUrlParams\n * @property {FormData} formData\n * @property {Object} parameters formData proxy\n * @property {FormData} unfilteredFormData\n * @property {Object} unfilteredParameters unfilteredFormData proxy\n * @property {HtmxHeaderSpecification} headers\n * @property {Element} target\n * @property {HttpVerb} verb\n * @property {HtmxElementValidationError[]} errors\n * @property {boolean} withCredentials\n * @property {number} timeout\n * @property {string} path\n * @property {Event} triggeringEvent\n */\n\n/**\n * @typedef {Object} HtmxResponseInfo\n * @property {XMLHttpRequest} xhr\n * @property {Element} target\n * @property {HtmxRequestConfig} requestConfig\n * @property {HtmxAjaxEtc} etc\n * @property {boolean} boosted\n * @property {string} select\n * @property {{requestPath: string, finalRequestPath: string, responsePath: string|null, anchor: string}} pathInfo\n * @property {boolean} [failed]\n * @property {boolean} [successful]\n * @property {boolean} [keepIndicators]\n */\n\n/**\n * @typedef {Object} HtmxAjaxEtc\n * @property {boolean} [returnPromise]\n * @property {HtmxAjaxHandler} [handler]\n * @property {string} [select]\n * @property {Element} [targetOverride]\n * @property {HtmxSwapStyle} [swapOverride]\n * @property {Record<string,string>} [headers]\n * @property {Object|FormData} [values]\n * @property {boolean} [credentials]\n * @property {number} [timeout]\n */\n\n/**\n * @typedef {Object} HtmxResponseHandlingConfig\n * @property {string} [code]\n * @property {boolean} swap\n * @property {boolean} [error]\n * @property {boolean} [ignoreTitle]\n * @property {string} [select]\n * @property {string} [target]\n * @property {string} [swapOverride]\n * @property {string} [event]\n */\n\n/**\n * @typedef {HtmxResponseInfo & {shouldSwap: boolean, serverResponse: any, isError: boolean, ignoreTitle: boolean, selectOverride:string, swapOverride:string}} HtmxBeforeSwapDetails\n */\n\n/**\n * @callback HtmxAjaxHandler\n * @param {Element} elt\n * @param {HtmxResponseInfo} responseInfo\n */\n\n/**\n * @typedef {(() => void)} HtmxSettleTask\n */\n\n/**\n * @typedef {Object} HtmxSettleInfo\n * @property {HtmxSettleTask[]} tasks\n * @property {Element[]} elts\n * @property {string} [title]\n */\n\n/**\n * @see https://github.com/bigskysoftware/htmx-extensions/blob/main/README.md\n * @typedef {Object} HtmxExtension\n * @property {(api: any) => void} init\n * @property {(name: string, event: Event|CustomEvent) => boolean} onEvent\n * @property {(text: string, xhr: XMLHttpRequest, elt: Element) => string} transformResponse\n * @property {(swapStyle: HtmxSwapStyle) => boolean} isInlineSwap\n * @property {(swapStyle: HtmxSwapStyle, target: Node, fragment: Node, settleInfo: HtmxSettleInfo) => boolean|Node[]} handleSwap\n * @property {(xhr: XMLHttpRequest, parameters: FormData, elt: Node) => *|string|null} encodeParameters\n * @property {() => string[]|null} getSelectors\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (htmx);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAzNy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vU2l0ZUpTLy4vbm9kZV9tb2R1bGVzL2h0bXgub3JnL2Rpc3QvaHRteC5lc20uanM/MTJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaHRteCA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgLy8gUHVibGljIEFQSVxuICBjb25zdCBodG14ID0ge1xuICAgIC8vIFRzYyBtYWRuZXNzIGhlcmUsIGFzc2lnbmluZyB0aGUgZnVuY3Rpb25zIGRpcmVjdGx5IHJlc3VsdHMgaW4gYW4gaW52YWxpZCBUeXBlU2NyaXB0IG91dHB1dCwgYnV0IHJlYXNzaWduaW5nIGlzIGZpbmVcbiAgICAvKiBFdmVudCBwcm9jZXNzaW5nICovXG4gICAgLyoqIEB0eXBlIHt0eXBlb2Ygb25Mb2FkSGVscGVyfSAqL1xuICAgIG9uTG9hZDogbnVsbCxcbiAgICAvKiogQHR5cGUge3R5cGVvZiBwcm9jZXNzTm9kZX0gKi9cbiAgICBwcm9jZXNzOiBudWxsLFxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIGFkZEV2ZW50TGlzdGVuZXJJbXBsfSAqL1xuICAgIG9uOiBudWxsLFxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIHJlbW92ZUV2ZW50TGlzdGVuZXJJbXBsfSAqL1xuICAgIG9mZjogbnVsbCxcbiAgICAvKiogQHR5cGUge3R5cGVvZiB0cmlnZ2VyRXZlbnR9ICovXG4gICAgdHJpZ2dlcjogbnVsbCxcbiAgICAvKiogQHR5cGUge3R5cGVvZiBhamF4SGVscGVyfSAqL1xuICAgIGFqYXg6IG51bGwsXG4gICAgLyogRE9NIHF1ZXJ5aW5nIGhlbHBlcnMgKi9cbiAgICAvKiogQHR5cGUge3R5cGVvZiBmaW5kfSAqL1xuICAgIGZpbmQ6IG51bGwsXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgZmluZEFsbH0gKi9cbiAgICBmaW5kQWxsOiBudWxsLFxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIGNsb3Nlc3R9ICovXG4gICAgY2xvc2VzdDogbnVsbCxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnB1dCB2YWx1ZXMgdGhhdCB3b3VsZCByZXNvbHZlIGZvciBhIGdpdmVuIGVsZW1lbnQgdmlhIHRoZSBodG14IHZhbHVlIHJlc29sdXRpb24gbWVjaGFuaXNtXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyN2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0IHRoZSBlbGVtZW50IHRvIHJlc29sdmUgdmFsdWVzIG9uXG4gICAgICogQHBhcmFtIHtIdHRwVmVyYn0gdHlwZSB0aGUgcmVxdWVzdCB0eXBlIChlLmcuICoqZ2V0Kiogb3IgKipwb3N0KiopIG5vbi1HRVQncyB3aWxsIGluY2x1ZGUgdGhlIGVuY2xvc2luZyBmb3JtIG9mIHRoZSBlbGVtZW50LiBEZWZhdWx0cyB0byAqKnBvc3QqKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFsdWVzOiBmdW5jdGlvbihlbHQsIHR5cGUpIHtcbiAgICAgIGNvbnN0IGlucHV0VmFsdWVzID0gZ2V0SW5wdXRWYWx1ZXMoZWx0LCB0eXBlIHx8ICdwb3N0JylcbiAgICAgIHJldHVybiBpbnB1dFZhbHVlcy52YWx1ZXNcbiAgICB9LFxuICAgIC8qIERPTSBtYW5pcHVsYXRpb24gaGVscGVycyAqL1xuICAgIC8qKiBAdHlwZSB7dHlwZW9mIHJlbW92ZUVsZW1lbnR9ICovXG4gICAgcmVtb3ZlOiBudWxsLFxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIGFkZENsYXNzVG9FbGVtZW50fSAqL1xuICAgIGFkZENsYXNzOiBudWxsLFxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIHJlbW92ZUNsYXNzRnJvbUVsZW1lbnR9ICovXG4gICAgcmVtb3ZlQ2xhc3M6IG51bGwsXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgdG9nZ2xlQ2xhc3NPbkVsZW1lbnR9ICovXG4gICAgdG9nZ2xlQ2xhc3M6IG51bGwsXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgdGFrZUNsYXNzRm9yRWxlbWVudH0gKi9cbiAgICB0YWtlQ2xhc3M6IG51bGwsXG4gICAgLyoqIEB0eXBlIHt0eXBlb2Ygc3dhcH0gKi9cbiAgICBzd2FwOiBudWxsLFxuICAgIC8qIEV4dGVuc2lvbiBlbnRyeXBvaW50cyAqL1xuICAgIC8qKiBAdHlwZSB7dHlwZW9mIGRlZmluZUV4dGVuc2lvbn0gKi9cbiAgICBkZWZpbmVFeHRlbnNpb246IG51bGwsXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgcmVtb3ZlRXh0ZW5zaW9ufSAqL1xuICAgIHJlbW92ZUV4dGVuc2lvbjogbnVsbCxcbiAgICAvKiBEZWJ1Z2dpbmcgKi9cbiAgICAvKiogQHR5cGUge3R5cGVvZiBsb2dBbGx9ICovXG4gICAgbG9nQWxsOiBudWxsLFxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIGxvZ05vbmV9ICovXG4gICAgbG9nTm9uZTogbnVsbCxcbiAgICAvKiBEZWJ1Z2dpbmcgKi9cbiAgICAvKipcbiAgICAgKiBUaGUgbG9nZ2VyIGh0bXggdXNlcyB0byBsb2cgd2l0aFxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2h0bXgub3JnL2FwaS8jbG9nZ2VyXG4gICAgICovXG4gICAgbG9nZ2VyOiBudWxsLFxuICAgIC8qKlxuICAgICAqIEEgcHJvcGVydHkgaG9sZGluZyB0aGUgY29uZmlndXJhdGlvbiBodG14IHVzZXMgYXQgcnVudGltZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB1c2luZyBhIFttZXRhIHRhZ10oaHR0cHM6Ly9odG14Lm9yZy9kb2NzLyNjb25maWcpIGlzIHRoZSBwcmVmZXJyZWQgbWVjaGFuaXNtIGZvciBzZXR0aW5nIHRoZXNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNjb25maWdcbiAgICAgKi9cbiAgICBjb25maWc6IHtcbiAgICAgIC8qKlxuICAgICAgICogV2hldGhlciB0byB1c2UgaGlzdG9yeS5cbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAqL1xuICAgICAgaGlzdG9yeUVuYWJsZWQ6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBudW1iZXIgb2YgcGFnZXMgdG8ga2VlcCBpbiAqKmxvY2FsU3RvcmFnZSoqIGZvciBoaXN0b3J5IHN1cHBvcnQuXG4gICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgKi9cbiAgICAgIGhpc3RvcnlDYWNoZVNpemU6IDEwLFxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICByZWZyZXNoT25IaXN0b3J5TWlzczogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZWZhdWx0IHN3YXAgc3R5bGUgdG8gdXNlIGlmICoqW2h4LXN3YXBdKGh0dHBzOi8vaHRteC5vcmcvYXR0cmlidXRlcy9oeC1zd2FwKSoqIGlzIG9taXR0ZWQuXG4gICAgICAgKiBAdHlwZSBIdG14U3dhcFN0eWxlXG4gICAgICAgKiBAZGVmYXVsdCAnaW5uZXJIVE1MJ1xuICAgICAgICovXG4gICAgICBkZWZhdWx0U3dhcFN0eWxlOiAnaW5uZXJIVE1MJyxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgZGVsYXkgYmV0d2VlbiByZWNlaXZpbmcgYSByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGRvaW5nIHRoZSBzd2FwLlxuICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRTd2FwRGVsYXk6IDAsXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBkZWZhdWx0IGRlbGF5IGJldHdlZW4gY29tcGxldGluZyB0aGUgY29udGVudCBzd2FwIGFuZCBzZXR0bGluZyBhdHRyaWJ1dGVzLlxuICAgICAgICogQHR5cGUgbnVtYmVyXG4gICAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAgICovXG4gICAgICBkZWZhdWx0U2V0dGxlRGVsYXk6IDIwLFxuICAgICAgLyoqXG4gICAgICAgKiBJZiB0cnVlLCBodG14IHdpbGwgaW5qZWN0IGEgc21hbGwgYW1vdW50IG9mIENTUyBpbnRvIHRoZSBwYWdlIHRvIG1ha2UgaW5kaWNhdG9ycyBpbnZpc2libGUgdW5sZXNzIHRoZSAqKmh0bXgtaW5kaWNhdG9yKiogY2xhc3MgaXMgcHJlc2VudC5cbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAqL1xuICAgICAgaW5jbHVkZUluZGljYXRvclN0eWxlczogdHJ1ZSxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNsYXNzIHRvIHBsYWNlIG9uIGluZGljYXRvcnMgd2hlbiBhIHJlcXVlc3QgaXMgaW4gZmxpZ2h0LlxuICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgKiBAZGVmYXVsdCAnaHRteC1pbmRpY2F0b3InXG4gICAgICAgKi9cbiAgICAgIGluZGljYXRvckNsYXNzOiAnaHRteC1pbmRpY2F0b3InLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgY2xhc3MgdG8gcGxhY2Ugb24gdHJpZ2dlcmluZyBlbGVtZW50cyB3aGVuIGEgcmVxdWVzdCBpcyBpbiBmbGlnaHQuXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqIEBkZWZhdWx0ICdodG14LXJlcXVlc3QnXG4gICAgICAgKi9cbiAgICAgIHJlcXVlc3RDbGFzczogJ2h0bXgtcmVxdWVzdCcsXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjbGFzcyB0byB0ZW1wb3JhcmlseSBwbGFjZSBvbiBlbGVtZW50cyB0aGF0IGh0bXggaGFzIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqIEBkZWZhdWx0ICdodG14LWFkZGVkJ1xuICAgICAgICovXG4gICAgICBhZGRlZENsYXNzOiAnaHRteC1hZGRlZCcsXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBjbGFzcyB0byBwbGFjZSBvbiB0YXJnZXQgZWxlbWVudHMgd2hlbiBodG14IGlzIGluIHRoZSBzZXR0bGluZyBwaGFzZS5cbiAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICogQGRlZmF1bHQgJ2h0bXgtc2V0dGxpbmcnXG4gICAgICAgKi9cbiAgICAgIHNldHRsaW5nQ2xhc3M6ICdodG14LXNldHRsaW5nJyxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNsYXNzIHRvIHBsYWNlIG9uIHRhcmdldCBlbGVtZW50cyB3aGVuIGh0bXggaXMgaW4gdGhlIHN3YXBwaW5nIHBoYXNlLlxuICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgKiBAZGVmYXVsdCAnaHRteC1zd2FwcGluZydcbiAgICAgICAqL1xuICAgICAgc3dhcHBpbmdDbGFzczogJ2h0bXgtc3dhcHBpbmcnLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGxvd3MgdGhlIHVzZSBvZiBldmFsLWxpa2UgZnVuY3Rpb25hbGl0eSBpbiBodG14LCB0byBlbmFibGUgKipoeC12YXJzKiosIHRyaWdnZXIgY29uZGl0aW9ucyAmIHNjcmlwdCB0YWcgZXZhbHVhdGlvbi4gQ2FuIGJlIHNldCB0byAqKmZhbHNlKiogZm9yIENTUCBjb21wYXRpYmlsaXR5LlxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICovXG4gICAgICBhbGxvd0V2YWw6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIElmIHNldCB0byBmYWxzZSwgZGlzYWJsZXMgdGhlIGludGVycHJldGF0aW9uIG9mIHNjcmlwdCB0YWdzLlxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICovXG4gICAgICBhbGxvd1NjcmlwdFRhZ3M6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIElmIHNldCwgdGhlIG5vbmNlIHdpbGwgYmUgYWRkZWQgdG8gaW5saW5lIHNjcmlwdHMuXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICAgKi9cbiAgICAgIGlubGluZVNjcmlwdE5vbmNlOiAnJyxcbiAgICAgIC8qKlxuICAgICAgICogSWYgc2V0LCB0aGUgbm9uY2Ugd2lsbCBiZSBhZGRlZCB0byBpbmxpbmUgc3R5bGVzLlxuICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAgICovXG4gICAgICBpbmxpbmVTdHlsZU5vbmNlOiAnJyxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGF0dHJpYnV0ZXMgdG8gc2V0dGxlIGR1cmluZyB0aGUgc2V0dGxpbmcgcGhhc2UuXG4gICAgICAgKiBAdHlwZSBzdHJpbmdbXVxuICAgICAgICogQGRlZmF1bHQgWydjbGFzcycsICdzdHlsZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgICAgICovXG4gICAgICBhdHRyaWJ1dGVzVG9TZXR0bGU6IFsnY2xhc3MnLCAnc3R5bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gICAgICAvKipcbiAgICAgICAqIEFsbG93IGNyb3NzLXNpdGUgQWNjZXNzLUNvbnRyb2wgcmVxdWVzdHMgdXNpbmcgY3JlZGVudGlhbHMgc3VjaCBhcyBjb29raWVzLCBhdXRob3JpemF0aW9uIGhlYWRlcnMgb3IgVExTIGNsaWVudCBjZXJ0aWZpY2F0ZXMuXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAqL1xuICAgICAgdGltZW91dDogMCxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgKipnZXRXZWJTb2NrZXRSZWNvbm5lY3REZWxheSoqIGZvciByZWNvbm5lY3RpbmcgYWZ0ZXIgdW5leHBlY3RlZCBjb25uZWN0aW9uIGxvc3MgYnkgdGhlIGV2ZW50IGNvZGUgKipBYm5vcm1hbCBDbG9zdXJlKiosICoqU2VydmljZSBSZXN0YXJ0Kiogb3IgKipUcnkgQWdhaW4gTGF0ZXIqKi5cbiAgICAgICAqIEB0eXBlIHsnZnVsbC1qaXR0ZXInIHwgKChyZXRyeUNvdW50Om51bWJlcikgPT4gbnVtYmVyKX1cbiAgICAgICAqIEBkZWZhdWx0IFwiZnVsbC1qaXR0ZXJcIlxuICAgICAgICovXG4gICAgICB3c1JlY29ubmVjdERlbGF5OiAnZnVsbC1qaXR0ZXInLFxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdHlwZSBvZiBiaW5hcnkgZGF0YSBiZWluZyByZWNlaXZlZCBvdmVyIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICogQHR5cGUgQmluYXJ5VHlwZVxuICAgICAgICogQGRlZmF1bHQgJ2Jsb2InXG4gICAgICAgKi9cbiAgICAgIHdzQmluYXJ5VHlwZTogJ2Jsb2InLFxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAqIEBkZWZhdWx0ICdbaHgtZGlzYWJsZV0sIFtkYXRhLWh4LWRpc2FibGVdJ1xuICAgICAgICovXG4gICAgICBkaXNhYmxlU2VsZWN0b3I6ICdbaHgtZGlzYWJsZV0sIFtkYXRhLWh4LWRpc2FibGVdJyxcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeydhdXRvJyB8ICdpbnN0YW50JyB8ICdzbW9vdGgnfVxuICAgICAgICogQGRlZmF1bHQgJ2luc3RhbnQnXG4gICAgICAgKi9cbiAgICAgIHNjcm9sbEJlaGF2aW9yOiAnaW5zdGFudCcsXG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBmb2N1c2VkIGVsZW1lbnQgc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldy5cbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRGb2N1c1Njcm9sbDogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIElmIHNldCB0byB0cnVlIGh0bXggd2lsbCBpbmNsdWRlIGEgY2FjaGUtYnVzdGluZyBwYXJhbWV0ZXIgaW4gR0VUIHJlcXVlc3RzIHRvIGF2b2lkIGNhY2hpbmcgcGFydGlhbCByZXNwb25zZXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIGdldENhY2hlQnVzdGVyUGFyYW06IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgaHRteCB3aWxsIHVzZSB0aGUgVmlldyBUcmFuc2l0aW9uIEFQSSB3aGVuIHN3YXBwaW5nIGluIG5ldyBjb250ZW50LlxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgZ2xvYmFsVmlld1RyYW5zaXRpb25zOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogaHRteCB3aWxsIGZvcm1hdCByZXF1ZXN0cyB3aXRoIHRoZXNlIG1ldGhvZHMgYnkgZW5jb2RpbmcgdGhlaXIgcGFyYW1ldGVycyBpbiB0aGUgVVJMLCBub3QgdGhlIHJlcXVlc3QgYm9keVxuICAgICAgICogQHR5cGUgeyhIdHRwVmVyYilbXX1cbiAgICAgICAqIEBkZWZhdWx0IFsnZ2V0JywgJ2RlbGV0ZSddXG4gICAgICAgKi9cbiAgICAgIG1ldGhvZHNUaGF0VXNlVXJsUGFyYW1zOiBbJ2dldCcsICdkZWxldGUnXSxcbiAgICAgIC8qKlxuICAgICAgICogSWYgc2V0IHRvIHRydWUsIGRpc2FibGVzIGh0bXgtYmFzZWQgcmVxdWVzdHMgdG8gbm9uLW9yaWdpbiBob3N0cy5cbiAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHNlbGZSZXF1ZXN0c09ubHk6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqIElmIHNldCB0byB0cnVlIGh0bXggd2lsbCBub3QgdXBkYXRlIHRoZSB0aXRsZSBvZiB0aGUgZG9jdW1lbnQgd2hlbiBhIHRpdGxlIHRhZyBpcyBmb3VuZCBpbiBuZXcgY29udGVudFxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqL1xuICAgICAgaWdub3JlVGl0bGU6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSB0YXJnZXQgb2YgYSBib29zdGVkIGVsZW1lbnQgaXMgc2Nyb2xsZWQgaW50byB0aGUgdmlld3BvcnQuXG4gICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgKi9cbiAgICAgIHNjcm9sbEludG9WaWV3T25Cb29zdDogdHJ1ZSxcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGNhY2hlIHRvIHN0b3JlIGV2YWx1YXRlZCB0cmlnZ2VyIHNwZWNpZmljYXRpb25zIGludG8uXG4gICAgICAgKiBZb3UgbWF5IGRlZmluZSBhIHNpbXBsZSBvYmplY3QgdG8gdXNlIGEgbmV2ZXItY2xlYXJpbmcgY2FjaGUsIG9yIGltcGxlbWVudCB5b3VyIG93biBzeXN0ZW0gdXNpbmcgYSBbcHJveHkgb2JqZWN0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSlcbiAgICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAqL1xuICAgICAgdHJpZ2dlclNwZWNzQ2FjaGU6IG51bGwsXG4gICAgICAvKiogQHR5cGUgYm9vbGVhbiAqL1xuICAgICAgZGlzYWJsZUluaGVyaXRhbmNlOiBmYWxzZSxcbiAgICAgIC8qKiBAdHlwZSBIdG14UmVzcG9uc2VIYW5kbGluZ0NvbmZpZ1tdICovXG4gICAgICByZXNwb25zZUhhbmRsaW5nOiBbXG4gICAgICAgIHsgY29kZTogJzIwNCcsIHN3YXA6IGZhbHNlIH0sXG4gICAgICAgIHsgY29kZTogJ1syM10uLicsIHN3YXA6IHRydWUgfSxcbiAgICAgICAgeyBjb2RlOiAnWzQ1XS4uJywgc3dhcDogZmFsc2UsIGVycm9yOiB0cnVlIH1cbiAgICAgIF0sXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gcHJvY2VzcyBPT0Igc3dhcHMgb24gZWxlbWVudHMgdGhhdCBhcmUgbmVzdGVkIHdpdGhpbiB0aGUgbWFpbiByZXNwb25zZSBlbGVtZW50LlxuICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICovXG4gICAgICBhbGxvd05lc3RlZE9vYlN3YXBzOiB0cnVlXG4gICAgfSxcbiAgICAvKiogQHR5cGUge3R5cGVvZiBwYXJzZUludGVydmFsfSAqL1xuICAgIHBhcnNlSW50ZXJ2YWw6IG51bGwsXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgaW50ZXJuYWxFdmFsfSAqL1xuICAgIF86IG51bGwsXG4gICAgdmVyc2lvbjogJzIuMC4zJ1xuICB9XG4gIC8vIFRzYyBtYWRuZXNzIHBhcnQgMlxuICBodG14Lm9uTG9hZCA9IG9uTG9hZEhlbHBlclxuICBodG14LnByb2Nlc3MgPSBwcm9jZXNzTm9kZVxuICBodG14Lm9uID0gYWRkRXZlbnRMaXN0ZW5lckltcGxcbiAgaHRteC5vZmYgPSByZW1vdmVFdmVudExpc3RlbmVySW1wbFxuICBodG14LnRyaWdnZXIgPSB0cmlnZ2VyRXZlbnRcbiAgaHRteC5hamF4ID0gYWpheEhlbHBlclxuICBodG14LmZpbmQgPSBmaW5kXG4gIGh0bXguZmluZEFsbCA9IGZpbmRBbGxcbiAgaHRteC5jbG9zZXN0ID0gY2xvc2VzdFxuICBodG14LnJlbW92ZSA9IHJlbW92ZUVsZW1lbnRcbiAgaHRteC5hZGRDbGFzcyA9IGFkZENsYXNzVG9FbGVtZW50XG4gIGh0bXgucmVtb3ZlQ2xhc3MgPSByZW1vdmVDbGFzc0Zyb21FbGVtZW50XG4gIGh0bXgudG9nZ2xlQ2xhc3MgPSB0b2dnbGVDbGFzc09uRWxlbWVudFxuICBodG14LnRha2VDbGFzcyA9IHRha2VDbGFzc0ZvckVsZW1lbnRcbiAgaHRteC5zd2FwID0gc3dhcFxuICBodG14LmRlZmluZUV4dGVuc2lvbiA9IGRlZmluZUV4dGVuc2lvblxuICBodG14LnJlbW92ZUV4dGVuc2lvbiA9IHJlbW92ZUV4dGVuc2lvblxuICBodG14LmxvZ0FsbCA9IGxvZ0FsbFxuICBodG14LmxvZ05vbmUgPSBsb2dOb25lXG4gIGh0bXgucGFyc2VJbnRlcnZhbCA9IHBhcnNlSW50ZXJ2YWxcbiAgaHRteC5fID0gaW50ZXJuYWxFdmFsXG5cbiAgY29uc3QgaW50ZXJuYWxBUEkgPSB7XG4gICAgYWRkVHJpZ2dlckhhbmRsZXIsXG4gICAgYm9keUNvbnRhaW5zLFxuICAgIGNhbkFjY2Vzc0xvY2FsU3RvcmFnZSxcbiAgICBmaW5kVGhpc0VsZW1lbnQsXG4gICAgZmlsdGVyVmFsdWVzLFxuICAgIHN3YXAsXG4gICAgaGFzQXR0cmlidXRlLFxuICAgIGdldEF0dHJpYnV0ZVZhbHVlLFxuICAgIGdldENsb3Nlc3RBdHRyaWJ1dGVWYWx1ZSxcbiAgICBnZXRDbG9zZXN0TWF0Y2gsXG4gICAgZ2V0RXhwcmVzc2lvblZhcnMsXG4gICAgZ2V0SGVhZGVycyxcbiAgICBnZXRJbnB1dFZhbHVlcyxcbiAgICBnZXRJbnRlcm5hbERhdGEsXG4gICAgZ2V0U3dhcFNwZWNpZmljYXRpb24sXG4gICAgZ2V0VHJpZ2dlclNwZWNzLFxuICAgIGdldFRhcmdldCxcbiAgICBtYWtlRnJhZ21lbnQsXG4gICAgbWVyZ2VPYmplY3RzLFxuICAgIG1ha2VTZXR0bGVJbmZvLFxuICAgIG9vYlN3YXAsXG4gICAgcXVlcnlTZWxlY3RvckV4dCxcbiAgICBzZXR0bGVJbW1lZGlhdGVseSxcbiAgICBzaG91bGRDYW5jZWwsXG4gICAgdHJpZ2dlckV2ZW50LFxuICAgIHRyaWdnZXJFcnJvckV2ZW50LFxuICAgIHdpdGhFeHRlbnNpb25zXG4gIH1cblxuICBjb25zdCBWRVJCUyA9IFsnZ2V0JywgJ3Bvc3QnLCAncHV0JywgJ2RlbGV0ZScsICdwYXRjaCddXG4gIGNvbnN0IFZFUkJfU0VMRUNUT1IgPSBWRVJCUy5tYXAoZnVuY3Rpb24odmVyYikge1xuICAgIHJldHVybiAnW2h4LScgKyB2ZXJiICsgJ10sIFtkYXRhLWh4LScgKyB2ZXJiICsgJ10nXG4gIH0pLmpvaW4oJywgJylcblxuICAvLz0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBVdGlsaXRpZXNcbiAgLy89ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGludGVydmFsIHN0cmluZyBjb25zaXN0ZW50IHdpdGggdGhlIHdheSBodG14IGRvZXMuIFVzZWZ1bCBmb3IgcGx1Z2lucyB0aGF0IGhhdmUgdGltaW5nLXJlbGF0ZWQgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQ2F1dGlvbjogQWNjZXB0cyBhbiBpbnQgZm9sbG93ZWQgYnkgZWl0aGVyICoqcyoqIG9yICoqbXMqKi4gQWxsIG90aGVyIHZhbHVlcyB1c2UgKipwYXJzZUZsb2F0KipcbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bXgub3JnL2FwaS8jcGFyc2VJbnRlcnZhbFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRpbWluZyBzdHJpbmdcbiAgICogQHJldHVybnMge251bWJlcnx1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUludGVydmFsKHN0cikge1xuICAgIGlmIChzdHIgPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgbGV0IGludGVydmFsID0gTmFOXG4gICAgaWYgKHN0ci5zbGljZSgtMikgPT0gJ21zJykge1xuICAgICAgaW50ZXJ2YWwgPSBwYXJzZUZsb2F0KHN0ci5zbGljZSgwLCAtMikpXG4gICAgfSBlbHNlIGlmIChzdHIuc2xpY2UoLTEpID09ICdzJykge1xuICAgICAgaW50ZXJ2YWwgPSBwYXJzZUZsb2F0KHN0ci5zbGljZSgwLCAtMSkpICogMTAwMFxuICAgIH0gZWxzZSBpZiAoc3RyLnNsaWNlKC0xKSA9PSAnbScpIHtcbiAgICAgIGludGVydmFsID0gcGFyc2VGbG9hdChzdHIuc2xpY2UoMCwgLTEpKSAqIDEwMDAgKiA2MFxuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnZhbCA9IHBhcnNlRmxvYXQoc3RyKVxuICAgIH1cbiAgICByZXR1cm4gaXNOYU4oaW50ZXJ2YWwpID8gdW5kZWZpbmVkIDogaW50ZXJ2YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJucyB7KHN0cmluZyB8IG51bGwpfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmF3QXR0cmlidXRlKGVsdCwgbmFtZSkge1xuICAgIHJldHVybiBlbHQgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGVsdC5nZXRBdHRyaWJ1dGUobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVhbGlmaWVkTmFtZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIHJlc29sdmUgd2l0aCBib3RoIGh4IGFuZCBkYXRhLWh4IHByZWZpeGVzXG4gIGZ1bmN0aW9uIGhhc0F0dHJpYnV0ZShlbHQsIHF1YWxpZmllZE5hbWUpIHtcbiAgICByZXR1cm4gISFlbHQuaGFzQXR0cmlidXRlICYmIChlbHQuaGFzQXR0cmlidXRlKHF1YWxpZmllZE5hbWUpIHx8XG4gICAgICBlbHQuaGFzQXR0cmlidXRlKCdkYXRhLScgKyBxdWFsaWZpZWROYW1lKSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcXVhbGlmaWVkTmFtZVxuICAgKiBAcmV0dXJucyB7KHN0cmluZyB8IG51bGwpfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoZWx0LCBxdWFsaWZpZWROYW1lKSB7XG4gICAgcmV0dXJuIGdldFJhd0F0dHJpYnV0ZShlbHQsIHF1YWxpZmllZE5hbWUpIHx8IGdldFJhd0F0dHJpYnV0ZShlbHQsICdkYXRhLScgKyBxdWFsaWZpZWROYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWx0XG4gICAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcmVudEVsdChlbHQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbHQucGFyZW50RWxlbWVudFxuICAgIGlmICghcGFyZW50ICYmIGVsdC5wYXJlbnROb2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkgcmV0dXJuIGVsdC5wYXJlbnROb2RlXG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtEb2N1bWVudH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHJldHVybiBkb2N1bWVudFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWx0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2xvYmFsXG4gICAqIEByZXR1cm5zIHtOb2RlfERvY3VtZW50fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Um9vdE5vZGUoZWx0LCBnbG9iYWwpIHtcbiAgICByZXR1cm4gZWx0LmdldFJvb3ROb2RlID8gZWx0LmdldFJvb3ROb2RlKHsgY29tcG9zZWQ6IGdsb2JhbCB9KSA6IGdldERvY3VtZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsdFxuICAgKiBAcGFyYW0geyhlOk5vZGUpID0+IGJvb2xlYW59IGNvbmRpdGlvblxuICAgKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRDbG9zZXN0TWF0Y2goZWx0LCBjb25kaXRpb24pIHtcbiAgICB3aGlsZSAoZWx0ICYmICFjb25kaXRpb24oZWx0KSkge1xuICAgICAgZWx0ID0gcGFyZW50RWx0KGVsdClcbiAgICB9XG5cbiAgICByZXR1cm4gZWx0IHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGluaXRpYWxFbGVtZW50XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gYW5jZXN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZU5hbWVcbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWVXaXRoRGlzaW5oZXJpdGFuY2UoaW5pdGlhbEVsZW1lbnQsIGFuY2VzdG9yLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZShhbmNlc3RvciwgYXR0cmlidXRlTmFtZSlcbiAgICBjb25zdCBkaXNpbmhlcml0ID0gZ2V0QXR0cmlidXRlVmFsdWUoYW5jZXN0b3IsICdoeC1kaXNpbmhlcml0JylcbiAgICB2YXIgaW5oZXJpdCA9IGdldEF0dHJpYnV0ZVZhbHVlKGFuY2VzdG9yLCAnaHgtaW5oZXJpdCcpXG4gICAgaWYgKGluaXRpYWxFbGVtZW50ICE9PSBhbmNlc3Rvcikge1xuICAgICAgaWYgKGh0bXguY29uZmlnLmRpc2FibGVJbmhlcml0YW5jZSkge1xuICAgICAgICBpZiAoaW5oZXJpdCAmJiAoaW5oZXJpdCA9PT0gJyonIHx8IGluaGVyaXQuc3BsaXQoJyAnKS5pbmRleE9mKGF0dHJpYnV0ZU5hbWUpID49IDApKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpc2luaGVyaXQgJiYgKGRpc2luaGVyaXQgPT09ICcqJyB8fCBkaXNpbmhlcml0LnNwbGl0KCcgJykuaW5kZXhPZihhdHRyaWJ1dGVOYW1lKSA+PSAwKSkge1xuICAgICAgICByZXR1cm4gJ3Vuc2V0J1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlVmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldENsb3Nlc3RBdHRyaWJ1dGVWYWx1ZShlbHQsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBsZXQgY2xvc2VzdEF0dHIgPSBudWxsXG4gICAgZ2V0Q2xvc2VzdE1hdGNoKGVsdCwgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuICEhKGNsb3Nlc3RBdHRyID0gZ2V0QXR0cmlidXRlVmFsdWVXaXRoRGlzaW5oZXJpdGFuY2UoZWx0LCBhc0VsZW1lbnQoZSksIGF0dHJpYnV0ZU5hbWUpKVxuICAgIH0pXG4gICAgaWYgKGNsb3Nlc3RBdHRyICE9PSAndW5zZXQnKSB7XG4gICAgICByZXR1cm4gY2xvc2VzdEF0dHJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBlbHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gbWF0Y2hlcyhlbHQsIHNlbGVjdG9yKSB7XG4gICAgLy8gQHRzLWlnbm9yZTogbm9uLXN0YW5kYXJkIHByb3BlcnRpZXMgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VucmVzb2x2ZWRWYXJpYWJsZVxuICAgIGNvbnN0IG1hdGNoZXNGdW5jdGlvbiA9IGVsdCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgKGVsdC5tYXRjaGVzIHx8IGVsdC5tYXRjaGVzU2VsZWN0b3IgfHwgZWx0Lm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsdC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWx0LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbHQub01hdGNoZXNTZWxlY3RvcilcbiAgICByZXR1cm4gISFtYXRjaGVzRnVuY3Rpb24gJiYgbWF0Y2hlc0Z1bmN0aW9uLmNhbGwoZWx0LCBzZWxlY3RvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRTdGFydFRhZyhzdHIpIHtcbiAgICBjb25zdCB0YWdNYXRjaGVyID0gLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pXG4gICAgY29uc3QgbWF0Y2ggPSB0YWdNYXRjaGVyLmV4ZWMoc3RyKVxuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoWzFdLnRvTG93ZXJDYXNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNwXG4gICAqIEByZXR1cm5zIHtEb2N1bWVudH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlSFRNTChyZXNwKSB7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpXG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcocmVzcCwgJ3RleHQvaHRtbCcpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnbWVudFxuICAgKiBAcGFyYW0ge05vZGV9IGVsdFxuICAgKi9cbiAgZnVuY3Rpb24gdGFrZUNoaWxkcmVuRm9yKGZyYWdtZW50LCBlbHQpIHtcbiAgICB3aGlsZSAoZWx0LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kKGVsdC5jaGlsZE5vZGVzWzBdKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxTY3JpcHRFbGVtZW50fSBzY3JpcHRcbiAgICogQHJldHVybnMge0hUTUxTY3JpcHRFbGVtZW50fVxuICAgKi9cbiAgZnVuY3Rpb24gZHVwbGljYXRlU2NyaXB0KHNjcmlwdCkge1xuICAgIGNvbnN0IG5ld1NjcmlwdCA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICBmb3JFYWNoKHNjcmlwdC5hdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBuZXdTY3JpcHQuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSlcbiAgICB9KVxuICAgIG5ld1NjcmlwdC50ZXh0Q29udGVudCA9IHNjcmlwdC50ZXh0Q29udGVudFxuICAgIG5ld1NjcmlwdC5hc3luYyA9IGZhbHNlXG4gICAgaWYgKGh0bXguY29uZmlnLmlubGluZVNjcmlwdE5vbmNlKSB7XG4gICAgICBuZXdTY3JpcHQubm9uY2UgPSBodG14LmNvbmZpZy5pbmxpbmVTY3JpcHROb25jZVxuICAgIH1cbiAgICByZXR1cm4gbmV3U2NyaXB0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MU2NyaXB0RWxlbWVudH0gc2NyaXB0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNKYXZhU2NyaXB0U2NyaXB0Tm9kZShzY3JpcHQpIHtcbiAgICByZXR1cm4gc2NyaXB0Lm1hdGNoZXMoJ3NjcmlwdCcpICYmIChzY3JpcHQudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcgfHwgc2NyaXB0LnR5cGUgPT09ICdtb2R1bGUnIHx8IHNjcmlwdC50eXBlID09PSAnJylcbiAgfVxuXG4gIC8qKlxuICAgKiB3ZSBoYXZlIHRvIG1ha2UgbmV3IGNvcGllcyBvZiBzY3JpcHQgdGFncyB0aGF0IHdlIGFyZSBnb2luZyB0byBpbnNlcnQgYmVjYXVzZVxuICAgKiBTT01FIGJyb3dzZXJzIChub3Qgc2F5aW5nIHdobywgYnV0IGl0IGludm9sdmVzIGFuIGVsZW1lbnQgYW5kIGFuIGFuaW1hbCkgZG9uJ3RcbiAgICogZXhlY3V0ZSBzY3JpcHRzIGNyZWF0ZWQgaW4gPHRlbXBsYXRlPiB0YWdzIHdoZW4gdGhleSBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NXG4gICAqIGFuZCBhbGwgdGhlIG90aGVycyBkbyBsbWFvXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnRcbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNjcmlwdFRhZ3MoZnJhZ21lbnQpIHtcbiAgICBBcnJheS5mcm9tKGZyYWdtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpKS5mb3JFYWNoKC8qKiBAcGFyYW0ge0hUTUxTY3JpcHRFbGVtZW50fSBzY3JpcHQgKi8gKHNjcmlwdCkgPT4ge1xuICAgICAgaWYgKGlzSmF2YVNjcmlwdFNjcmlwdE5vZGUoc2NyaXB0KSkge1xuICAgICAgICBjb25zdCBuZXdTY3JpcHQgPSBkdXBsaWNhdGVTY3JpcHQoc2NyaXB0KVxuICAgICAgICBjb25zdCBwYXJlbnQgPSBzY3JpcHQucGFyZW50Tm9kZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3U2NyaXB0LCBzY3JpcHQpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2dFcnJvcihlKVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7RG9jdW1lbnRGcmFnbWVudCAmIHt0aXRsZT86IHN0cmluZ319IERvY3VtZW50RnJhZ21lbnRXaXRoVGl0bGVcbiAgICogQGRlc2NyaXB0aW9uICBhIGRvY3VtZW50IGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgcmVzcG9uc2UgSFRNTCwgaW5jbHVkaW5nXG4gICAqIGEgYHRpdGxlYCBwcm9wZXJ0eSBmb3IgYW55IHRpdGxlIGluZm9ybWF0aW9uIGZvdW5kXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2UgSFRNTFxuICAgKiBAcmV0dXJucyB7RG9jdW1lbnRGcmFnbWVudFdpdGhUaXRsZX1cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VGcmFnbWVudChyZXNwb25zZSkge1xuICAgIC8vIHN0cmlwIGhlYWQgdGFnIHRvIGRldGVybWluZSBzaGFwZSBvZiByZXNwb25zZSB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgY29uc3QgcmVzcG9uc2VXaXRoTm9IZWFkID0gcmVzcG9uc2UucmVwbGFjZSgvPGhlYWQoXFxzW14+XSopPz5bXFxzXFxTXSo/PFxcL2hlYWQ+L2ksICcnKVxuICAgIGNvbnN0IHN0YXJ0VGFnID0gZ2V0U3RhcnRUYWcocmVzcG9uc2VXaXRoTm9IZWFkKVxuICAgIC8qKiBAdHlwZSBEb2N1bWVudEZyYWdtZW50V2l0aFRpdGxlICovXG4gICAgbGV0IGZyYWdtZW50XG4gICAgaWYgKHN0YXJ0VGFnID09PSAnaHRtbCcpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGEgZnVsbCBkb2N1bWVudCwgcGFyc2UgaXQgYW5kIHJldHVybiB0aGUgYm9keVxuICAgICAgZnJhZ21lbnQgPSAvKiogQHR5cGUgRG9jdW1lbnRGcmFnbWVudFdpdGhUaXRsZSAqLyAobmV3IERvY3VtZW50RnJhZ21lbnQoKSlcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlSFRNTChyZXNwb25zZSlcbiAgICAgIHRha2VDaGlsZHJlbkZvcihmcmFnbWVudCwgZG9jLmJvZHkpXG4gICAgICBmcmFnbWVudC50aXRsZSA9IGRvYy50aXRsZVxuICAgIH0gZWxzZSBpZiAoc3RhcnRUYWcgPT09ICdib2R5Jykge1xuICAgICAgLy8gcGFyc2UgYm9keSB3L28gd3JhcHBpbmcgaW4gdGVtcGxhdGVcbiAgICAgIGZyYWdtZW50ID0gLyoqIEB0eXBlIERvY3VtZW50RnJhZ21lbnRXaXRoVGl0bGUgKi8gKG5ldyBEb2N1bWVudEZyYWdtZW50KCkpXG4gICAgICBjb25zdCBkb2MgPSBwYXJzZUhUTUwocmVzcG9uc2VXaXRoTm9IZWFkKVxuICAgICAgdGFrZUNoaWxkcmVuRm9yKGZyYWdtZW50LCBkb2MuYm9keSlcbiAgICAgIGZyYWdtZW50LnRpdGxlID0gZG9jLnRpdGxlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIG5vbi1ib2R5IHBhcnRpYWwgSFRNTCBjb250ZW50LCBzbyB3cmFwIGl0IGluIGEgdGVtcGxhdGUgdG8gbWF4aW1pemUgcGFyc2luZyBmbGV4aWJpbGl0eVxuICAgICAgY29uc3QgZG9jID0gcGFyc2VIVE1MKCc8Ym9keT48dGVtcGxhdGUgY2xhc3M9XCJpbnRlcm5hbC1odG14LXdyYXBwZXJcIj4nICsgcmVzcG9uc2VXaXRoTm9IZWFkICsgJzwvdGVtcGxhdGU+PC9ib2R5PicpXG4gICAgICBmcmFnbWVudCA9IC8qKiBAdHlwZSBEb2N1bWVudEZyYWdtZW50V2l0aFRpdGxlICovIChkb2MucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKS5jb250ZW50KVxuICAgICAgLy8gZXh0cmFjdCB0aXRsZSBpbnRvIGZyYWdtZW50IGZvciBsYXRlciBwcm9jZXNzaW5nXG4gICAgICBmcmFnbWVudC50aXRsZSA9IGRvYy50aXRsZVxuXG4gICAgICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMgd2Ugc3VwcG9ydCBhIHRpdGxlIHRhZyBhdCB0aGUgcm9vdCBsZXZlbCBvZiBub24tYm9keSByZXNwb25zZXMsIHNvIHdlIG5lZWQgdG8gaGFuZGxlIGl0XG4gICAgICB2YXIgdGl0bGVFbGVtZW50ID0gZnJhZ21lbnQucXVlcnlTZWxlY3RvcigndGl0bGUnKVxuICAgICAgaWYgKHRpdGxlRWxlbWVudCAmJiB0aXRsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gZnJhZ21lbnQpIHtcbiAgICAgICAgdGl0bGVFbGVtZW50LnJlbW92ZSgpXG4gICAgICAgIGZyYWdtZW50LnRpdGxlID0gdGl0bGVFbGVtZW50LmlubmVyVGV4dFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIGlmIChodG14LmNvbmZpZy5hbGxvd1NjcmlwdFRhZ3MpIHtcbiAgICAgICAgbm9ybWFsaXplU2NyaXB0VGFncyhmcmFnbWVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgc2NyaXB0IHRhZ3MgaWYgc2NyaXB0cyBhcmUgZGlzYWJsZWRcbiAgICAgICAgZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0JykuZm9yRWFjaCgoc2NyaXB0KSA9PiBzY3JpcHQucmVtb3ZlKCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICovXG4gIGZ1bmN0aW9uIG1heWJlQ2FsbChmdW5jKSB7XG4gICAgaWYgKGZ1bmMpIHtcbiAgICAgIGZ1bmMoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZnVuY3Rpb24gaXNUeXBlKG8sIHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCAnICsgdHlwZSArICddJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb1xuICAgKiBAcmV0dXJucyB7byBpcyBGdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24obykge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb1xuICAgKiBAcmV0dXJucyB7byBpcyBPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBpc1Jhd09iamVjdChvKSB7XG4gICAgcmV0dXJuIGlzVHlwZShvLCAnT2JqZWN0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPbkhhbmRsZXJcbiAgICogQHByb3BlcnR5IHsoa2V5b2YgSFRNTEVsZW1lbnRFdmVudE1hcCl8c3RyaW5nfSBldmVudFxuICAgKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJ9IGxpc3RlbmVyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBMaXN0ZW5lckluZm9cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRyaWdnZXJcbiAgICogQHByb3BlcnR5IHtFdmVudExpc3RlbmVyfSBsaXN0ZW5lclxuICAgKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0fSBvblxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gSHRteE5vZGVJbnRlcm5hbERhdGFcbiAgICogRWxlbWVudCBkYXRhXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW5pdEhhc2hdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Jvb3N0ZWRdXG4gICAqIEBwcm9wZXJ0eSB7T25IYW5kbGVyW119IFtvbkhhbmRsZXJzXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3RpbWVvdXRdXG4gICAqIEBwcm9wZXJ0eSB7TGlzdGVuZXJJbmZvW119IFtsaXN0ZW5lckluZm9zXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjYW5jZWxsZWRdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3RyaWdnZXJlZE9uY2VdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsYXllZF1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3Rocm90dGxlXVxuICAgKiBAcHJvcGVydHkge1dlYWtNYXA8SHRteFRyaWdnZXJTcGVjaWZpY2F0aW9uLFdlYWtNYXA8RXZlbnRUYXJnZXQsc3RyaW5nPj59IFtsYXN0VmFsdWVdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvYWRlZF1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYXRoXVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZlcmJdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvbGxpbmddXG4gICAqIEBwcm9wZXJ0eSB7SFRNTEJ1dHRvbkVsZW1lbnR8SFRNTElucHV0RWxlbWVudHxudWxsfSBbbGFzdEJ1dHRvbkNsaWNrZWRdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVxdWVzdENvdW50XVxuICAgKiBAcHJvcGVydHkge1hNTEh0dHBSZXF1ZXN0fSBbeGhyXVxuICAgKiBAcHJvcGVydHkgeygoKSA9PiB2b2lkKVtdfSBbcXVldWVkUmVxdWVzdHNdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Fib3J0YWJsZV1cbiAgICpcbiAgICogRXZlbnQgZGF0YVxuICAgKiBAcHJvcGVydHkge0h0bXhUcmlnZ2VyU3BlY2lmaWNhdGlvbn0gW3RyaWdnZXJTcGVjXVxuICAgKiBAcHJvcGVydHkge0V2ZW50VGFyZ2V0W119IFtoYW5kbGVkRm9yXVxuICAgKi9cblxuICAvKipcbiAgICogZ2V0SW50ZXJuYWxEYXRhIHJldHJpZXZlcyBcInByaXZhdGVcIiBkYXRhIHN0b3JlZCBieSBodG14IHdpdGhpbiBhbiBlbGVtZW50XG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RXZlbnR9IGVsdFxuICAgKiBAcmV0dXJucyB7SHRteE5vZGVJbnRlcm5hbERhdGF9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJbnRlcm5hbERhdGEoZWx0KSB7XG4gICAgY29uc3QgZGF0YVByb3AgPSAnaHRteC1pbnRlcm5hbC1kYXRhJ1xuICAgIGxldCBkYXRhID0gZWx0W2RhdGFQcm9wXVxuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IGVsdFtkYXRhUHJvcF0gPSB7fVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIHRvQXJyYXkgY29udmVydHMgYW4gQXJyYXlMaWtlIG9iamVjdCBpbnRvIGEgcmVhbCBhcnJheS5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtBcnJheUxpa2U8VD59IGFyclxuICAgKiBAcmV0dXJucyB7VFtdfVxuICAgKi9cbiAgZnVuY3Rpb24gdG9BcnJheShhcnIpIHtcbiAgICBjb25zdCByZXR1cm5BcnIgPSBbXVxuICAgIGlmIChhcnIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJldHVybkFyci5wdXNoKGFycltpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkFyclxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7VFtdfE5hbWVkTm9kZU1hcHxIVE1MQ29sbGVjdGlvbnxIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbnxBcnJheUxpa2U8VD59IGFyclxuICAgKiBAcGFyYW0geyhUKSA9PiB2b2lkfSBmdW5jXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoKGFyciwgZnVuYykge1xuICAgIGlmIChhcnIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZ1bmMoYXJyW2ldKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTY3JvbGxlZEludG9WaWV3KGVsKSB7XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgZWxlbVRvcCA9IHJlY3QudG9wXG4gICAgY29uc3QgZWxlbUJvdHRvbSA9IHJlY3QuYm90dG9tXG4gICAgcmV0dXJuIGVsZW1Ub3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZWxlbUJvdHRvbSA+PSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBlbHRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBib2R5Q29udGFpbnMoZWx0KSB7XG4gICAgLy8gSUUgRml4XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBlbHQuZ2V0Um9vdE5vZGUgJiYgZWx0LmdldFJvb3ROb2RlKClcbiAgICBpZiAocm9vdE5vZGUgJiYgcm9vdE5vZGUgaW5zdGFuY2VvZiB3aW5kb3cuU2hhZG93Um9vdCkge1xuICAgICAgcmV0dXJuIGdldERvY3VtZW50KCkuYm9keS5jb250YWlucyhyb290Tm9kZS5ob3N0KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0RG9jdW1lbnQoKS5ib2R5LmNvbnRhaW5zKGVsdClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyaWdnZXJcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgZnVuY3Rpb24gc3BsaXRPbldoaXRlc3BhY2UodHJpZ2dlcikge1xuICAgIHJldHVybiB0cmlnZ2VyLnRyaW0oKS5zcGxpdCgvXFxzKy8pXG4gIH1cblxuICAvKipcbiAgICogbWVyZ2VPYmplY3RzIHRha2VzIGFsbCB0aGUga2V5cyBmcm9tXG4gICAqIG9iajIgYW5kIGR1cGxpY2F0ZXMgdGhlbSBpbnRvIG9iajFcbiAgICogQHRlbXBsYXRlIFQxXG4gICAqIEB0ZW1wbGF0ZSBUMlxuICAgKiBAcGFyYW0ge1QxfSBvYmoxXG4gICAqIEBwYXJhbSB7VDJ9IG9iajJcbiAgICogQHJldHVybnMge1QxICYgVDJ9XG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZU9iamVjdHMob2JqMSwgb2JqMikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iajIpIHtcbiAgICAgIGlmIChvYmoyLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0c2MgZG9lc24ndCBzZWVtIHRvIHByb3Blcmx5IGhhbmRsZSB0eXBlcyBtZXJnaW5nXG4gICAgICAgIG9iajFba2V5XSA9IG9iajJba2V5XVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlIHRzYyBkb2Vzbid0IHNlZW0gdG8gcHJvcGVybHkgaGFuZGxlIHR5cGVzIG1lcmdpbmdcbiAgICByZXR1cm4gb2JqMVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBqU3RyaW5nXG4gICAqIEByZXR1cm5zIHthbnl8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlSlNPTihqU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGpTdHJpbmcpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ0Vycm9yKGVycm9yKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBjYW5BY2Nlc3NMb2NhbFN0b3JhZ2UoKSB7XG4gICAgY29uc3QgdGVzdCA9ICdodG14OmxvY2FsU3RvcmFnZVRlc3QnXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgocGF0aCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGgpXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIHBhdGggPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoXG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2gsIHVubGVzcyBpbmRleCBwYWdlXG4gICAgICBpZiAoISgvXlxcLyQvLnRlc3QocGF0aCkpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyskLywgJycpXG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGJlIGtpbmQgdG8gSUUxMSwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IFVSTCgpXG4gICAgICByZXR1cm4gcGF0aFxuICAgIH1cbiAgfVxuXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBwdWJsaWMgQVBJXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBmdW5jdGlvbiBpbnRlcm5hbEV2YWwoc3RyKSB7XG4gICAgcmV0dXJuIG1heWJlRXZhbChnZXREb2N1bWVudCgpLmJvZHksIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV2YWwoc3RyKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNhbGxiYWNrIGZvciB0aGUgKipodG14OmxvYWQqKiBldmVudC4gVGhpcyBjYW4gYmUgdXNlZCB0byBwcm9jZXNzIG5ldyBjb250ZW50LCBmb3IgZXhhbXBsZSBpbml0aWFsaXppbmcgdGhlIGNvbnRlbnQgd2l0aCBhIGphdmFzY3JpcHQgbGlicmFyeVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNvbkxvYWRcbiAgICpcbiAgICogQHBhcmFtIHsoZWx0OiBOb2RlKSA9PiB2b2lkfSBjYWxsYmFjayB0aGUgY2FsbGJhY2sgdG8gY2FsbCBvbiBuZXdseSBsb2FkZWQgY29udGVudFxuICAgKiBAcmV0dXJucyB7RXZlbnRMaXN0ZW5lcn1cbiAgICovXG4gIGZ1bmN0aW9uIG9uTG9hZEhlbHBlcihjYWxsYmFjaykge1xuICAgIGNvbnN0IHZhbHVlID0gaHRteC5vbignaHRteDpsb2FkJywgLyoqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGV2dCAqLyBmdW5jdGlvbihldnQpIHtcbiAgICAgIGNhbGxiYWNrKGV2dC5kZXRhaWwuZWx0KVxuICAgIH0pXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogTG9nIGFsbCBodG14IGV2ZW50cywgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG14Lm9yZy9hcGkvI2xvZ0FsbFxuICAgKi9cbiAgZnVuY3Rpb24gbG9nQWxsKCkge1xuICAgIGh0bXgubG9nZ2VyID0gZnVuY3Rpb24oZWx0LCBldmVudCwgZGF0YSkge1xuICAgICAgaWYgKGNvbnNvbGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQsIGVsdCwgZGF0YSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsb2dOb25lKCkge1xuICAgIGh0bXgubG9nZ2VyID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIGVsZW1lbnQgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG14Lm9yZy9hcGkvI2ZpbmRcbiAgICpcbiAgICogQHBhcmFtIHtQYXJlbnROb2RlfHN0cmluZ30gZWx0T3JTZWxlY3RvciAgdGhlIHJvb3QgZWxlbWVudCB0byBmaW5kIHRoZSBtYXRjaGluZyBlbGVtZW50IGluLCBpbmNsdXNpdmUgfCB0aGUgc2VsZWN0b3IgdG8gbWF0Y2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzZWxlY3Rvcl0gdGhlIHNlbGVjdG9yIHRvIG1hdGNoXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBmaW5kKGVsdE9yU2VsZWN0b3IsIHNlbGVjdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBlbHRPclNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsdE9yU2VsZWN0b3IucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpbmQoZ2V0RG9jdW1lbnQoKSwgZWx0T3JTZWxlY3RvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIGVsZW1lbnRzIG1hdGNoaW5nIHRoZSBzZWxlY3RvclxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNmaW5kQWxsXG4gICAqXG4gICAqIEBwYXJhbSB7UGFyZW50Tm9kZXxzdHJpbmd9IGVsdE9yU2VsZWN0b3IgdGhlIHJvb3QgZWxlbWVudCB0byBmaW5kIHRoZSBtYXRjaGluZyBlbGVtZW50cyBpbiwgaW5jbHVzaXZlIHwgdGhlIHNlbGVjdG9yIHRvIG1hdGNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VsZWN0b3JdIHRoZSBzZWxlY3RvciB0byBtYXRjaFxuICAgKiBAcmV0dXJucyB7Tm9kZUxpc3RPZjxFbGVtZW50Pn1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRBbGwoZWx0T3JTZWxlY3Rvciwgc2VsZWN0b3IpIHtcbiAgICBpZiAodHlwZW9mIGVsdE9yU2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWx0T3JTZWxlY3Rvci5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluZEFsbChnZXREb2N1bWVudCgpLCBlbHRPclNlbGVjdG9yKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBXaW5kb3dcbiAgICovXG4gIGZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICByZXR1cm4gd2luZG93XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIERPTVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNyZW1vdmVcbiAgICpcbiAgICogQHBhcmFtIHtOb2RlfSBlbHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV1cbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWx0LCBkZWxheSkge1xuICAgIGVsdCA9IHJlc29sdmVUYXJnZXQoZWx0KVxuICAgIGlmIChkZWxheSkge1xuICAgICAgZ2V0V2luZG93KCkuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtb3ZlRWxlbWVudChlbHQpXG4gICAgICAgIGVsdCA9IG51bGxcbiAgICAgIH0sIGRlbGF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRFbHQoZWx0KS5yZW1vdmVDaGlsZChlbHQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBlbHRcbiAgICogQHJldHVybiB7RWxlbWVudHxudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gYXNFbGVtZW50KGVsdCkge1xuICAgIHJldHVybiBlbHQgaW5zdGFuY2VvZiBFbGVtZW50ID8gZWx0IDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBlbHRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGFzSHRtbEVsZW1lbnQoZWx0KSB7XG4gICAgcmV0dXJuIGVsdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gZWx0IDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGFzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbHRcbiAgICogQHJldHVybiB7UGFyZW50Tm9kZXxudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gYXNQYXJlbnROb2RlKGVsdCkge1xuICAgIHJldHVybiBlbHQgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGVsdCBpbnN0YW5jZW9mIERvY3VtZW50IHx8IGVsdCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgPyBlbHQgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgYWRkcyBhIGNsYXNzIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNhZGRDbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbHQgdGhlIGVsZW1lbnQgdG8gYWRkIHRoZSBjbGFzcyB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhenogdGhlIGNsYXNzIHRvIGFkZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5XSB0aGUgZGVsYXkgKGluIG1pbGxpc2Vjb25kcykgYmVmb3JlIGNsYXNzIGlzIGFkZGVkXG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzc1RvRWxlbWVudChlbHQsIGNsYXp6LCBkZWxheSkge1xuICAgIGVsdCA9IGFzRWxlbWVudChyZXNvbHZlVGFyZ2V0KGVsdCkpXG4gICAgaWYgKCFlbHQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGdldFdpbmRvdygpLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGFkZENsYXNzVG9FbGVtZW50KGVsdCwgY2xhenopXG4gICAgICAgIGVsdCA9IG51bGxcbiAgICAgIH0sIGRlbGF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBlbHQuY2xhc3NMaXN0ICYmIGVsdC5jbGFzc0xpc3QuYWRkKGNsYXp6KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNyZW1vdmVDbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge05vZGV8c3RyaW5nfSBub2RlIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGF6eiB0aGUgY2xhc3MgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXldIHRoZSBkZWxheSAoaW4gbWlsbGlzZWNvbmRzIGJlZm9yZSBjbGFzcyBpcyByZW1vdmVkKVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NGcm9tRWxlbWVudChub2RlLCBjbGF6eiwgZGVsYXkpIHtcbiAgICBsZXQgZWx0ID0gYXNFbGVtZW50KHJlc29sdmVUYXJnZXQobm9kZSkpXG4gICAgaWYgKCFlbHQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGdldFdpbmRvdygpLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzRnJvbUVsZW1lbnQoZWx0LCBjbGF6eilcbiAgICAgICAgZWx0ID0gbnVsbFxuICAgICAgfSwgZGVsYXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbHQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsdC5jbGFzc0xpc3QucmVtb3ZlKGNsYXp6KVxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gY2xhc3NlcyBsZWZ0LCByZW1vdmUgdGhlIGNsYXNzIGF0dHJpYnV0ZVxuICAgICAgICBpZiAoZWx0LmNsYXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlbHQucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZ2l2ZW4gY2xhc3Mgb24gYW4gZWxlbWVudFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyN0b2dnbGVDbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbHQgdGhlIGVsZW1lbnQgdG8gdG9nZ2xlIHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhenogdGhlIGNsYXNzIHRvIHRvZ2dsZVxuICAgKi9cbiAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3NPbkVsZW1lbnQoZWx0LCBjbGF6eikge1xuICAgIGVsdCA9IHJlc29sdmVUYXJnZXQoZWx0KVxuICAgIGVsdC5jbGFzc0xpc3QudG9nZ2xlKGNsYXp6KVxuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIHRoZSBnaXZlbiBjbGFzcyBmcm9tIGl0cyBzaWJsaW5ncywgc28gdGhhdCBhbW9uZyBpdHMgc2libGluZ3MsIG9ubHkgdGhlIGdpdmVuIGVsZW1lbnQgd2lsbCBoYXZlIHRoZSBjbGFzcy5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bXgub3JnL2FwaS8jdGFrZUNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZXxzdHJpbmd9IGVsdCB0aGUgZWxlbWVudCB0aGF0IHdpbGwgdGFrZSB0aGUgY2xhc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXp6IHRoZSBjbGFzcyB0byB0YWtlXG4gICAqL1xuICBmdW5jdGlvbiB0YWtlQ2xhc3NGb3JFbGVtZW50KGVsdCwgY2xhenopIHtcbiAgICBlbHQgPSByZXNvbHZlVGFyZ2V0KGVsdClcbiAgICBmb3JFYWNoKGVsdC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmVtb3ZlQ2xhc3NGcm9tRWxlbWVudChjaGlsZCwgY2xhenopXG4gICAgfSlcbiAgICBhZGRDbGFzc1RvRWxlbWVudChhc0VsZW1lbnQoZWx0KSwgY2xhenopXG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGNsb3Nlc3QgbWF0Y2hpbmcgZWxlbWVudCBpbiB0aGUgZ2l2ZW4gZWxlbWVudHMgcGFyZW50YWdlLCBpbmNsdXNpdmUgb2YgdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bXgub3JnL2FwaS8jY2xvc2VzdFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbHQgdGhlIGVsZW1lbnQgdG8gZmluZCB0aGUgc2VsZWN0b3IgZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgdGhlIHNlbGVjdG9yIHRvIGZpbmRcbiAgICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGNsb3Nlc3QoZWx0LCBzZWxlY3Rvcikge1xuICAgIGVsdCA9IGFzRWxlbWVudChyZXNvbHZlVGFyZ2V0KGVsdCkpXG4gICAgaWYgKGVsdCAmJiBlbHQuY2xvc2VzdCkge1xuICAgICAgcmV0dXJuIGVsdC5jbG9zZXN0KHNlbGVjdG9yKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPIHJlbW92ZSB3aGVuIElFIGdvZXMgYXdheVxuICAgICAgZG8ge1xuICAgICAgICBpZiAoZWx0ID09IG51bGwgfHwgbWF0Y2hlcyhlbHQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBlbHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGVsdCA9IGVsdCAmJiBhc0VsZW1lbnQocGFyZW50RWx0KGVsdCkpKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHByZWZpeCkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWZmaXhcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHN1ZmZpeCkge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IHRyaW1tZWRTZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKVxuICAgIGlmIChzdGFydHNXaXRoKHRyaW1tZWRTZWxlY3RvciwgJzwnKSAmJiBlbmRzV2l0aCh0cmltbWVkU2VsZWN0b3IsICcvPicpKSB7XG4gICAgICByZXR1cm4gdHJpbW1lZFNlbGVjdG9yLnN1YnN0cmluZygxLCB0cmltbWVkU2VsZWN0b3IubGVuZ3RoIC0gMilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyaW1tZWRTZWxlY3RvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV8RWxlbWVudHxEb2N1bWVudHxzdHJpbmd9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZ2xvYmFsXG4gICAqIEByZXR1cm5zIHsoTm9kZXxXaW5kb3cpW119XG4gICAqL1xuICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsRXh0KGVsdCwgc2VsZWN0b3IsIGdsb2JhbCkge1xuICAgIGVsdCA9IHJlc29sdmVUYXJnZXQoZWx0KVxuICAgIGlmIChzZWxlY3Rvci5pbmRleE9mKCdjbG9zZXN0ICcpID09PSAwKSB7XG4gICAgICByZXR1cm4gW2Nsb3Nlc3QoYXNFbGVtZW50KGVsdCksIG5vcm1hbGl6ZVNlbGVjdG9yKHNlbGVjdG9yLnN1YnN0cig4KSkpXVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuaW5kZXhPZignZmluZCAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtmaW5kKGFzUGFyZW50Tm9kZShlbHQpLCBub3JtYWxpemVTZWxlY3RvcihzZWxlY3Rvci5zdWJzdHIoNSkpKV1cbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSAnbmV4dCcpIHtcbiAgICAgIHJldHVybiBbYXNFbGVtZW50KGVsdCkubmV4dEVsZW1lbnRTaWJsaW5nXVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuaW5kZXhPZignbmV4dCAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtzY2FuRm9yd2FyZFF1ZXJ5KGVsdCwgbm9ybWFsaXplU2VsZWN0b3Ioc2VsZWN0b3Iuc3Vic3RyKDUpKSwgISFnbG9iYWwpXVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT09ICdwcmV2aW91cycpIHtcbiAgICAgIHJldHVybiBbYXNFbGVtZW50KGVsdCkucHJldmlvdXNFbGVtZW50U2libGluZ11cbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmluZGV4T2YoJ3ByZXZpb3VzICcpID09PSAwKSB7XG4gICAgICByZXR1cm4gW3NjYW5CYWNrd2FyZHNRdWVyeShlbHQsIG5vcm1hbGl6ZVNlbGVjdG9yKHNlbGVjdG9yLnN1YnN0cig5KSksICEhZ2xvYmFsKV1cbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICByZXR1cm4gW2RvY3VtZW50XVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT09ICd3aW5kb3cnKSB7XG4gICAgICByZXR1cm4gW3dpbmRvd11cbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSAnYm9keScpIHtcbiAgICAgIHJldHVybiBbZG9jdW1lbnQuYm9keV1cbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yID09PSAncm9vdCcpIHtcbiAgICAgIHJldHVybiBbZ2V0Um9vdE5vZGUoZWx0LCAhIWdsb2JhbCldXG4gICAgfSBlbHNlIGlmIChzZWxlY3RvciA9PT0gJ2hvc3QnKSB7XG4gICAgICByZXR1cm4gWygvKiogQHR5cGUgU2hhZG93Um9vdCAqLyhlbHQuZ2V0Um9vdE5vZGUoKSkpLmhvc3RdXG4gICAgfSBlbHNlIGlmIChzZWxlY3Rvci5pbmRleE9mKCdnbG9iYWwgJykgPT09IDApIHtcbiAgICAgIHJldHVybiBxdWVyeVNlbGVjdG9yQWxsRXh0KGVsdCwgc2VsZWN0b3Iuc2xpY2UoNyksIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b0FycmF5KGFzUGFyZW50Tm9kZShnZXRSb290Tm9kZShlbHQsICEhZ2xvYmFsKSkucXVlcnlTZWxlY3RvckFsbChub3JtYWxpemVTZWxlY3RvcihzZWxlY3RvcikpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHN0YXJ0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdsb2JhbFxuICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICovXG4gIHZhciBzY2FuRm9yd2FyZFF1ZXJ5ID0gZnVuY3Rpb24oc3RhcnQsIG1hdGNoLCBnbG9iYWwpIHtcbiAgICBjb25zdCByZXN1bHRzID0gYXNQYXJlbnROb2RlKGdldFJvb3ROb2RlKHN0YXJ0LCBnbG9iYWwpKS5xdWVyeVNlbGVjdG9yQWxsKG1hdGNoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWx0ID0gcmVzdWx0c1tpXVxuICAgICAgaWYgKGVsdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihzdGFydCkgPT09IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKSB7XG4gICAgICAgIHJldHVybiBlbHRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBzdGFydFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hcbiAgICogQHBhcmFtIHtib29sZWFufSBnbG9iYWxcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICB2YXIgc2NhbkJhY2t3YXJkc1F1ZXJ5ID0gZnVuY3Rpb24oc3RhcnQsIG1hdGNoLCBnbG9iYWwpIHtcbiAgICBjb25zdCByZXN1bHRzID0gYXNQYXJlbnROb2RlKGdldFJvb3ROb2RlKHN0YXJ0LCBnbG9iYWwpKS5xdWVyeVNlbGVjdG9yQWxsKG1hdGNoKVxuICAgIGZvciAobGV0IGkgPSByZXN1bHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlbHQgPSByZXN1bHRzW2ldXG4gICAgICBpZiAoZWx0LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHN0YXJ0KSA9PT0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcpIHtcbiAgICAgICAgcmV0dXJuIGVsdFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV8c3RyaW5nfSBlbHRPclNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge05vZGV8V2luZG93fVxuICAgKi9cbiAgZnVuY3Rpb24gcXVlcnlTZWxlY3RvckV4dChlbHRPclNlbGVjdG9yLCBzZWxlY3Rvcikge1xuICAgIGlmICh0eXBlb2YgZWx0T3JTZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBxdWVyeVNlbGVjdG9yQWxsRXh0KGVsdE9yU2VsZWN0b3IsIHNlbGVjdG9yKVswXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcXVlcnlTZWxlY3RvckFsbEV4dChnZXREb2N1bWVudCgpLmJvZHksIGVsdE9yU2VsZWN0b3IpWzBdXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7RXZlbnRUYXJnZXR9IFRcbiAgICogQHBhcmFtIHtUfHN0cmluZ30gZWx0T3JTZWxlY3RvclxuICAgKiBAcGFyYW0ge1R9IFtjb250ZXh0XVxuICAgKiBAcmV0dXJucyB7RWxlbWVudHxUfG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiByZXNvbHZlVGFyZ2V0KGVsdE9yU2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIGVsdE9yU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmluZChhc1BhcmVudE5vZGUoY29udGV4dCkgfHwgZG9jdW1lbnQsIGVsdE9yU2VsZWN0b3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbHRPclNlbGVjdG9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtrZXlvZiBIVE1MRWxlbWVudEV2ZW50TWFwfHN0cmluZ30gQW55RXZlbnROYW1lXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudEFyZ3NcbiAgICogQHByb3BlcnR5IHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwcm9wZXJ0eSB7QW55RXZlbnROYW1lfSBldmVudFxuICAgKiBAcHJvcGVydHkge0V2ZW50TGlzdGVuZXJ9IGxpc3RlbmVyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fGJvb2xlYW59IG9wdGlvbnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8QW55RXZlbnROYW1lfSBhcmcxXG4gICAqIEBwYXJhbSB7QW55RXZlbnROYW1lfEV2ZW50TGlzdGVuZXJ9IGFyZzJcbiAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyfE9iamVjdHxib29sZWFufSBbYXJnM11cbiAgICogQHBhcmFtIHtPYmplY3R8Ym9vbGVhbn0gW2FyZzRdXG4gICAqIEByZXR1cm5zIHtFdmVudEFyZ3N9XG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzRXZlbnRBcmdzKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiBnZXREb2N1bWVudCgpLmJvZHksXG4gICAgICAgIGV2ZW50OiBhc1N0cmluZyhhcmcxKSxcbiAgICAgICAgbGlzdGVuZXI6IGFyZzIsXG4gICAgICAgIG9wdGlvbnM6IGFyZzNcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiByZXNvbHZlVGFyZ2V0KGFyZzEpLFxuICAgICAgICBldmVudDogYXNTdHJpbmcoYXJnMiksXG4gICAgICAgIGxpc3RlbmVyOiBhcmczLFxuICAgICAgICBvcHRpb25zOiBhcmc0XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNvblxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fHN0cmluZ30gYXJnMSB0aGUgZWxlbWVudCB0byBhZGQgdGhlIGxpc3RlbmVyIHRvIHwgdGhlIGV2ZW50IG5hbWUgdG8gYWRkIHRoZSBsaXN0ZW5lciBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd8RXZlbnRMaXN0ZW5lcn0gYXJnMiB0aGUgZXZlbnQgbmFtZSB0byBhZGQgdGhlIGxpc3RlbmVyIGZvciB8IHRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyfE9iamVjdHxib29sZWFufSBbYXJnM10gdGhlIGxpc3RlbmVyIHRvIGFkZCB8IG9wdGlvbnMgdG8gYWRkXG4gICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFthcmc0XSBvcHRpb25zIHRvIGFkZFxuICAgKiBAcmV0dXJucyB7RXZlbnRMaXN0ZW5lcn1cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJJbXBsKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICByZWFkeShmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGV2ZW50QXJncyA9IHByb2Nlc3NFdmVudEFyZ3MoYXJnMSwgYXJnMiwgYXJnMywgYXJnNClcbiAgICAgIGV2ZW50QXJncy50YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudEFyZ3MuZXZlbnQsIGV2ZW50QXJncy5saXN0ZW5lciwgZXZlbnRBcmdzLm9wdGlvbnMpXG4gICAgfSlcbiAgICBjb25zdCBiID0gaXNGdW5jdGlvbihhcmcyKVxuICAgIHJldHVybiBiID8gYXJnMiA6IGFyZzNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYW4gZWxlbWVudFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNvZmZcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldHxzdHJpbmd9IGFyZzEgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHwgdGhlIGV2ZW50IG5hbWUgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tXG4gICAqIEBwYXJhbSB7c3RyaW5nfEV2ZW50TGlzdGVuZXJ9IGFyZzIgdGhlIGV2ZW50IG5hbWUgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHwgdGhlIGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IFthcmczXSB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEByZXR1cm5zIHtFdmVudExpc3RlbmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lckltcGwoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIHJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZXZlbnRBcmdzID0gcHJvY2Vzc0V2ZW50QXJncyhhcmcxLCBhcmcyLCBhcmczKVxuICAgICAgZXZlbnRBcmdzLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50QXJncy5ldmVudCwgZXZlbnRBcmdzLmxpc3RlbmVyKVxuICAgIH0pXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oYXJnMikgPyBhcmcyIDogYXJnM1xuICB9XG5cbiAgLy89ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gTm9kZSBwcm9jZXNzaW5nXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgY29uc3QgRFVNTVlfRUxUID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50KCdvdXRwdXQnKSAvLyBkdW1teSBlbGVtZW50IGZvciBiYWQgc2VsZWN0b3JzXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWVcbiAgICogQHJldHVybnMgeyhOb2RlfFdpbmRvdylbXX1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRBdHRyaWJ1dGVUYXJnZXRzKGVsdCwgYXR0ck5hbWUpIHtcbiAgICBjb25zdCBhdHRyVGFyZ2V0ID0gZ2V0Q2xvc2VzdEF0dHJpYnV0ZVZhbHVlKGVsdCwgYXR0ck5hbWUpXG4gICAgaWYgKGF0dHJUYXJnZXQpIHtcbiAgICAgIGlmIChhdHRyVGFyZ2V0ID09PSAndGhpcycpIHtcbiAgICAgICAgcmV0dXJuIFtmaW5kVGhpc0VsZW1lbnQoZWx0LCBhdHRyTmFtZSldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBxdWVyeVNlbGVjdG9yQWxsRXh0KGVsdCwgYXR0clRhcmdldClcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsb2dFcnJvcignVGhlIHNlbGVjdG9yIFwiJyArIGF0dHJUYXJnZXQgKyAnXCIgb24gJyArIGF0dHJOYW1lICsgJyByZXR1cm5lZCBubyBtYXRjaGVzIScpXG4gICAgICAgICAgcmV0dXJuIFtEVU1NWV9FTFRdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRUaGlzRWxlbWVudChlbHQsIGF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBhc0VsZW1lbnQoZ2V0Q2xvc2VzdE1hdGNoKGVsdCwgZnVuY3Rpb24oZWx0KSB7XG4gICAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoYXNFbGVtZW50KGVsdCksIGF0dHJpYnV0ZSkgIT0gbnVsbFxuICAgIH0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEByZXR1cm5zIHtOb2RlfFdpbmRvd3xudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VGFyZ2V0KGVsdCkge1xuICAgIGNvbnN0IHRhcmdldFN0ciA9IGdldENsb3Nlc3RBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC10YXJnZXQnKVxuICAgIGlmICh0YXJnZXRTdHIpIHtcbiAgICAgIGlmICh0YXJnZXRTdHIgPT09ICd0aGlzJykge1xuICAgICAgICByZXR1cm4gZmluZFRoaXNFbGVtZW50KGVsdCwgJ2h4LXRhcmdldCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcXVlcnlTZWxlY3RvckV4dChlbHQsIHRhcmdldFN0cilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGF0YSA9IGdldEludGVybmFsRGF0YShlbHQpXG4gICAgICBpZiAoZGF0YS5ib29zdGVkKSB7XG4gICAgICAgIHJldHVybiBnZXREb2N1bWVudCgpLmJvZHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbHRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBzaG91bGRTZXR0bGVBdHRyaWJ1dGUobmFtZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXNUb1NldHRsZSA9IGh0bXguY29uZmlnLmF0dHJpYnV0ZXNUb1NldHRsZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlc1RvU2V0dGxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobmFtZSA9PT0gYXR0cmlidXRlc1RvU2V0dGxlW2ldKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbWVyZ2VUb1xuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG1lcmdlRnJvbVxuICAgKi9cbiAgZnVuY3Rpb24gY2xvbmVBdHRyaWJ1dGVzKG1lcmdlVG8sIG1lcmdlRnJvbSkge1xuICAgIGZvckVhY2gobWVyZ2VUby5hdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoIW1lcmdlRnJvbS5oYXNBdHRyaWJ1dGUoYXR0ci5uYW1lKSAmJiBzaG91bGRTZXR0bGVBdHRyaWJ1dGUoYXR0ci5uYW1lKSkge1xuICAgICAgICBtZXJnZVRvLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpXG4gICAgICB9XG4gICAgfSlcbiAgICBmb3JFYWNoKG1lcmdlRnJvbS5hdHRyaWJ1dGVzLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoc2hvdWxkU2V0dGxlQXR0cmlidXRlKGF0dHIubmFtZSkpIHtcbiAgICAgICAgbWVyZ2VUby5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIdG14U3dhcFN0eWxlfSBzd2FwU3R5bGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0lubGluZVN3YXAoc3dhcFN0eWxlLCB0YXJnZXQpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9ucyh0YXJnZXQpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHRlbnNpb24gPSBleHRlbnNpb25zW2ldXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uLmlzSW5saW5lU3dhcChzd2FwU3R5bGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dFcnJvcihlKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3dhcFN0eWxlID09PSAnb3V0ZXJIVE1MJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvb2JWYWx1ZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9vYkVsZW1lbnRcbiAgICogQHBhcmFtIHtIdG14U2V0dGxlSW5mb30gc2V0dGxlSW5mb1xuICAgKiBAcGFyYW0ge05vZGV8RG9jdW1lbnR9IFtyb290Tm9kZV1cbiAgICogQHJldHVybnNcbiAgICovXG4gIGZ1bmN0aW9uIG9vYlN3YXAob29iVmFsdWUsIG9vYkVsZW1lbnQsIHNldHRsZUluZm8sIHJvb3ROb2RlKSB7XG4gICAgcm9vdE5vZGUgPSByb290Tm9kZSB8fCBnZXREb2N1bWVudCgpXG4gICAgbGV0IHNlbGVjdG9yID0gJyMnICsgZ2V0UmF3QXR0cmlidXRlKG9vYkVsZW1lbnQsICdpZCcpXG4gICAgLyoqIEB0eXBlIEh0bXhTd2FwU3R5bGUgKi9cbiAgICBsZXQgc3dhcFN0eWxlID0gJ291dGVySFRNTCdcbiAgICBpZiAob29iVmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH0gZWxzZSBpZiAob29iVmFsdWUuaW5kZXhPZignOicpID4gMCkge1xuICAgICAgc3dhcFN0eWxlID0gb29iVmFsdWUuc3Vic3RyKDAsIG9vYlZhbHVlLmluZGV4T2YoJzonKSlcbiAgICAgIHNlbGVjdG9yID0gb29iVmFsdWUuc3Vic3RyKG9vYlZhbHVlLmluZGV4T2YoJzonKSArIDEsIG9vYlZhbHVlLmxlbmd0aClcbiAgICB9IGVsc2Uge1xuICAgICAgc3dhcFN0eWxlID0gb29iVmFsdWVcbiAgICB9XG4gICAgb29iRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2h4LXN3YXAtb29iJylcbiAgICBvb2JFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1oeC1zd2FwLW9vYicpXG5cbiAgICBjb25zdCB0YXJnZXRzID0gcXVlcnlTZWxlY3RvckFsbEV4dChyb290Tm9kZSwgc2VsZWN0b3IsIGZhbHNlKVxuICAgIGlmICh0YXJnZXRzKSB7XG4gICAgICBmb3JFYWNoKFxuICAgICAgICB0YXJnZXRzLFxuICAgICAgICBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICBsZXQgZnJhZ21lbnRcbiAgICAgICAgICBjb25zdCBvb2JFbGVtZW50Q2xvbmUgPSBvb2JFbGVtZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgIGZyYWdtZW50ID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChvb2JFbGVtZW50Q2xvbmUpXG4gICAgICAgICAgaWYgKCFpc0lubGluZVN3YXAoc3dhcFN0eWxlLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGFzUGFyZW50Tm9kZShvb2JFbGVtZW50Q2xvbmUpIC8vIGlmIHRoaXMgaXMgbm90IGFuIGlubGluZSBzd2FwLCB3ZSB1c2UgdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUsIG5vdCB0aGUgbm9kZSBpdHNlbGZcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBiZWZvcmVTd2FwRGV0YWlscyA9IHsgc2hvdWxkU3dhcDogdHJ1ZSwgdGFyZ2V0LCBmcmFnbWVudCB9XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyRXZlbnQodGFyZ2V0LCAnaHRteDpvb2JCZWZvcmVTd2FwJywgYmVmb3JlU3dhcERldGFpbHMpKSByZXR1cm5cblxuICAgICAgICAgIHRhcmdldCA9IGJlZm9yZVN3YXBEZXRhaWxzLnRhcmdldCAvLyBhbGxvdyByZS10YXJnZXRpbmdcbiAgICAgICAgICBpZiAoYmVmb3JlU3dhcERldGFpbHMuc2hvdWxkU3dhcCkge1xuICAgICAgICAgICAgaGFuZGxlUHJlc2VydmVkRWxlbWVudHMoZnJhZ21lbnQpXG4gICAgICAgICAgICBzd2FwV2l0aFN0eWxlKHN3YXBTdHlsZSwgdGFyZ2V0LCB0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICAgICAgICAgICAgcmVzdG9yZVByZXNlcnZlZEVsZW1lbnRzKClcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yRWFjaChzZXR0bGVJbmZvLmVsdHMsIGZ1bmN0aW9uKGVsdCkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6b29iQWZ0ZXJTd2FwJywgYmVmb3JlU3dhcERldGFpbHMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgb29iRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG9vYkVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9vYkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvb2JFbGVtZW50KVxuICAgICAgdHJpZ2dlckVycm9yRXZlbnQoZ2V0RG9jdW1lbnQoKS5ib2R5LCAnaHRteDpvb2JFcnJvck5vVGFyZ2V0JywgeyBjb250ZW50OiBvb2JFbGVtZW50IH0pXG4gICAgfVxuICAgIHJldHVybiBvb2JWYWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVByZXNlcnZlZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHBhbnRyeSA9IGZpbmQoJyMtLWh0bXgtcHJlc2VydmUtcGFudHJ5LS0nKVxuICAgIGlmIChwYW50cnkpIHtcbiAgICAgIGZvciAoY29uc3QgcHJlc2VydmVkRWx0IG9mIFsuLi5wYW50cnkuY2hpbGRyZW5dKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRWxlbWVudCA9IGZpbmQoJyMnICsgcHJlc2VydmVkRWx0LmlkKVxuICAgICAgICAvLyBAdHMtaWdub3JlIC0gdXNlIHByb3Bvc2VkIG1vdmVCZWZvcmUgZmVhdHVyZVxuICAgICAgICBleGlzdGluZ0VsZW1lbnQucGFyZW50Tm9kZS5tb3ZlQmVmb3JlKHByZXNlcnZlZEVsdCwgZXhpc3RpbmdFbGVtZW50KVxuICAgICAgICBleGlzdGluZ0VsZW1lbnQucmVtb3ZlKClcbiAgICAgIH1cbiAgICAgIHBhbnRyeS5yZW1vdmUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR8UGFyZW50Tm9kZX0gZnJhZ21lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVByZXNlcnZlZEVsZW1lbnRzKGZyYWdtZW50KSB7XG4gICAgZm9yRWFjaChmaW5kQWxsKGZyYWdtZW50LCAnW2h4LXByZXNlcnZlXSwgW2RhdGEtaHgtcHJlc2VydmVdJyksIGZ1bmN0aW9uKHByZXNlcnZlZEVsdCkge1xuICAgICAgY29uc3QgaWQgPSBnZXRBdHRyaWJ1dGVWYWx1ZShwcmVzZXJ2ZWRFbHQsICdpZCcpXG4gICAgICBjb25zdCBleGlzdGluZ0VsZW1lbnQgPSBnZXREb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGlkKVxuICAgICAgaWYgKGV4aXN0aW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZWRFbHQubW92ZUJlZm9yZSkgeyAvLyBpZiB0aGUgbW92ZUJlZm9yZSBBUEkgZXhpc3RzLCB1c2UgaXRcbiAgICAgICAgICAvLyBnZXQgb3IgY3JlYXRlIGEgc3RvcmFnZSBzcG90IGZvciBzdHVmZlxuICAgICAgICAgIGxldCBwYW50cnkgPSBmaW5kKCcjLS1odG14LXByZXNlcnZlLXBhbnRyeS0tJylcbiAgICAgICAgICBpZiAocGFudHJ5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGdldERvY3VtZW50KCkuYm9keS5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyZW5kJywgXCI8ZGl2IGlkPSctLWh0bXgtcHJlc2VydmUtcGFudHJ5LS0nPjwvZGl2PlwiKVxuICAgICAgICAgICAgcGFudHJ5ID0gZmluZCgnIy0taHRteC1wcmVzZXJ2ZS1wYW50cnktLScpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSB1c2UgcHJvcG9zZWQgbW92ZUJlZm9yZSBmZWF0dXJlXG4gICAgICAgICAgcGFudHJ5Lm1vdmVCZWZvcmUoZXhpc3RpbmdFbGVtZW50LCBudWxsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXNlcnZlZEVsdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChleGlzdGluZ0VsZW1lbnQsIHByZXNlcnZlZEVsdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBwYXJlbnROb2RlXG4gICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gZnJhZ21lbnRcbiAgICogQHBhcmFtIHtIdG14U2V0dGxlSW5mb30gc2V0dGxlSW5mb1xuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlcyhwYXJlbnROb2RlLCBmcmFnbWVudCwgc2V0dGxlSW5mbykge1xuICAgIGZvckVhY2goZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkXScpLCBmdW5jdGlvbihuZXdOb2RlKSB7XG4gICAgICBjb25zdCBpZCA9IGdldFJhd0F0dHJpYnV0ZShuZXdOb2RlLCAnaWQnKVxuICAgICAgaWYgKGlkICYmIGlkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkID0gaWQucmVwbGFjZShcIidcIiwgXCJcXFxcJ1wiKVxuICAgICAgICBjb25zdCBub3JtYWxpemVkVGFnID0gbmV3Tm9kZS50YWdOYW1lLnJlcGxhY2UoJzonLCAnXFxcXDonKVxuICAgICAgICBjb25zdCBwYXJlbnRFbHQgPSBhc1BhcmVudE5vZGUocGFyZW50Tm9kZSlcbiAgICAgICAgY29uc3Qgb2xkTm9kZSA9IHBhcmVudEVsdCAmJiBwYXJlbnRFbHQucXVlcnlTZWxlY3Rvcihub3JtYWxpemVkVGFnICsgXCJbaWQ9J1wiICsgbm9ybWFsaXplZElkICsgXCInXVwiKVxuICAgICAgICBpZiAob2xkTm9kZSAmJiBvbGROb2RlICE9PSBwYXJlbnRFbHQpIHtcbiAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gbmV3Tm9kZS5jbG9uZU5vZGUoKVxuICAgICAgICAgIGNsb25lQXR0cmlidXRlcyhuZXdOb2RlLCBvbGROb2RlKVxuICAgICAgICAgIHNldHRsZUluZm8udGFza3MucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsb25lQXR0cmlidXRlcyhuZXdOb2RlLCBuZXdBdHRyaWJ1dGVzKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gY2hpbGRcbiAgICogQHJldHVybnMge0h0bXhTZXR0bGVUYXNrfVxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUFqYXhMb2FkVGFzayhjaGlsZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJlbW92ZUNsYXNzRnJvbUVsZW1lbnQoY2hpbGQsIGh0bXguY29uZmlnLmFkZGVkQ2xhc3MpXG4gICAgICBwcm9jZXNzTm9kZShhc0VsZW1lbnQoY2hpbGQpKVxuICAgICAgcHJvY2Vzc0ZvY3VzKGFzUGFyZW50Tm9kZShjaGlsZCkpXG4gICAgICB0cmlnZ2VyRXZlbnQoY2hpbGQsICdodG14OmxvYWQnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1BhcmVudE5vZGV9IGNoaWxkXG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzRm9jdXMoY2hpbGQpIHtcbiAgICBjb25zdCBhdXRvZm9jdXMgPSAnW2F1dG9mb2N1c10nXG4gICAgY29uc3QgYXV0b0ZvY3VzZWRFbHQgPSBhc0h0bWxFbGVtZW50KG1hdGNoZXMoY2hpbGQsIGF1dG9mb2N1cykgPyBjaGlsZCA6IGNoaWxkLnF1ZXJ5U2VsZWN0b3IoYXV0b2ZvY3VzKSlcbiAgICBpZiAoYXV0b0ZvY3VzZWRFbHQgIT0gbnVsbCkge1xuICAgICAgYXV0b0ZvY3VzZWRFbHQuZm9jdXMoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHBhcmVudE5vZGVcbiAgICogQHBhcmFtIHtOb2RlfSBpbnNlcnRCZWZvcmVcbiAgICogQHBhcmFtIHtQYXJlbnROb2RlfSBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0h0bXhTZXR0bGVJbmZvfSBzZXR0bGVJbmZvXG4gICAqL1xuICBmdW5jdGlvbiBpbnNlcnROb2Rlc0JlZm9yZShwYXJlbnROb2RlLCBpbnNlcnRCZWZvcmUsIGZyYWdtZW50LCBzZXR0bGVJbmZvKSB7XG4gICAgaGFuZGxlQXR0cmlidXRlcyhwYXJlbnROb2RlLCBmcmFnbWVudCwgc2V0dGxlSW5mbylcbiAgICB3aGlsZSAoZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGZyYWdtZW50LmZpcnN0Q2hpbGRcbiAgICAgIGFkZENsYXNzVG9FbGVtZW50KGFzRWxlbWVudChjaGlsZCksIGh0bXguY29uZmlnLmFkZGVkQ2xhc3MpXG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgaW5zZXJ0QmVmb3JlKVxuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlICE9PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZC5ub2RlVHlwZSAhPT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgc2V0dGxlSW5mby50YXNrcy5wdXNoKG1ha2VBamF4TG9hZFRhc2soY2hpbGQpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBiYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9oeWFtYW1vdG8vZmQ0MzU1MDVkMjllYmZhM2Q5NzE2ZmQyYmU4ZDQyZjAsXG4gICAqIGRlcml2ZWQgZnJvbSBKYXZhJ3Mgc3RyaW5nIGhhc2hjb2RlIGltcGxlbWVudGF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhc2hcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ0hhc2goc3RyaW5nLCBoYXNoKSB7XG4gICAgbGV0IGNoYXIgPSAwXG4gICAgd2hpbGUgKGNoYXIgPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgc3RyaW5nLmNoYXJDb2RlQXQoY2hhcisrKSB8IDAgLy8gYml0d2lzZSBvciBlbnN1cmVzIHdlIGhhdmUgYSAzMi1iaXQgaW50XG4gICAgfVxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZUhhc2goZWx0KSB7XG4gICAgbGV0IGhhc2ggPSAwXG4gICAgLy8gSUUgZml4XG4gICAgaWYgKGVsdC5hdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsdC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGVsdC5hdHRyaWJ1dGVzW2ldXG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUpIHsgLy8gb25seSBpbmNsdWRlIGF0dHJpYnV0ZXMgdy8gYWN0dWFsIHZhbHVlcyAoZW1wdHkgaXMgc2FtZSBhcyBub24tZXhpc3RlbnQpXG4gICAgICAgICAgaGFzaCA9IHN0cmluZ0hhc2goYXR0cmlidXRlLm5hbWUsIGhhc2gpXG4gICAgICAgICAgaGFzaCA9IHN0cmluZ0hhc2goYXR0cmlidXRlLnZhbHVlLCBoYXNoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWx0XG4gICAqL1xuICBmdW5jdGlvbiBkZUluaXRPbkhhbmRsZXJzKGVsdCkge1xuICAgIGNvbnN0IGludGVybmFsRGF0YSA9IGdldEludGVybmFsRGF0YShlbHQpXG4gICAgaWYgKGludGVybmFsRGF0YS5vbkhhbmRsZXJzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVybmFsRGF0YS5vbkhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJJbmZvID0gaW50ZXJuYWxEYXRhLm9uSGFuZGxlcnNbaV1cbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckltcGwoZWx0LCBoYW5kbGVySW5mby5ldmVudCwgaGFuZGxlckluZm8ubGlzdGVuZXIpXG4gICAgICB9XG4gICAgICBkZWxldGUgaW50ZXJuYWxEYXRhLm9uSGFuZGxlcnNcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBkZUluaXROb2RlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBpbnRlcm5hbERhdGEgPSBnZXRJbnRlcm5hbERhdGEoZWxlbWVudClcbiAgICBpZiAoaW50ZXJuYWxEYXRhLnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlcm5hbERhdGEudGltZW91dClcbiAgICB9XG4gICAgaWYgKGludGVybmFsRGF0YS5saXN0ZW5lckluZm9zKSB7XG4gICAgICBmb3JFYWNoKGludGVybmFsRGF0YS5saXN0ZW5lckluZm9zLCBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgIGlmIChpbmZvLm9uKSB7XG4gICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lckltcGwoaW5mby5vbiwgaW5mby50cmlnZ2VyLCBpbmZvLmxpc3RlbmVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBkZUluaXRPbkhhbmRsZXJzKGVsZW1lbnQpXG4gICAgZm9yRWFjaChPYmplY3Qua2V5cyhpbnRlcm5hbERhdGEpLCBmdW5jdGlvbihrZXkpIHsgZGVsZXRlIGludGVybmFsRGF0YVtrZXldIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBjbGVhblVwRWxlbWVudChlbGVtZW50KSB7XG4gICAgdHJpZ2dlckV2ZW50KGVsZW1lbnQsICdodG14OmJlZm9yZUNsZWFudXBFbGVtZW50JylcbiAgICBkZUluaXROb2RlKGVsZW1lbnQpXG4gICAgLy8gQHRzLWlnbm9yZSBJRTExIGNvZGVcbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnJlc29sdmVkUmVmZXJlbmNlXG4gICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4pIHsgLy8gSUVcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGZvckVhY2goZWxlbWVudC5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHsgY2xlYW5VcEVsZW1lbnQoY2hpbGQpIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gZnJhZ21lbnRcbiAgICogQHBhcmFtIHtIdG14U2V0dGxlSW5mb30gc2V0dGxlSW5mb1xuICAgKi9cbiAgZnVuY3Rpb24gc3dhcE91dGVySFRNTCh0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgdGFyZ2V0LnRhZ05hbWUgPT09ICdCT0RZJykgeyAvLyBzcGVjaWFsIGNhc2UgdGhlIGJvZHkgdG8gaW5uZXJIVE1MIGJlY2F1c2UgRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgY29udGFpbiBhIGJvZHkgZWx0IHVuZm9ydHVuYXRlbHlcbiAgICAgIHJldHVybiBzd2FwSW5uZXJIVE1MKHRhcmdldCwgZnJhZ21lbnQsIHNldHRsZUluZm8pXG4gICAgfVxuICAgIC8qKiBAdHlwZSB7Tm9kZX0gKi9cbiAgICBsZXQgbmV3RWx0XG4gICAgY29uc3QgZWx0QmVmb3JlTmV3Q29udGVudCA9IHRhcmdldC5wcmV2aW91c1NpYmxpbmdcbiAgICBjb25zdCBwYXJlbnROb2RlID0gcGFyZW50RWx0KHRhcmdldClcbiAgICBpZiAoIXBhcmVudE5vZGUpIHsgLy8gd2hlbiBwYXJlbnQgbm9kZSBkaXNhcHBlYXJzLCB3ZSBjYW4ndCBkbyBhbnl0aGluZ1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGluc2VydE5vZGVzQmVmb3JlKHBhcmVudE5vZGUsIHRhcmdldCwgZnJhZ21lbnQsIHNldHRsZUluZm8pXG4gICAgaWYgKGVsdEJlZm9yZU5ld0NvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgbmV3RWx0ID0gcGFyZW50Tm9kZS5maXJzdENoaWxkXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VsdCA9IGVsdEJlZm9yZU5ld0NvbnRlbnQubmV4dFNpYmxpbmdcbiAgICB9XG4gICAgc2V0dGxlSW5mby5lbHRzID0gc2V0dGxlSW5mby5lbHRzLmZpbHRlcihmdW5jdGlvbihlKSB7IHJldHVybiBlICE9PSB0YXJnZXQgfSlcbiAgICAvLyBzY2FuIHRocm91Z2ggYWxsIG5ld2x5IGFkZGVkIGNvbnRlbnQgYW5kIGFkZCBhbGwgZWxlbWVudHMgdG8gdGhlIHNldHRsZSBpbmZvIHNvIHdlIHRyaWdnZXJcbiAgICAvLyBldmVudHMgcHJvcGVybHkgb24gdGhlbVxuICAgIHdoaWxlIChuZXdFbHQgJiYgbmV3RWx0ICE9PSB0YXJnZXQpIHtcbiAgICAgIGlmIChuZXdFbHQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHNldHRsZUluZm8uZWx0cy5wdXNoKG5ld0VsdClcbiAgICAgIH1cbiAgICAgIG5ld0VsdCA9IG5ld0VsdC5uZXh0U2libGluZ1xuICAgIH1cbiAgICBjbGVhblVwRWxlbWVudCh0YXJnZXQpXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldC5yZW1vdmUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gZnJhZ21lbnRcbiAgICogQHBhcmFtIHtIdG14U2V0dGxlSW5mb30gc2V0dGxlSW5mb1xuICAgKi9cbiAgZnVuY3Rpb24gc3dhcEFmdGVyQmVnaW4odGFyZ2V0LCBmcmFnbWVudCwgc2V0dGxlSW5mbykge1xuICAgIHJldHVybiBpbnNlcnROb2Rlc0JlZm9yZSh0YXJnZXQsIHRhcmdldC5maXJzdENoaWxkLCBmcmFnbWVudCwgc2V0dGxlSW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKiBAcGFyYW0ge1BhcmVudE5vZGV9IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7SHRteFNldHRsZUluZm99IHNldHRsZUluZm9cbiAgICovXG4gIGZ1bmN0aW9uIHN3YXBCZWZvcmVCZWdpbih0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKSB7XG4gICAgcmV0dXJuIGluc2VydE5vZGVzQmVmb3JlKHBhcmVudEVsdCh0YXJnZXQpLCB0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gZnJhZ21lbnRcbiAgICogQHBhcmFtIHtIdG14U2V0dGxlSW5mb30gc2V0dGxlSW5mb1xuICAgKi9cbiAgZnVuY3Rpb24gc3dhcEJlZm9yZUVuZCh0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKSB7XG4gICAgcmV0dXJuIGluc2VydE5vZGVzQmVmb3JlKHRhcmdldCwgbnVsbCwgZnJhZ21lbnQsIHNldHRsZUluZm8pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtQYXJlbnROb2RlfSBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0h0bXhTZXR0bGVJbmZvfSBzZXR0bGVJbmZvXG4gICAqL1xuICBmdW5jdGlvbiBzd2FwQWZ0ZXJFbmQodGFyZ2V0LCBmcmFnbWVudCwgc2V0dGxlSW5mbykge1xuICAgIHJldHVybiBpbnNlcnROb2Rlc0JlZm9yZShwYXJlbnRFbHQodGFyZ2V0KSwgdGFyZ2V0Lm5leHRTaWJsaW5nLCBmcmFnbWVudCwgc2V0dGxlSW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICAgKi9cbiAgZnVuY3Rpb24gc3dhcERlbGV0ZSh0YXJnZXQpIHtcbiAgICBjbGVhblVwRWxlbWVudCh0YXJnZXQpXG4gICAgY29uc3QgcGFyZW50ID0gcGFyZW50RWx0KHRhcmdldClcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICByZXR1cm4gcGFyZW50LnJlbW92ZUNoaWxkKHRhcmdldClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtQYXJlbnROb2RlfSBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0h0bXhTZXR0bGVJbmZvfSBzZXR0bGVJbmZvXG4gICAqL1xuICBmdW5jdGlvbiBzd2FwSW5uZXJIVE1MKHRhcmdldCwgZnJhZ21lbnQsIHNldHRsZUluZm8pIHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGRcbiAgICBpbnNlcnROb2Rlc0JlZm9yZSh0YXJnZXQsIGZpcnN0Q2hpbGQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICB3aGlsZSAoZmlyc3RDaGlsZC5uZXh0U2libGluZykge1xuICAgICAgICBjbGVhblVwRWxlbWVudChmaXJzdENoaWxkLm5leHRTaWJsaW5nKVxuICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZC5uZXh0U2libGluZylcbiAgICAgIH1cbiAgICAgIGNsZWFuVXBFbGVtZW50KGZpcnN0Q2hpbGQpXG4gICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIdG14U3dhcFN0eWxlfSBzd2FwU3R5bGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAgICogQHBhcmFtIHtQYXJlbnROb2RlfSBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0h0bXhTZXR0bGVJbmZvfSBzZXR0bGVJbmZvXG4gICAqL1xuICBmdW5jdGlvbiBzd2FwV2l0aFN0eWxlKHN3YXBTdHlsZSwgZWx0LCB0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKSB7XG4gICAgc3dpdGNoIChzd2FwU3R5bGUpIHtcbiAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgJ291dGVySFRNTCc6XG4gICAgICAgIHN3YXBPdXRlckhUTUwodGFyZ2V0LCBmcmFnbWVudCwgc2V0dGxlSW5mbylcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlICdhZnRlcmJlZ2luJzpcbiAgICAgICAgc3dhcEFmdGVyQmVnaW4odGFyZ2V0LCBmcmFnbWVudCwgc2V0dGxlSW5mbylcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlICdiZWZvcmViZWdpbic6XG4gICAgICAgIHN3YXBCZWZvcmVCZWdpbih0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgJ2JlZm9yZWVuZCc6XG4gICAgICAgIHN3YXBCZWZvcmVFbmQodGFyZ2V0LCBmcmFnbWVudCwgc2V0dGxlSW5mbylcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlICdhZnRlcmVuZCc6XG4gICAgICAgIHN3YXBBZnRlckVuZCh0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgIHN3YXBEZWxldGUodGFyZ2V0KVxuICAgICAgICByZXR1cm5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBleHRlbnNpb25zID0gZ2V0RXh0ZW5zaW9ucyhlbHQpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGV4dCA9IGV4dGVuc2lvbnNbaV1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3RWxlbWVudHMgPSBleHQuaGFuZGxlU3dhcChzd2FwU3R5bGUsIHRhcmdldCwgZnJhZ21lbnQsIHNldHRsZUluZm8pXG4gICAgICAgICAgICBpZiAobmV3RWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV3RWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaGFuZGxlU3dhcCByZXR1cm5zIGFuIGFycmF5IChsaWtlKSBvZiBlbGVtZW50cywgd2UgaGFuZGxlIHRoZW1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5ld0VsZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5ld0VsZW1lbnRzW2pdXG4gICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0bGVJbmZvLnRhc2tzLnB1c2gobWFrZUFqYXhMb2FkVGFzayhjaGlsZCkpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ0Vycm9yKGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzd2FwU3R5bGUgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgICAgc3dhcElubmVySFRNTCh0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN3YXBXaXRoU3R5bGUoaHRteC5jb25maWcuZGVmYXVsdFN3YXBTdHlsZSwgZWx0LCB0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnRcbiAgICogQHBhcmFtIHtIdG14U2V0dGxlSW5mb30gc2V0dGxlSW5mb1xuICAgKiBAcGFyYW0ge05vZGV8RG9jdW1lbnR9IFtyb290Tm9kZV1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRBbmRTd2FwT29iRWxlbWVudHMoZnJhZ21lbnQsIHNldHRsZUluZm8sIHJvb3ROb2RlKSB7XG4gICAgdmFyIG9vYkVsdHMgPSBmaW5kQWxsKGZyYWdtZW50LCAnW2h4LXN3YXAtb29iXSwgW2RhdGEtaHgtc3dhcC1vb2JdJylcbiAgICBmb3JFYWNoKG9vYkVsdHMsIGZ1bmN0aW9uKG9vYkVsZW1lbnQpIHtcbiAgICAgIGlmIChodG14LmNvbmZpZy5hbGxvd05lc3RlZE9vYlN3YXBzIHx8IG9vYkVsZW1lbnQucGFyZW50RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvb2JWYWx1ZSA9IGdldEF0dHJpYnV0ZVZhbHVlKG9vYkVsZW1lbnQsICdoeC1zd2FwLW9vYicpXG4gICAgICAgIGlmIChvb2JWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgb29iU3dhcChvb2JWYWx1ZSwgb29iRWxlbWVudCwgc2V0dGxlSW5mbywgcm9vdE5vZGUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9vYkVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdoeC1zd2FwLW9vYicpXG4gICAgICAgIG9vYkVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWh4LXN3YXAtb29iJylcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBvb2JFbHRzLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGNvbXBsZXRlIHN3YXBwaW5nIHBpcGVsaW5lLCBpbmNsdWRpbmc6IGZvY3VzIGFuZCBzZWxlY3Rpb24gcHJlc2VydmF0aW9uLFxuICAgKiB0aXRsZSB1cGRhdGVzLCBzY3JvbGwsIE9PQiBzd2FwcGluZywgbm9ybWFsIHN3YXBwaW5nIGFuZCBzZXR0bGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICogQHBhcmFtIHtIdG14U3dhcFNwZWNpZmljYXRpb259IHN3YXBTcGVjXG4gICAqIEBwYXJhbSB7U3dhcE9wdGlvbnN9IFtzd2FwT3B0aW9uc11cbiAgICovXG4gIGZ1bmN0aW9uIHN3YXAodGFyZ2V0LCBjb250ZW50LCBzd2FwU3BlYywgc3dhcE9wdGlvbnMpIHtcbiAgICBpZiAoIXN3YXBPcHRpb25zKSB7XG4gICAgICBzd2FwT3B0aW9ucyA9IHt9XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gcmVzb2x2ZVRhcmdldCh0YXJnZXQpXG4gICAgY29uc3Qgcm9vdE5vZGUgPSBzd2FwT3B0aW9ucy5jb250ZXh0RWxlbWVudCA/IGdldFJvb3ROb2RlKHN3YXBPcHRpb25zLmNvbnRleHRFbGVtZW50LCBmYWxzZSkgOiBnZXREb2N1bWVudCgpXG5cbiAgICAvLyBwcmVzZXJ2ZSBmb2N1cyBhbmQgc2VsZWN0aW9uXG4gICAgY29uc3QgYWN0aXZlRWx0ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgIGxldCBzZWxlY3Rpb25JbmZvID0ge31cbiAgICB0cnkge1xuICAgICAgc2VsZWN0aW9uSW5mbyA9IHtcbiAgICAgICAgZWx0OiBhY3RpdmVFbHQsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc3RhcnQ6IGFjdGl2ZUVsdCA/IGFjdGl2ZUVsdC5zZWxlY3Rpb25TdGFydCA6IG51bGwsXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZW5kOiBhY3RpdmVFbHQgPyBhY3RpdmVFbHQuc2VsZWN0aW9uRW5kIDogbnVsbFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNhZmFyaSBpc3N1ZSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3BsYXl3cmlnaHQvaXNzdWVzLzU4OTRcbiAgICB9XG4gICAgY29uc3Qgc2V0dGxlSW5mbyA9IG1ha2VTZXR0bGVJbmZvKHRhcmdldClcblxuICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgc3dhcHMsIGRvbid0IHBhcnNlIHRoZSByZXNwb25zZSBhcyBIVE1MLCBqdXN0IGluc2VydCBpdFxuICAgIGlmIChzd2FwU3BlYy5zd2FwU3R5bGUgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgIHRhcmdldC50ZXh0Q29udGVudCA9IGNvbnRlbnRcbiAgICAvLyBPdGhlcndpc2UsIG1ha2UgdGhlIGZyYWdtZW50IGFuZCBwcm9jZXNzIGl0XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBmcmFnbWVudCA9IG1ha2VGcmFnbWVudChjb250ZW50KVxuXG4gICAgICBzZXR0bGVJbmZvLnRpdGxlID0gZnJhZ21lbnQudGl0bGVcblxuICAgICAgLy8gc2VsZWN0LW9vYiBzd2Fwc1xuICAgICAgaWYgKHN3YXBPcHRpb25zLnNlbGVjdE9PQikge1xuICAgICAgICBjb25zdCBvb2JTZWxlY3RWYWx1ZXMgPSBzd2FwT3B0aW9ucy5zZWxlY3RPT0Iuc3BsaXQoJywnKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9vYlNlbGVjdFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG9vYlNlbGVjdFZhbHVlID0gb29iU2VsZWN0VmFsdWVzW2ldLnNwbGl0KCc6JywgMilcbiAgICAgICAgICBsZXQgaWQgPSBvb2JTZWxlY3RWYWx1ZVswXS50cmltKClcbiAgICAgICAgICBpZiAoaWQuaW5kZXhPZignIycpID09PSAwKSB7XG4gICAgICAgICAgICBpZCA9IGlkLnN1YnN0cmluZygxKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvb2JWYWx1ZSA9IG9vYlNlbGVjdFZhbHVlWzFdIHx8ICd0cnVlJ1xuICAgICAgICAgIGNvbnN0IG9vYkVsZW1lbnQgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIGlkKVxuICAgICAgICAgIGlmIChvb2JFbGVtZW50KSB7XG4gICAgICAgICAgICBvb2JTd2FwKG9vYlZhbHVlLCBvb2JFbGVtZW50LCBzZXR0bGVJbmZvLCByb290Tm9kZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG9vYiBzd2Fwc1xuICAgICAgZmluZEFuZFN3YXBPb2JFbGVtZW50cyhmcmFnbWVudCwgc2V0dGxlSW5mbywgcm9vdE5vZGUpXG4gICAgICBmb3JFYWNoKGZpbmRBbGwoZnJhZ21lbnQsICd0ZW1wbGF0ZScpLCAvKiogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSAqL2Z1bmN0aW9uKHRlbXBsYXRlKSB7XG4gICAgICAgIGlmIChmaW5kQW5kU3dhcE9vYkVsZW1lbnRzKHRlbXBsYXRlLmNvbnRlbnQsIHNldHRsZUluZm8sIHJvb3ROb2RlKSkge1xuICAgICAgICAgIC8vIEF2b2lkIHBvbGx1dGluZyB0aGUgRE9NIHdpdGggZW1wdHkgdGVtcGxhdGVzIHRoYXQgd2VyZSBvbmx5IHVzZWQgdG8gZW5jYXBzdWxhdGUgb29iIHN3YXBcbiAgICAgICAgICB0ZW1wbGF0ZS5yZW1vdmUoKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBub3JtYWwgc3dhcFxuICAgICAgaWYgKHN3YXBPcHRpb25zLnNlbGVjdCkge1xuICAgICAgICBjb25zdCBuZXdGcmFnbWVudCA9IGdldERvY3VtZW50KCkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICAgIGZvckVhY2goZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbChzd2FwT3B0aW9ucy5zZWxlY3QpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgbmV3RnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgICAgfSlcbiAgICAgICAgZnJhZ21lbnQgPSBuZXdGcmFnbWVudFxuICAgICAgfVxuICAgICAgaGFuZGxlUHJlc2VydmVkRWxlbWVudHMoZnJhZ21lbnQpXG4gICAgICBzd2FwV2l0aFN0eWxlKHN3YXBTcGVjLnN3YXBTdHlsZSwgc3dhcE9wdGlvbnMuY29udGV4dEVsZW1lbnQsIHRhcmdldCwgZnJhZ21lbnQsIHNldHRsZUluZm8pXG4gICAgICByZXN0b3JlUHJlc2VydmVkRWxlbWVudHMoKVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHNhdmVkIGZvY3VzIGFuZCBzZWxlY3Rpb24gaW5mb3JtYXRpb24gdG8gc3dhcHBlZCBjb250ZW50XG4gICAgaWYgKHNlbGVjdGlvbkluZm8uZWx0ICYmXG4gICAgICAhYm9keUNvbnRhaW5zKHNlbGVjdGlvbkluZm8uZWx0KSAmJlxuICAgICAgZ2V0UmF3QXR0cmlidXRlKHNlbGVjdGlvbkluZm8uZWx0LCAnaWQnKSkge1xuICAgICAgY29uc3QgbmV3QWN0aXZlRWx0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZ2V0UmF3QXR0cmlidXRlKHNlbGVjdGlvbkluZm8uZWx0LCAnaWQnKSlcbiAgICAgIGNvbnN0IGZvY3VzT3B0aW9ucyA9IHsgcHJldmVudFNjcm9sbDogc3dhcFNwZWMuZm9jdXNTY3JvbGwgIT09IHVuZGVmaW5lZCA/ICFzd2FwU3BlYy5mb2N1c1Njcm9sbCA6ICFodG14LmNvbmZpZy5kZWZhdWx0Rm9jdXNTY3JvbGwgfVxuICAgICAgaWYgKG5ld0FjdGl2ZUVsdCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChzZWxlY3Rpb25JbmZvLnN0YXJ0ICYmIG5ld0FjdGl2ZUVsdC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBuZXdBY3RpdmVFbHQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uSW5mby5zdGFydCwgc2VsZWN0aW9uSW5mby5lbmQpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gdGhlIHNldFNlbGVjdGlvblJhbmdlIG1ldGhvZCBpcyBwcmVzZW50IG9uIGZpZWxkcyB0aGF0IGRvbid0IHN1cHBvcnQgaXQsIHNvIGp1c3QgbGV0IHRoaXMgZmFpbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdBY3RpdmVFbHQuZm9jdXMoZm9jdXNPcHRpb25zKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKGh0bXguY29uZmlnLnN3YXBwaW5nQ2xhc3MpXG4gICAgZm9yRWFjaChzZXR0bGVJbmZvLmVsdHMsIGZ1bmN0aW9uKGVsdCkge1xuICAgICAgaWYgKGVsdC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWx0LmNsYXNzTGlzdC5hZGQoaHRteC5jb25maWcuc2V0dGxpbmdDbGFzcylcbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudChlbHQsICdodG14OmFmdGVyU3dhcCcsIHN3YXBPcHRpb25zLmV2ZW50SW5mbylcbiAgICB9KVxuICAgIGlmIChzd2FwT3B0aW9ucy5hZnRlclN3YXBDYWxsYmFjaykge1xuICAgICAgc3dhcE9wdGlvbnMuYWZ0ZXJTd2FwQ2FsbGJhY2soKVxuICAgIH1cblxuICAgIC8vIG1lcmdlIGluIG5ldyB0aXRsZSBhZnRlciBzd2FwIGJ1dCBiZWZvcmUgc2V0dGxlXG4gICAgaWYgKCFzd2FwU3BlYy5pZ25vcmVUaXRsZSkge1xuICAgICAgaGFuZGxlVGl0bGUoc2V0dGxlSW5mby50aXRsZSlcbiAgICB9XG5cbiAgICAvLyBzZXR0bGVcbiAgICBjb25zdCBkb1NldHRsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yRWFjaChzZXR0bGVJbmZvLnRhc2tzLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgIHRhc2suY2FsbCgpXG4gICAgICB9KVxuICAgICAgZm9yRWFjaChzZXR0bGVJbmZvLmVsdHMsIGZ1bmN0aW9uKGVsdCkge1xuICAgICAgICBpZiAoZWx0LmNsYXNzTGlzdCkge1xuICAgICAgICAgIGVsdC5jbGFzc0xpc3QucmVtb3ZlKGh0bXguY29uZmlnLnNldHRsaW5nQ2xhc3MpXG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6YWZ0ZXJTZXR0bGUnLCBzd2FwT3B0aW9ucy5ldmVudEluZm8pXG4gICAgICB9KVxuXG4gICAgICBpZiAoc3dhcE9wdGlvbnMuYW5jaG9yKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvclRhcmdldCA9IGFzRWxlbWVudChyZXNvbHZlVGFyZ2V0KCcjJyArIHN3YXBPcHRpb25zLmFuY2hvcikpXG4gICAgICAgIGlmIChhbmNob3JUYXJnZXQpIHtcbiAgICAgICAgICBhbmNob3JUYXJnZXQuc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ3N0YXJ0JywgYmVoYXZpb3I6ICdhdXRvJyB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVNjcm9sbFN0YXRlKHNldHRsZUluZm8uZWx0cywgc3dhcFNwZWMpXG4gICAgICBpZiAoc3dhcE9wdGlvbnMuYWZ0ZXJTZXR0bGVDYWxsYmFjaykge1xuICAgICAgICBzd2FwT3B0aW9ucy5hZnRlclNldHRsZUNhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3dhcFNwZWMuc2V0dGxlRGVsYXkgPiAwKSB7XG4gICAgICBnZXRXaW5kb3coKS5zZXRUaW1lb3V0KGRvU2V0dGxlLCBzd2FwU3BlYy5zZXR0bGVEZWxheSlcbiAgICB9IGVsc2Uge1xuICAgICAgZG9TZXR0bGUoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbHRcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVRyaWdnZXJIZWFkZXIoeGhyLCBoZWFkZXIsIGVsdCkge1xuICAgIGNvbnN0IHRyaWdnZXJCb2R5ID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcilcbiAgICBpZiAodHJpZ2dlckJvZHkuaW5kZXhPZigneycpID09PSAwKSB7XG4gICAgICBjb25zdCB0cmlnZ2VycyA9IHBhcnNlSlNPTih0cmlnZ2VyQm9keSlcbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIHRyaWdnZXJzKSB7XG4gICAgICAgIGlmICh0cmlnZ2Vycy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgICAgbGV0IGRldGFpbCA9IHRyaWdnZXJzW2V2ZW50TmFtZV1cbiAgICAgICAgICBpZiAoaXNSYXdPYmplY3QoZGV0YWlsKSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZWx0ID0gZGV0YWlsLnRhcmdldCAhPT0gdW5kZWZpbmVkID8gZGV0YWlsLnRhcmdldCA6IGVsdFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXRhaWwgPSB7IHZhbHVlOiBkZXRhaWwgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlnZ2VyRXZlbnQoZWx0LCBldmVudE5hbWUsIGRldGFpbClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBldmVudE5hbWVzID0gdHJpZ2dlckJvZHkuc3BsaXQoJywnKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudChlbHQsIGV2ZW50TmFtZXNbaV0udHJpbSgpLCBbXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBXSElURVNQQUNFID0gL1xccy9cbiAgY29uc3QgV0hJVEVTUEFDRV9PUl9DT01NQSA9IC9bXFxzLF0vXG4gIGNvbnN0IFNZTUJPTF9TVEFSVCA9IC9bXyRhLXpBLVpdL1xuICBjb25zdCBTWU1CT0xfQ09OVCA9IC9bXyRhLXpBLVowLTldL1xuICBjb25zdCBTVFJJTkdJU0hfU1RBUlQgPSBbJ1wiJywgXCInXCIsICcvJ11cbiAgY29uc3QgTk9UX1dISVRFU1BBQ0UgPSAvW15cXHNdL1xuICBjb25zdCBDT01CSU5FRF9TRUxFQ1RPUl9TVEFSVCA9IC9beyhdL1xuICBjb25zdCBDT01CSU5FRF9TRUxFQ1RPUl9FTkQgPSAvW30pXS9cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119XG4gICAqL1xuICBmdW5jdGlvbiB0b2tlbml6ZVN0cmluZyhzdHIpIHtcbiAgICAvKiogQHR5cGUgc3RyaW5nW10gKi9cbiAgICBjb25zdCB0b2tlbnMgPSBbXVxuICAgIGxldCBwb3NpdGlvbiA9IDBcbiAgICB3aGlsZSAocG9zaXRpb24gPCBzdHIubGVuZ3RoKSB7XG4gICAgICBpZiAoU1lNQk9MX1NUQVJULmV4ZWMoc3RyLmNoYXJBdChwb3NpdGlvbikpKSB7XG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gcG9zaXRpb25cbiAgICAgICAgd2hpbGUgKFNZTUJPTF9DT05ULmV4ZWMoc3RyLmNoYXJBdChwb3NpdGlvbiArIDEpKSkge1xuICAgICAgICAgIHBvc2l0aW9uKytcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMucHVzaChzdHIuc3Vic3RyKHN0YXJ0UG9zaXRpb24sIHBvc2l0aW9uIC0gc3RhcnRQb3NpdGlvbiArIDEpKVxuICAgICAgfSBlbHNlIGlmIChTVFJJTkdJU0hfU1RBUlQuaW5kZXhPZihzdHIuY2hhckF0KHBvc2l0aW9uKSkgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2hhciA9IHN0ci5jaGFyQXQocG9zaXRpb24pXG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gcG9zaXRpb25cbiAgICAgICAgcG9zaXRpb24rK1xuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQocG9zaXRpb24pICE9PSBzdGFydENoYXIpIHtcbiAgICAgICAgICBpZiAoc3RyLmNoYXJBdChwb3NpdGlvbikgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgcG9zaXRpb24rK1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3NpdGlvbisrXG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnB1c2goc3RyLnN1YnN0cihzdGFydFBvc2l0aW9uLCBwb3NpdGlvbiAtIHN0YXJ0UG9zaXRpb24gKyAxKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IHN0ci5jaGFyQXQocG9zaXRpb24pXG4gICAgICAgIHRva2Vucy5wdXNoKHN5bWJvbClcbiAgICAgIH1cbiAgICAgIHBvc2l0aW9uKytcbiAgICB9XG4gICAgcmV0dXJuIHRva2Vuc1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBsYXN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc1Bvc3NpYmxlUmVsYXRpdmVSZWZlcmVuY2UodG9rZW4sIGxhc3QsIHBhcmFtTmFtZSkge1xuICAgIHJldHVybiBTWU1CT0xfU1RBUlQuZXhlYyh0b2tlbi5jaGFyQXQoMCkpICYmXG4gICAgICB0b2tlbiAhPT0gJ3RydWUnICYmXG4gICAgICB0b2tlbiAhPT0gJ2ZhbHNlJyAmJlxuICAgICAgdG9rZW4gIT09ICd0aGlzJyAmJlxuICAgICAgdG9rZW4gIT09IHBhcmFtTmFtZSAmJlxuICAgICAgbGFzdCAhPT0gJy4nXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldHxzdHJpbmd9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0b2tlbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZVxuICAgKiBAcmV0dXJucyB7Q29uZGl0aW9uYWxGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gbWF5YmVHZW5lcmF0ZUNvbmRpdGlvbmFsKGVsdCwgdG9rZW5zLCBwYXJhbU5hbWUpIHtcbiAgICBpZiAodG9rZW5zWzBdID09PSAnWycpIHtcbiAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICBsZXQgYnJhY2tldENvdW50ID0gMVxuICAgICAgbGV0IGNvbmRpdGlvbmFsU291cmNlID0gJyByZXR1cm4gKGZ1bmN0aW9uKCcgKyBwYXJhbU5hbWUgKyAnKXsgcmV0dXJuICgnXG4gICAgICBsZXQgbGFzdCA9IG51bGxcbiAgICAgIHdoaWxlICh0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1swXVxuICAgICAgICAvLyBAdHMtaWdub3JlIEZvciBzb21lIHJlYXNvbiB0c2MgZG9lc24ndCB1bmRlcnN0YW5kIHRoZSBzaGlmdCBjYWxsLCBhbmQgdGhpbmtzIHdlJ3JlIGNvbXBhcmluZyB0aGUgc2FtZSB2YWx1ZSBoZXJlLCBpLmUuICdbJyB2cyAnXSdcbiAgICAgICAgaWYgKHRva2VuID09PSAnXScpIHtcbiAgICAgICAgICBicmFja2V0Q291bnQtLVxuICAgICAgICAgIGlmIChicmFja2V0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvbmFsU291cmNlID0gY29uZGl0aW9uYWxTb3VyY2UgKyAndHJ1ZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgICAgICBjb25kaXRpb25hbFNvdXJjZSArPSAnKX0pJ1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uRnVuY3Rpb24gPSBtYXliZUV2YWwoZWx0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24oY29uZGl0aW9uYWxTb3VyY2UpKClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0pXG4gICAgICAgICAgICAgIGNvbmRpdGlvbkZ1bmN0aW9uLnNvdXJjZSA9IGNvbmRpdGlvbmFsU291cmNlXG4gICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25GdW5jdGlvblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14OnN5bnRheDplcnJvcicsIHsgZXJyb3I6IGUsIHNvdXJjZTogY29uZGl0aW9uYWxTb3VyY2UgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdbJykge1xuICAgICAgICAgIGJyYWNrZXRDb3VudCsrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUG9zc2libGVSZWxhdGl2ZVJlZmVyZW5jZSh0b2tlbiwgbGFzdCwgcGFyYW1OYW1lKSkge1xuICAgICAgICAgIGNvbmRpdGlvbmFsU291cmNlICs9ICcoKCcgKyBwYXJhbU5hbWUgKyAnLicgKyB0b2tlbiArICcpID8gKCcgKyBwYXJhbU5hbWUgKyAnLicgKyB0b2tlbiArICcpIDogKHdpbmRvdy4nICsgdG9rZW4gKyAnKSknXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZGl0aW9uYWxTb3VyY2UgPSBjb25kaXRpb25hbFNvdXJjZSArIHRva2VuXG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IHRva2Vucy5zaGlmdCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHRva2Vuc1xuICAgKiBAcGFyYW0ge1JlZ0V4cH0gbWF0Y2hcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGNvbnN1bWVVbnRpbCh0b2tlbnMsIG1hdGNoKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwICYmICFtYXRjaC50ZXN0KHRva2Vuc1swXSkpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnMuc2hpZnQoKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gdG9rZW5zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBjb25zdW1lQ1NTU2VsZWN0b3IodG9rZW5zKSB7XG4gICAgbGV0IHJlc3VsdFxuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiBDT01CSU5FRF9TRUxFQ1RPUl9TVEFSVC50ZXN0KHRva2Vuc1swXSkpIHtcbiAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICByZXN1bHQgPSBjb25zdW1lVW50aWwodG9rZW5zLCBDT01CSU5FRF9TRUxFQ1RPUl9FTkQpLnRyaW0oKVxuICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29uc3VtZVVudGlsKHRva2VucywgV0hJVEVTUEFDRV9PUl9DT01NQSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgY29uc3QgSU5QVVRfU0VMRUNUT1IgPSAnaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QnXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHBsaWNpdFRyaWdnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIGZvciB0cmlnZ2VyIHNwZWNzXG4gICAqIEByZXR1cm5zIHtIdG14VHJpZ2dlclNwZWNpZmljYXRpb25bXX1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQW5kQ2FjaGVUcmlnZ2VyKGVsdCwgZXhwbGljaXRUcmlnZ2VyLCBjYWNoZSkge1xuICAgIC8qKiBAdHlwZSBIdG14VHJpZ2dlclNwZWNpZmljYXRpb25bXSAqL1xuICAgIGNvbnN0IHRyaWdnZXJTcGVjcyA9IFtdXG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemVTdHJpbmcoZXhwbGljaXRUcmlnZ2VyKVxuICAgIGRvIHtcbiAgICAgIGNvbnN1bWVVbnRpbCh0b2tlbnMsIE5PVF9XSElURVNQQUNFKVxuICAgICAgY29uc3QgaW5pdGlhbExlbmd0aCA9IHRva2Vucy5sZW5ndGhcbiAgICAgIGNvbnN0IHRyaWdnZXIgPSBjb25zdW1lVW50aWwodG9rZW5zLCAvWyxcXFtcXHNdLylcbiAgICAgIGlmICh0cmlnZ2VyICE9PSAnJykge1xuICAgICAgICBpZiAodHJpZ2dlciA9PT0gJ2V2ZXJ5Jykge1xuICAgICAgICAgIC8qKiBAdHlwZSBIdG14VHJpZ2dlclNwZWNpZmljYXRpb24gKi9cbiAgICAgICAgICBjb25zdCBldmVyeSA9IHsgdHJpZ2dlcjogJ2V2ZXJ5JyB9XG4gICAgICAgICAgY29uc3VtZVVudGlsKHRva2VucywgTk9UX1dISVRFU1BBQ0UpXG4gICAgICAgICAgZXZlcnkucG9sbEludGVydmFsID0gcGFyc2VJbnRlcnZhbChjb25zdW1lVW50aWwodG9rZW5zLCAvWyxcXFtcXHNdLykpXG4gICAgICAgICAgY29uc3VtZVVudGlsKHRva2VucywgTk9UX1dISVRFU1BBQ0UpXG4gICAgICAgICAgdmFyIGV2ZW50RmlsdGVyID0gbWF5YmVHZW5lcmF0ZUNvbmRpdGlvbmFsKGVsdCwgdG9rZW5zLCAnZXZlbnQnKVxuICAgICAgICAgIGlmIChldmVudEZpbHRlcikge1xuICAgICAgICAgICAgZXZlcnkuZXZlbnRGaWx0ZXIgPSBldmVudEZpbHRlclxuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlnZ2VyU3BlY3MucHVzaChldmVyeSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiogQHR5cGUgSHRteFRyaWdnZXJTcGVjaWZpY2F0aW9uICovXG4gICAgICAgICAgY29uc3QgdHJpZ2dlclNwZWMgPSB7IHRyaWdnZXIgfVxuICAgICAgICAgIHZhciBldmVudEZpbHRlciA9IG1heWJlR2VuZXJhdGVDb25kaXRpb25hbChlbHQsIHRva2VucywgJ2V2ZW50JylcbiAgICAgICAgICBpZiAoZXZlbnRGaWx0ZXIpIHtcbiAgICAgICAgICAgIHRyaWdnZXJTcGVjLmV2ZW50RmlsdGVyID0gZXZlbnRGaWx0ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3VtZVVudGlsKHRva2VucywgTk9UX1dISVRFU1BBQ0UpXG4gICAgICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1swXSAhPT0gJywnKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vucy5zaGlmdCgpXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09ICdjaGFuZ2VkJykge1xuICAgICAgICAgICAgICB0cmlnZ2VyU3BlYy5jaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ29uY2UnKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJTcGVjLm9uY2UgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnY29uc3VtZScpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlclNwZWMuY29uc3VtZSA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICdkZWxheScgJiYgdG9rZW5zWzBdID09PSAnOicpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgICAgICAgdHJpZ2dlclNwZWMuZGVsYXkgPSBwYXJzZUludGVydmFsKGNvbnN1bWVVbnRpbCh0b2tlbnMsIFdISVRFU1BBQ0VfT1JfQ09NTUEpKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ2Zyb20nICYmIHRva2Vuc1swXSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgICAgICAgIGlmIChDT01CSU5FRF9TRUxFQ1RPUl9TVEFSVC50ZXN0KHRva2Vuc1swXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbV9hcmcgPSBjb25zdW1lQ1NTU2VsZWN0b3IodG9rZW5zKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tX2FyZyA9IGNvbnN1bWVVbnRpbCh0b2tlbnMsIFdISVRFU1BBQ0VfT1JfQ09NTUEpXG4gICAgICAgICAgICAgICAgaWYgKGZyb21fYXJnID09PSAnY2xvc2VzdCcgfHwgZnJvbV9hcmcgPT09ICdmaW5kJyB8fCBmcm9tX2FyZyA9PT0gJ25leHQnIHx8IGZyb21fYXJnID09PSAncHJldmlvdXMnKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBjb25zdW1lQ1NTU2VsZWN0b3IodG9rZW5zKVxuICAgICAgICAgICAgICAgICAgLy8gYG5leHRgIGFuZCBgcHJldmlvdXNgIGFsbG93IGEgc2VsZWN0b3ItbGVzcyBzeW50YXhcbiAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21fYXJnICs9ICcgJyArIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyaWdnZXJTcGVjLmZyb20gPSBmcm9tX2FyZ1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ3RhcmdldCcgJiYgdG9rZW5zWzBdID09PSAnOicpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgICAgICAgdHJpZ2dlclNwZWMudGFyZ2V0ID0gY29uc3VtZUNTU1NlbGVjdG9yKHRva2VucylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICd0aHJvdHRsZScgJiYgdG9rZW5zWzBdID09PSAnOicpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgICAgICAgdHJpZ2dlclNwZWMudGhyb3R0bGUgPSBwYXJzZUludGVydmFsKGNvbnN1bWVVbnRpbCh0b2tlbnMsIFdISVRFU1BBQ0VfT1JfQ09NTUEpKVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJ3F1ZXVlJyAmJiB0b2tlbnNbMF0gPT09ICc6Jykge1xuICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKVxuICAgICAgICAgICAgICB0cmlnZ2VyU3BlYy5xdWV1ZSA9IGNvbnN1bWVVbnRpbCh0b2tlbnMsIFdISVRFU1BBQ0VfT1JfQ09NTUEpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuID09PSAncm9vdCcgJiYgdG9rZW5zWzBdID09PSAnOicpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnNoaWZ0KClcbiAgICAgICAgICAgICAgdHJpZ2dlclNwZWNbdG9rZW5dID0gY29uc3VtZUNTU1NlbGVjdG9yKHRva2VucylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICd0aHJlc2hvbGQnICYmIHRva2Vuc1swXSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgIHRva2Vucy5zaGlmdCgpXG4gICAgICAgICAgICAgIHRyaWdnZXJTcGVjW3Rva2VuXSA9IGNvbnN1bWVVbnRpbCh0b2tlbnMsIFdISVRFU1BBQ0VfT1JfQ09NTUEpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cmlnZ2VyRXJyb3JFdmVudChlbHQsICdodG14OnN5bnRheDplcnJvcicsIHsgdG9rZW46IHRva2Vucy5zaGlmdCgpIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lVW50aWwodG9rZW5zLCBOT1RfV0hJVEVTUEFDRSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlclNwZWNzLnB1c2godHJpZ2dlclNwZWMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSBpbml0aWFsTGVuZ3RoKSB7XG4gICAgICAgIHRyaWdnZXJFcnJvckV2ZW50KGVsdCwgJ2h0bXg6c3ludGF4OmVycm9yJywgeyB0b2tlbjogdG9rZW5zLnNoaWZ0KCkgfSlcbiAgICAgIH1cbiAgICAgIGNvbnN1bWVVbnRpbCh0b2tlbnMsIE5PVF9XSElURVNQQUNFKVxuICAgIH0gd2hpbGUgKHRva2Vuc1swXSA9PT0gJywnICYmIHRva2Vucy5zaGlmdCgpKVxuICAgIGlmIChjYWNoZSkge1xuICAgICAgY2FjaGVbZXhwbGljaXRUcmlnZ2VyXSA9IHRyaWdnZXJTcGVjc1xuICAgIH1cbiAgICByZXR1cm4gdHJpZ2dlclNwZWNzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHJldHVybnMge0h0bXhUcmlnZ2VyU3BlY2lmaWNhdGlvbltdfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VHJpZ2dlclNwZWNzKGVsdCkge1xuICAgIGNvbnN0IGV4cGxpY2l0VHJpZ2dlciA9IGdldEF0dHJpYnV0ZVZhbHVlKGVsdCwgJ2h4LXRyaWdnZXInKVxuICAgIGxldCB0cmlnZ2VyU3BlY3MgPSBbXVxuICAgIGlmIChleHBsaWNpdFRyaWdnZXIpIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gaHRteC5jb25maWcudHJpZ2dlclNwZWNzQ2FjaGVcbiAgICAgIHRyaWdnZXJTcGVjcyA9IChjYWNoZSAmJiBjYWNoZVtleHBsaWNpdFRyaWdnZXJdKSB8fCBwYXJzZUFuZENhY2hlVHJpZ2dlcihlbHQsIGV4cGxpY2l0VHJpZ2dlciwgY2FjaGUpXG4gICAgfVxuXG4gICAgaWYgKHRyaWdnZXJTcGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJpZ2dlclNwZWNzXG4gICAgfSBlbHNlIGlmIChtYXRjaGVzKGVsdCwgJ2Zvcm0nKSkge1xuICAgICAgcmV0dXJuIFt7IHRyaWdnZXI6ICdzdWJtaXQnIH1dXG4gICAgfSBlbHNlIGlmIChtYXRjaGVzKGVsdCwgJ2lucHV0W3R5cGU9XCJidXR0b25cIl0sIGlucHV0W3R5cGU9XCJzdWJtaXRcIl0nKSkge1xuICAgICAgcmV0dXJuIFt7IHRyaWdnZXI6ICdjbGljaycgfV1cbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMoZWx0LCBJTlBVVF9TRUxFQ1RPUikpIHtcbiAgICAgIHJldHVybiBbeyB0cmlnZ2VyOiAnY2hhbmdlJyB9XVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3sgdHJpZ2dlcjogJ2NsaWNrJyB9XVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKi9cbiAgZnVuY3Rpb24gY2FuY2VsUG9sbGluZyhlbHQpIHtcbiAgICBnZXRJbnRlcm5hbERhdGEoZWx0KS5jYW5jZWxsZWQgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHBhcmFtIHtUcmlnZ2VySGFuZGxlcn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0h0bXhUcmlnZ2VyU3BlY2lmaWNhdGlvbn0gc3BlY1xuICAgKi9cbiAgZnVuY3Rpb24gcHJvY2Vzc1BvbGxpbmcoZWx0LCBoYW5kbGVyLCBzcGVjKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBnZXRJbnRlcm5hbERhdGEoZWx0KVxuICAgIG5vZGVEYXRhLnRpbWVvdXQgPSBnZXRXaW5kb3coKS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGJvZHlDb250YWlucyhlbHQpICYmIG5vZGVEYXRhLmNhbmNlbGxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoIW1heWJlRmlsdGVyRXZlbnQoc3BlYywgZWx0LCBtYWtlRXZlbnQoJ2h4OnBvbGw6dHJpZ2dlcicsIHtcbiAgICAgICAgICB0cmlnZ2VyU3BlYzogc3BlYyxcbiAgICAgICAgICB0YXJnZXQ6IGVsdFxuICAgICAgICB9KSkpIHtcbiAgICAgICAgICBoYW5kbGVyKGVsdClcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzUG9sbGluZyhlbHQsIGhhbmRsZXIsIHNwZWMpXG4gICAgICB9XG4gICAgfSwgc3BlYy5wb2xsSW50ZXJ2YWwpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MQW5jaG9yRWxlbWVudH0gZWx0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaXNMb2NhbExpbmsoZWx0KSB7XG4gICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lID09PSBlbHQuaG9zdG5hbWUgJiZcbiAgICAgIGdldFJhd0F0dHJpYnV0ZShlbHQsICdocmVmJykgJiZcbiAgICAgIGdldFJhd0F0dHJpYnV0ZShlbHQsICdocmVmJykuaW5kZXhPZignIycpICE9PSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICovXG4gIGZ1bmN0aW9uIGVsdElzRGlzYWJsZWQoZWx0KSB7XG4gICAgcmV0dXJuIGNsb3Nlc3QoZWx0LCBodG14LmNvbmZpZy5kaXNhYmxlU2VsZWN0b3IpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHBhcmFtIHtIdG14Tm9kZUludGVybmFsRGF0YX0gbm9kZURhdGFcbiAgICogQHBhcmFtIHtIdG14VHJpZ2dlclNwZWNpZmljYXRpb25bXX0gdHJpZ2dlclNwZWNzXG4gICAqL1xuICBmdW5jdGlvbiBib29zdEVsZW1lbnQoZWx0LCBub2RlRGF0YSwgdHJpZ2dlclNwZWNzKSB7XG4gICAgaWYgKChlbHQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCAmJiBpc0xvY2FsTGluayhlbHQpICYmIChlbHQudGFyZ2V0ID09PSAnJyB8fCBlbHQudGFyZ2V0ID09PSAnX3NlbGYnKSkgfHwgKGVsdC50YWdOYW1lID09PSAnRk9STScgJiYgU3RyaW5nKGdldFJhd0F0dHJpYnV0ZShlbHQsICdtZXRob2QnKSkudG9Mb3dlckNhc2UoKSAhPT0gJ2RpYWxvZycpKSB7XG4gICAgICBub2RlRGF0YS5ib29zdGVkID0gdHJ1ZVxuICAgICAgbGV0IHZlcmIsIHBhdGhcbiAgICAgIGlmIChlbHQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgIHZlcmIgPSAoLyoqIEB0eXBlIEh0dHBWZXJiICovKCdnZXQnKSlcbiAgICAgICAgcGF0aCA9IGdldFJhd0F0dHJpYnV0ZShlbHQsICdocmVmJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhd0F0dHJpYnV0ZSA9IGdldFJhd0F0dHJpYnV0ZShlbHQsICdtZXRob2QnKVxuICAgICAgICB2ZXJiID0gKC8qKiBAdHlwZSBIdHRwVmVyYiAqLyhyYXdBdHRyaWJ1dGUgPyByYXdBdHRyaWJ1dGUudG9Mb3dlckNhc2UoKSA6ICdnZXQnKSlcbiAgICAgICAgcGF0aCA9IGdldFJhd0F0dHJpYnV0ZShlbHQsICdhY3Rpb24nKVxuICAgICAgICBpZiAodmVyYiA9PT0gJ2dldCcgJiYgcGF0aC5pbmNsdWRlcygnPycpKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFw/W14jXSsvLCAnJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJpZ2dlclNwZWNzLmZvckVhY2goZnVuY3Rpb24odHJpZ2dlclNwZWMpIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbHQsIGZ1bmN0aW9uKG5vZGUsIGV2dCkge1xuICAgICAgICAgIGNvbnN0IGVsdCA9IGFzRWxlbWVudChub2RlKVxuICAgICAgICAgIGlmIChlbHRJc0Rpc2FibGVkKGVsdCkpIHtcbiAgICAgICAgICAgIGNsZWFuVXBFbGVtZW50KGVsdClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpc3N1ZUFqYXhSZXF1ZXN0KHZlcmIsIHBhdGgsIGVsdCwgZXZ0KVxuICAgICAgICB9LCBub2RlRGF0YSwgdHJpZ2dlclNwZWMsIHRydWUpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gc2hvdWxkQ2FuY2VsKGV2dCwgbm9kZSkge1xuICAgIGNvbnN0IGVsdCA9IGFzRWxlbWVudChub2RlKVxuICAgIGlmICghZWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGV2dC50eXBlID09PSAnc3VibWl0JyB8fCBldnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgaWYgKGVsdC50YWdOYW1lID09PSAnRk9STScpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaGVzKGVsdCwgJ2lucHV0W3R5cGU9XCJzdWJtaXRcIl0sIGJ1dHRvbicpICYmIGNsb3Nlc3QoZWx0LCAnZm9ybScpICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoZWx0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiYgZWx0LmhyZWYgJiZcbiAgICAgICAgKGVsdC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSA9PT0gJyMnIHx8IGVsdC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKS5pbmRleE9mKCcjJykgIT09IDApKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWx0XG4gICAqIEBwYXJhbSB7RXZlbnR8TW91c2VFdmVudHxLZXlib2FyZEV2ZW50fFRvdWNoRXZlbnR9IGV2dFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlnbm9yZUJvb3N0ZWRBbmNob3JDdHJsQ2xpY2soZWx0LCBldnQpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxEYXRhKGVsdCkuYm9vc3RlZCAmJiBlbHQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCAmJiBldnQudHlwZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIHdpbGwgcmVzb2x2ZSB0byB1bmRlZmluZWQgZm9yIGV2ZW50cyB0aGF0IGRvbid0IGRlZmluZSB0aG9zZSBwcm9wZXJ0aWVzLCB3aGljaCBpcyBmaW5lXG4gICAgICAoZXZ0LmN0cmxLZXkgfHwgZXZ0Lm1ldGFLZXkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIdG14VHJpZ2dlclNwZWNpZmljYXRpb259IHRyaWdnZXJTcGVjXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWx0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIG1heWJlRmlsdGVyRXZlbnQodHJpZ2dlclNwZWMsIGVsdCwgZXZ0KSB7XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSB0cmlnZ2VyU3BlYy5ldmVudEZpbHRlclxuICAgIGlmIChldmVudEZpbHRlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV2ZW50RmlsdGVyLmNhbGwoZWx0LCBldnQpICE9PSB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGV2ZW50RmlsdGVyLnNvdXJjZVxuICAgICAgICB0cmlnZ2VyRXJyb3JFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14OmV2ZW50RmlsdGVyOmVycm9yJywgeyBlcnJvcjogZSwgc291cmNlIH0pXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gZWx0XG4gICAqIEBwYXJhbSB7VHJpZ2dlckhhbmRsZXJ9IGhhbmRsZXJcbiAgICogQHBhcmFtIHtIdG14Tm9kZUludGVybmFsRGF0YX0gbm9kZURhdGFcbiAgICogQHBhcmFtIHtIdG14VHJpZ2dlclNwZWNpZmljYXRpb259IHRyaWdnZXJTcGVjXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cGxpY2l0Q2FuY2VsXVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbHQsIGhhbmRsZXIsIG5vZGVEYXRhLCB0cmlnZ2VyU3BlYywgZXhwbGljaXRDYW5jZWwpIHtcbiAgICBjb25zdCBlbGVtZW50RGF0YSA9IGdldEludGVybmFsRGF0YShlbHQpXG4gICAgLyoqIEB0eXBlIHsoTm9kZXxXaW5kb3cpW119ICovXG4gICAgbGV0IGVsdHNUb0xpc3Rlbk9uXG4gICAgaWYgKHRyaWdnZXJTcGVjLmZyb20pIHtcbiAgICAgIGVsdHNUb0xpc3Rlbk9uID0gcXVlcnlTZWxlY3RvckFsbEV4dChlbHQsIHRyaWdnZXJTcGVjLmZyb20pXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdHNUb0xpc3Rlbk9uID0gW2VsdF1cbiAgICB9XG4gICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgdmFsdWVzIG9mIHRoZSBlbGVtZW50cywgc28gd2UgY2FuIHRlbGwgaWYgdGhleSBjaGFuZ2VcbiAgICBpZiAodHJpZ2dlclNwZWMuY2hhbmdlZCkge1xuICAgICAgaWYgKCEoJ2xhc3RWYWx1ZScgaW4gZWxlbWVudERhdGEpKSB7XG4gICAgICAgIGVsZW1lbnREYXRhLmxhc3RWYWx1ZSA9IG5ldyBXZWFrTWFwKClcbiAgICAgIH1cbiAgICAgIGVsdHNUb0xpc3Rlbk9uLmZvckVhY2goZnVuY3Rpb24oZWx0VG9MaXN0ZW5Pbikge1xuICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmxhc3RWYWx1ZS5oYXModHJpZ2dlclNwZWMpKSB7XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdFZhbHVlLnNldCh0cmlnZ2VyU3BlYywgbmV3IFdlYWtNYXAoKSlcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIHZhbHVlIHdpbGwgYmUgdW5kZWZpbmVkIGZvciBub24taW5wdXQgZWxlbWVudHMsIHdoaWNoIGlzIGZpbmVcbiAgICAgICAgZWxlbWVudERhdGEubGFzdFZhbHVlLmdldCh0cmlnZ2VyU3BlYykuc2V0KGVsdFRvTGlzdGVuT24sIGVsdFRvTGlzdGVuT24udmFsdWUpXG4gICAgICB9KVxuICAgIH1cbiAgICBmb3JFYWNoKGVsdHNUb0xpc3Rlbk9uLCBmdW5jdGlvbihlbHRUb0xpc3Rlbk9uKSB7XG4gICAgICAvKiogQHR5cGUgRXZlbnRMaXN0ZW5lciAqL1xuICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIWJvZHlDb250YWlucyhlbHQpKSB7XG4gICAgICAgICAgZWx0VG9MaXN0ZW5Pbi5yZW1vdmVFdmVudExpc3RlbmVyKHRyaWdnZXJTcGVjLnRyaWdnZXIsIGV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlnbm9yZUJvb3N0ZWRBbmNob3JDdHJsQ2xpY2soZWx0LCBldnQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGxpY2l0Q2FuY2VsIHx8IHNob3VsZENhbmNlbChldnQsIGVsdCkpIHtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZUZpbHRlckV2ZW50KHRyaWdnZXJTcGVjLCBlbHQsIGV2dCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudERhdGEgPSBnZXRJbnRlcm5hbERhdGEoZXZ0KVxuICAgICAgICBldmVudERhdGEudHJpZ2dlclNwZWMgPSB0cmlnZ2VyU3BlY1xuICAgICAgICBpZiAoZXZlbnREYXRhLmhhbmRsZWRGb3IgPT0gbnVsbCkge1xuICAgICAgICAgIGV2ZW50RGF0YS5oYW5kbGVkRm9yID0gW11cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnREYXRhLmhhbmRsZWRGb3IuaW5kZXhPZihlbHQpIDwgMCkge1xuICAgICAgICAgIGV2ZW50RGF0YS5oYW5kbGVkRm9yLnB1c2goZWx0KVxuICAgICAgICAgIGlmICh0cmlnZ2VyU3BlYy5jb25zdW1lKSB7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyaWdnZXJTcGVjLnRhcmdldCAmJiBldnQudGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMoYXNFbGVtZW50KGV2dC50YXJnZXQpLCB0cmlnZ2VyU3BlYy50YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJpZ2dlclNwZWMub25jZSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnRyaWdnZXJlZE9uY2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50RGF0YS50cmlnZ2VyZWRPbmNlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHJpZ2dlclNwZWMuY2hhbmdlZCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGV2ZW50LnRhcmdldFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB2YWx1ZSB3aWxsIGJlIHVuZGVmaW5lZCBmb3Igbm9uLWlucHV0IGVsZW1lbnRzLCB3aGljaCBpcyBmaW5lXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWVcbiAgICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGVsZW1lbnREYXRhLmxhc3RWYWx1ZS5nZXQodHJpZ2dlclNwZWMpXG4gICAgICAgICAgICBpZiAobGFzdFZhbHVlLmhhcyhub2RlKSAmJiBsYXN0VmFsdWUuZ2V0KG5vZGUpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RWYWx1ZS5zZXQobm9kZSwgdmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5kZWxheWVkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZWxlbWVudERhdGEuZGVsYXllZClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLnRocm90dGxlKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJpZ2dlclNwZWMudGhyb3R0bGUgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLnRocm90dGxlKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXJFdmVudChlbHQsICdodG14OnRyaWdnZXInKVxuICAgICAgICAgICAgICBoYW5kbGVyKGVsdCwgZXZ0KVxuICAgICAgICAgICAgICBlbGVtZW50RGF0YS50aHJvdHRsZSA9IGdldFdpbmRvdygpLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudERhdGEudGhyb3R0bGUgPSBudWxsXG4gICAgICAgICAgICAgIH0sIHRyaWdnZXJTcGVjLnRocm90dGxlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlclNwZWMuZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5kZWxheWVkID0gZ2V0V2luZG93KCkuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6dHJpZ2dlcicpXG4gICAgICAgICAgICAgIGhhbmRsZXIoZWx0LCBldnQpXG4gICAgICAgICAgICB9LCB0cmlnZ2VyU3BlYy5kZWxheSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6dHJpZ2dlcicpXG4gICAgICAgICAgICBoYW5kbGVyKGVsdCwgZXZ0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEYXRhLmxpc3RlbmVySW5mb3MgPT0gbnVsbCkge1xuICAgICAgICBub2RlRGF0YS5saXN0ZW5lckluZm9zID0gW11cbiAgICAgIH1cbiAgICAgIG5vZGVEYXRhLmxpc3RlbmVySW5mb3MucHVzaCh7XG4gICAgICAgIHRyaWdnZXI6IHRyaWdnZXJTcGVjLnRyaWdnZXIsXG4gICAgICAgIGxpc3RlbmVyOiBldmVudExpc3RlbmVyLFxuICAgICAgICBvbjogZWx0VG9MaXN0ZW5PblxuICAgICAgfSlcbiAgICAgIGVsdFRvTGlzdGVuT24uYWRkRXZlbnRMaXN0ZW5lcih0cmlnZ2VyU3BlYy50cmlnZ2VyLCBldmVudExpc3RlbmVyKVxuICAgIH0pXG4gIH1cblxuICBsZXQgd2luZG93SXNTY3JvbGxpbmcgPSBmYWxzZSAvLyB1c2VkIGJ5IGluaXRTY3JvbGxIYW5kbGVyXG4gIGxldCBzY3JvbGxIYW5kbGVyID0gbnVsbFxuICBmdW5jdGlvbiBpbml0U2Nyb2xsSGFuZGxlcigpIHtcbiAgICBpZiAoIXNjcm9sbEhhbmRsZXIpIHtcbiAgICAgIHNjcm9sbEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93SXNTY3JvbGxpbmcgPSB0cnVlXG4gICAgICB9XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc2Nyb2xsSGFuZGxlcilcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzY3JvbGxIYW5kbGVyKVxuICAgICAgc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3dJc1Njcm9sbGluZykge1xuICAgICAgICAgIHdpbmRvd0lzU2Nyb2xsaW5nID0gZmFsc2VcbiAgICAgICAgICBmb3JFYWNoKGdldERvY3VtZW50KCkucXVlcnlTZWxlY3RvckFsbChcIltoeC10cmlnZ2VyKj0ncmV2ZWFsZWQnXSxbZGF0YS1oeC10cmlnZ2VyKj0ncmV2ZWFsZWQnXVwiKSwgZnVuY3Rpb24oZWx0KSB7XG4gICAgICAgICAgICBtYXliZVJldmVhbChlbHQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSwgMjAwKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKi9cbiAgZnVuY3Rpb24gbWF5YmVSZXZlYWwoZWx0KSB7XG4gICAgaWYgKCFoYXNBdHRyaWJ1dGUoZWx0LCAnZGF0YS1oeC1yZXZlYWxlZCcpICYmIGlzU2Nyb2xsZWRJbnRvVmlldyhlbHQpKSB7XG4gICAgICBlbHQuc2V0QXR0cmlidXRlKCdkYXRhLWh4LXJldmVhbGVkJywgJ3RydWUnKVxuICAgICAgY29uc3Qgbm9kZURhdGEgPSBnZXRJbnRlcm5hbERhdGEoZWx0KVxuICAgICAgaWYgKG5vZGVEYXRhLmluaXRIYXNoKSB7XG4gICAgICAgIHRyaWdnZXJFdmVudChlbHQsICdyZXZlYWxlZCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgbm9kZSBpc24ndCBpbml0aWFsaXplZCwgd2FpdCBmb3IgaXQgYmVmb3JlIHRyaWdnZXJpbmcgdGhlIHJlcXVlc3RcbiAgICAgICAgZWx0LmFkZEV2ZW50TGlzdGVuZXIoJ2h0bXg6YWZ0ZXJQcm9jZXNzTm9kZScsIGZ1bmN0aW9uKCkgeyB0cmlnZ2VyRXZlbnQoZWx0LCAncmV2ZWFsZWQnKSB9LCB7IG9uY2U6IHRydWUgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLz0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge1RyaWdnZXJIYW5kbGVyfSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7SHRteE5vZGVJbnRlcm5hbERhdGF9IG5vZGVEYXRhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheVxuICAgKi9cbiAgZnVuY3Rpb24gbG9hZEltbWVkaWF0ZWx5KGVsdCwgaGFuZGxlciwgbm9kZURhdGEsIGRlbGF5KSB7XG4gICAgY29uc3QgbG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFub2RlRGF0YS5sb2FkZWQpIHtcbiAgICAgICAgbm9kZURhdGEubG9hZGVkID0gdHJ1ZVxuICAgICAgICBoYW5kbGVyKGVsdClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgZ2V0V2luZG93KCkuc2V0VGltZW91dChsb2FkLCBkZWxheSlcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEBwYXJhbSB7SHRteE5vZGVJbnRlcm5hbERhdGF9IG5vZGVEYXRhXG4gICAqIEBwYXJhbSB7SHRteFRyaWdnZXJTcGVjaWZpY2F0aW9uW119IHRyaWdnZXJTcGVjc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NWZXJicyhlbHQsIG5vZGVEYXRhLCB0cmlnZ2VyU3BlY3MpIHtcbiAgICBsZXQgZXhwbGljaXRBY3Rpb24gPSBmYWxzZVxuICAgIGZvckVhY2goVkVSQlMsIGZ1bmN0aW9uKHZlcmIpIHtcbiAgICAgIGlmIChoYXNBdHRyaWJ1dGUoZWx0LCAnaHgtJyArIHZlcmIpKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBnZXRBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC0nICsgdmVyYilcbiAgICAgICAgZXhwbGljaXRBY3Rpb24gPSB0cnVlXG4gICAgICAgIG5vZGVEYXRhLnBhdGggPSBwYXRoXG4gICAgICAgIG5vZGVEYXRhLnZlcmIgPSB2ZXJiXG4gICAgICAgIHRyaWdnZXJTcGVjcy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWdnZXJTcGVjKSB7XG4gICAgICAgICAgYWRkVHJpZ2dlckhhbmRsZXIoZWx0LCB0cmlnZ2VyU3BlYywgbm9kZURhdGEsIGZ1bmN0aW9uKG5vZGUsIGV2dCkge1xuICAgICAgICAgICAgY29uc3QgZWx0ID0gYXNFbGVtZW50KG5vZGUpXG4gICAgICAgICAgICBpZiAoY2xvc2VzdChlbHQsIGh0bXguY29uZmlnLmRpc2FibGVTZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgY2xlYW5VcEVsZW1lbnQoZWx0KVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzc3VlQWpheFJlcXVlc3QodmVyYiwgcGF0aCwgZWx0LCBldnQpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBleHBsaWNpdEFjdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBUcmlnZ2VySGFuZGxlclxuICAgKiBAcGFyYW0ge05vZGV9IGVsdFxuICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZ0XVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBlbHRcbiAgICogQHBhcmFtIHtIdG14VHJpZ2dlclNwZWNpZmljYXRpb259IHRyaWdnZXJTcGVjXG4gICAqIEBwYXJhbSB7SHRteE5vZGVJbnRlcm5hbERhdGF9IG5vZGVEYXRhXG4gICAqIEBwYXJhbSB7VHJpZ2dlckhhbmRsZXJ9IGhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIGFkZFRyaWdnZXJIYW5kbGVyKGVsdCwgdHJpZ2dlclNwZWMsIG5vZGVEYXRhLCBoYW5kbGVyKSB7XG4gICAgaWYgKHRyaWdnZXJTcGVjLnRyaWdnZXIgPT09ICdyZXZlYWxlZCcpIHtcbiAgICAgIGluaXRTY3JvbGxIYW5kbGVyKClcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWx0LCBoYW5kbGVyLCBub2RlRGF0YSwgdHJpZ2dlclNwZWMpXG4gICAgICBtYXliZVJldmVhbChhc0VsZW1lbnQoZWx0KSlcbiAgICB9IGVsc2UgaWYgKHRyaWdnZXJTcGVjLnRyaWdnZXIgPT09ICdpbnRlcnNlY3QnKSB7XG4gICAgICBjb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7fVxuICAgICAgaWYgKHRyaWdnZXJTcGVjLnJvb3QpIHtcbiAgICAgICAgb2JzZXJ2ZXJPcHRpb25zLnJvb3QgPSBxdWVyeVNlbGVjdG9yRXh0KGVsdCwgdHJpZ2dlclNwZWMucm9vdClcbiAgICAgIH1cbiAgICAgIGlmICh0cmlnZ2VyU3BlYy50aHJlc2hvbGQpIHtcbiAgICAgICAgb2JzZXJ2ZXJPcHRpb25zLnRocmVzaG9sZCA9IHBhcnNlRmxvYXQodHJpZ2dlclNwZWMudGhyZXNob2xkKVxuICAgICAgfVxuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaV1cbiAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChlbHQsICdpbnRlcnNlY3QnKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIG9ic2VydmVyT3B0aW9ucylcbiAgICAgIG9ic2VydmVyLm9ic2VydmUoYXNFbGVtZW50KGVsdCkpXG4gICAgICBhZGRFdmVudExpc3RlbmVyKGFzRWxlbWVudChlbHQpLCBoYW5kbGVyLCBub2RlRGF0YSwgdHJpZ2dlclNwZWMpXG4gICAgfSBlbHNlIGlmICh0cmlnZ2VyU3BlYy50cmlnZ2VyID09PSAnbG9hZCcpIHtcbiAgICAgIGlmICghbWF5YmVGaWx0ZXJFdmVudCh0cmlnZ2VyU3BlYywgZWx0LCBtYWtlRXZlbnQoJ2xvYWQnLCB7IGVsdCB9KSkpIHtcbiAgICAgICAgbG9hZEltbWVkaWF0ZWx5KGFzRWxlbWVudChlbHQpLCBoYW5kbGVyLCBub2RlRGF0YSwgdHJpZ2dlclNwZWMuZGVsYXkpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cmlnZ2VyU3BlYy5wb2xsSW50ZXJ2YWwgPiAwKSB7XG4gICAgICBub2RlRGF0YS5wb2xsaW5nID0gdHJ1ZVxuICAgICAgcHJvY2Vzc1BvbGxpbmcoYXNFbGVtZW50KGVsdCksIGhhbmRsZXIsIHRyaWdnZXJTcGVjKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGVsdCwgaGFuZGxlciwgbm9kZURhdGEsIHRyaWdnZXJTcGVjKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBzaG91bGRQcm9jZXNzSHhPbihub2RlKSB7XG4gICAgY29uc3QgZWx0ID0gYXNFbGVtZW50KG5vZGUpXG4gICAgaWYgKCFlbHQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZWx0LmF0dHJpYnV0ZXNcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0gYXR0cmlidXRlc1tqXS5uYW1lXG4gICAgICBpZiAoc3RhcnRzV2l0aChhdHRyTmFtZSwgJ2h4LW9uOicpIHx8IHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdkYXRhLWh4LW9uOicpIHx8XG4gICAgICAgIHN0YXJ0c1dpdGgoYXR0ck5hbWUsICdoeC1vbi0nKSB8fCBzdGFydHNXaXRoKGF0dHJOYW1lLCAnZGF0YS1oeC1vbi0nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IGVsdFxuICAgKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICAgKi9cbiAgY29uc3QgSFhfT05fUVVFUlkgPSBuZXcgWFBhdGhFdmFsdWF0b3IoKVxuICAgIC5jcmVhdGVFeHByZXNzaW9uKCcuLy8qW0AqWyBzdGFydHMtd2l0aChuYW1lKCksIFwiaHgtb246XCIpIG9yIHN0YXJ0cy13aXRoKG5hbWUoKSwgXCJkYXRhLWh4LW9uOlwiKSBvcicgK1xuICAgICAgJyBzdGFydHMtd2l0aChuYW1lKCksIFwiaHgtb24tXCIpIG9yIHN0YXJ0cy13aXRoKG5hbWUoKSwgXCJkYXRhLWh4LW9uLVwiKSBdXScpXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0hYT25Sb290KGVsdCwgZWxlbWVudHMpIHtcbiAgICBpZiAoc2hvdWxkUHJvY2Vzc0h4T24oZWx0KSkge1xuICAgICAgZWxlbWVudHMucHVzaChhc0VsZW1lbnQoZWx0KSlcbiAgICB9XG4gICAgY29uc3QgaXRlciA9IEhYX09OX1FVRVJZLmV2YWx1YXRlKGVsdClcbiAgICBsZXQgbm9kZSA9IG51bGxcbiAgICB3aGlsZSAobm9kZSA9IGl0ZXIuaXRlcmF0ZU5leHQoKSkgZWxlbWVudHMucHVzaChhc0VsZW1lbnQobm9kZSkpXG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSHhPbldpbGRjYXJkRWxlbWVudHMoZWx0KSB7XG4gICAgLyoqIEB0eXBlIHtFbGVtZW50W119ICovXG4gICAgY29uc3QgZWxlbWVudHMgPSBbXVxuICAgIGlmIChlbHQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGVsdC5jaGlsZE5vZGVzKSB7XG4gICAgICAgIHByb2Nlc3NIWE9uUm9vdChjaGlsZCwgZWxlbWVudHMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NIWE9uUm9vdChlbHQsIGVsZW1lbnRzKVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcmV0dXJucyB7Tm9kZUxpc3RPZjxFbGVtZW50PnxbXX1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRFbGVtZW50c1RvUHJvY2VzcyhlbHQpIHtcbiAgICBpZiAoZWx0LnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICAgIGNvbnN0IGJvb3N0ZWRTZWxlY3RvciA9ICcsIFtoeC1ib29zdF0gYSwgW2RhdGEtaHgtYm9vc3RdIGEsIGFbaHgtYm9vc3RdLCBhW2RhdGEtaHgtYm9vc3RdJ1xuXG4gICAgICBjb25zdCBleHRlbnNpb25TZWxlY3RvcnMgPSBbXVxuICAgICAgZm9yIChjb25zdCBlIGluIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tlXVxuICAgICAgICBpZiAoZXh0ZW5zaW9uLmdldFNlbGVjdG9ycykge1xuICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSBleHRlbnNpb24uZ2V0U2VsZWN0b3JzKClcbiAgICAgICAgICBpZiAoc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICBleHRlbnNpb25TZWxlY3RvcnMucHVzaChzZWxlY3RvcnMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBlbHQucXVlcnlTZWxlY3RvckFsbChWRVJCX1NFTEVDVE9SICsgYm9vc3RlZFNlbGVjdG9yICsgXCIsIGZvcm0sIFt0eXBlPSdzdWJtaXQnXSxcIiArXG4gICAgICAgICcgW2h4LWV4dF0sIFtkYXRhLWh4LWV4dF0sIFtoeC10cmlnZ2VyXSwgW2RhdGEtaHgtdHJpZ2dlcl0nICsgZXh0ZW5zaW9uU2VsZWN0b3JzLmZsYXQoKS5tYXAocyA9PiAnLCAnICsgcykuam9pbignJykpXG5cbiAgICAgIHJldHVybiByZXN1bHRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgc3VibWl0IGJ1dHRvbnMvaW5wdXRzIHRoYXQgaGF2ZSB0aGUgZm9ybSBhdHRyaWJ1dGUgc2V0XG4gICAqIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvYnV0dG9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgKi9cbiAgZnVuY3Rpb24gbWF5YmVTZXRMYXN0QnV0dG9uQ2xpY2tlZChldnQpIHtcbiAgICBjb25zdCBlbHQgPSAvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fEhUTUxJbnB1dEVsZW1lbnR9ICovIChjbG9zZXN0KGFzRWxlbWVudChldnQudGFyZ2V0KSwgXCJidXR0b24sIGlucHV0W3R5cGU9J3N1Ym1pdCddXCIpKVxuICAgIGNvbnN0IGludGVybmFsRGF0YSA9IGdldFJlbGF0ZWRGb3JtRGF0YShldnQpXG4gICAgaWYgKGludGVybmFsRGF0YSkge1xuICAgICAgaW50ZXJuYWxEYXRhLmxhc3RCdXR0b25DbGlja2VkID0gZWx0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgKi9cbiAgZnVuY3Rpb24gbWF5YmVVbnNldExhc3RCdXR0b25DbGlja2VkKGV2dCkge1xuICAgIGNvbnN0IGludGVybmFsRGF0YSA9IGdldFJlbGF0ZWRGb3JtRGF0YShldnQpXG4gICAgaWYgKGludGVybmFsRGF0YSkge1xuICAgICAgaW50ZXJuYWxEYXRhLmxhc3RCdXR0b25DbGlja2VkID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICogQHJldHVybnMge0h0bXhOb2RlSW50ZXJuYWxEYXRhfHVuZGVmaW5lZH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlbGF0ZWRGb3JtRGF0YShldnQpIHtcbiAgICBjb25zdCBlbHQgPSBjbG9zZXN0KGFzRWxlbWVudChldnQudGFyZ2V0KSwgXCJidXR0b24sIGlucHV0W3R5cGU9J3N1Ym1pdCddXCIpXG4gICAgaWYgKCFlbHQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBmb3JtID0gcmVzb2x2ZVRhcmdldCgnIycgKyBnZXRSYXdBdHRyaWJ1dGUoZWx0LCAnZm9ybScpLCBlbHQuZ2V0Um9vdE5vZGUoKSkgfHwgY2xvc2VzdChlbHQsICdmb3JtJylcbiAgICBpZiAoIWZvcm0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxEYXRhKGZvcm0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWx0XG4gICAqL1xuICBmdW5jdGlvbiBpbml0QnV0dG9uVHJhY2tpbmcoZWx0KSB7XG4gICAgLy8gbmVlZCB0byBoYW5kbGUgYm90aCBjbGljayBhbmQgZm9jdXMgaW46XG4gICAgLy8gICBmb2N1c2luIC0gaW4gY2FzZSBzb21lb25lIHRhYnMgaW4gdG8gYSBidXR0b24gYW5kIGhpdHMgdGhlIHNwYWNlIGJhclxuICAgIC8vICAgY2xpY2sgLSBvbiBPU1ggYnV0dG9ucyBkbyBub3QgZm9jdXMgb24gY2xpY2sgc2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzcyNFxuICAgIGVsdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG1heWJlU2V0TGFzdEJ1dHRvbkNsaWNrZWQpXG4gICAgZWx0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBtYXliZVNldExhc3RCdXR0b25DbGlja2VkKVxuICAgIGVsdC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG1heWJlVW5zZXRMYXN0QnV0dG9uQ2xpY2tlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqL1xuICBmdW5jdGlvbiBhZGRIeE9uRXZlbnRIYW5kbGVyKGVsdCwgZXZlbnROYW1lLCBjb2RlKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBnZXRJbnRlcm5hbERhdGEoZWx0KVxuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlRGF0YS5vbkhhbmRsZXJzKSkge1xuICAgICAgbm9kZURhdGEub25IYW5kbGVycyA9IFtdXG4gICAgfVxuICAgIGxldCBmdW5jXG4gICAgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi9cbiAgICBjb25zdCBsaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIG1heWJlRXZhbChlbHQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZWx0SXNEaXNhYmxlZChlbHQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdW5jKSB7XG4gICAgICAgICAgZnVuYyA9IG5ldyBGdW5jdGlvbignZXZlbnQnLCBjb2RlKVxuICAgICAgICB9XG4gICAgICAgIGZ1bmMuY2FsbChlbHQsIGUpXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKVxuICAgIG5vZGVEYXRhLm9uSGFuZGxlcnMucHVzaCh7IGV2ZW50OiBldmVudE5hbWUsIGxpc3RlbmVyIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NIeE9uV2lsZGNhcmQoZWx0KSB7XG4gICAgLy8gd2lwZSBhbnkgcHJldmlvdXMgb24gaGFuZGxlcnMgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIHRha2VzIHByZWNlZGVuY2VcbiAgICBkZUluaXRPbkhhbmRsZXJzKGVsdClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWx0LmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBlbHQuYXR0cmlidXRlc1tpXS5uYW1lXG4gICAgICBjb25zdCB2YWx1ZSA9IGVsdC5hdHRyaWJ1dGVzW2ldLnZhbHVlXG4gICAgICBpZiAoc3RhcnRzV2l0aChuYW1lLCAnaHgtb24nKSB8fCBzdGFydHNXaXRoKG5hbWUsICdkYXRhLWh4LW9uJykpIHtcbiAgICAgICAgY29uc3QgYWZ0ZXJPblBvc2l0aW9uID0gbmFtZS5pbmRleE9mKCctb24nKSArIDNcbiAgICAgICAgY29uc3QgbmV4dENoYXIgPSBuYW1lLnNsaWNlKGFmdGVyT25Qb3NpdGlvbiwgYWZ0ZXJPblBvc2l0aW9uICsgMSlcbiAgICAgICAgaWYgKG5leHRDaGFyID09PSAnLScgfHwgbmV4dENoYXIgPT09ICc6Jykge1xuICAgICAgICAgIGxldCBldmVudE5hbWUgPSBuYW1lLnNsaWNlKGFmdGVyT25Qb3NpdGlvbiArIDEpXG4gICAgICAgICAgLy8gaWYgdGhlIGV2ZW50TmFtZSBzdGFydHMgd2l0aCBhIGNvbG9uIG9yIGRhc2gsIHByZXBlbmQgXCJodG14XCIgZm9yIHNob3J0aGFuZCBzdXBwb3J0XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGgoZXZlbnROYW1lLCAnOicpKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSAnaHRteCcgKyBldmVudE5hbWVcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgoZXZlbnROYW1lLCAnLScpKSB7XG4gICAgICAgICAgICBldmVudE5hbWUgPSAnaHRteDonICsgZXZlbnROYW1lLnNsaWNlKDEpXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKGV2ZW50TmFtZSwgJ2h0bXgtJykpIHtcbiAgICAgICAgICAgIGV2ZW50TmFtZSA9ICdodG14OicgKyBldmVudE5hbWUuc2xpY2UoNSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRIeE9uRXZlbnRIYW5kbGVyKGVsdCwgZXZlbnROYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8SFRNTElucHV0RWxlbWVudH0gZWx0XG4gICAqL1xuICBmdW5jdGlvbiBpbml0Tm9kZShlbHQpIHtcbiAgICBpZiAoY2xvc2VzdChlbHQsIGh0bXguY29uZmlnLmRpc2FibGVTZWxlY3RvcikpIHtcbiAgICAgIGNsZWFuVXBFbGVtZW50KGVsdClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBub2RlRGF0YSA9IGdldEludGVybmFsRGF0YShlbHQpXG4gICAgaWYgKG5vZGVEYXRhLmluaXRIYXNoICE9PSBhdHRyaWJ1dGVIYXNoKGVsdCkpIHtcbiAgICAgIC8vIGNsZWFuIHVwIGFueSBwcmV2aW91c2x5IHByb2Nlc3NlZCBpbmZvXG4gICAgICBkZUluaXROb2RlKGVsdClcblxuICAgICAgbm9kZURhdGEuaW5pdEhhc2ggPSBhdHRyaWJ1dGVIYXNoKGVsdClcblxuICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6YmVmb3JlUHJvY2Vzc05vZGUnKVxuXG4gICAgICBjb25zdCB0cmlnZ2VyU3BlY3MgPSBnZXRUcmlnZ2VyU3BlY3MoZWx0KVxuICAgICAgY29uc3QgaGFzRXhwbGljaXRIdHRwQWN0aW9uID0gcHJvY2Vzc1ZlcmJzKGVsdCwgbm9kZURhdGEsIHRyaWdnZXJTcGVjcylcblxuICAgICAgaWYgKCFoYXNFeHBsaWNpdEh0dHBBY3Rpb24pIHtcbiAgICAgICAgaWYgKGdldENsb3Nlc3RBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC1ib29zdCcpID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBib29zdEVsZW1lbnQoZWx0LCBub2RlRGF0YSwgdHJpZ2dlclNwZWNzKVxuICAgICAgICB9IGVsc2UgaWYgKGhhc0F0dHJpYnV0ZShlbHQsICdoeC10cmlnZ2VyJykpIHtcbiAgICAgICAgICB0cmlnZ2VyU3BlY3MuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyU3BlYykge1xuICAgICAgICAgICAgLy8gRm9yIFwibmFrZWRcIiB0cmlnZ2VycywgZG9uJ3QgZG8gYW55dGhpbmcgYXQgYWxsXG4gICAgICAgICAgICBhZGRUcmlnZ2VySGFuZGxlcihlbHQsIHRyaWdnZXJTcGVjLCBub2RlRGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIHN1Ym1pdCBidXR0b25zL2lucHV0cyB0aGF0IGhhdmUgdGhlIGZvcm0gYXR0cmlidXRlIHNldFxuICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9idXR0b25cbiAgICAgIGlmIChlbHQudGFnTmFtZSA9PT0gJ0ZPUk0nIHx8IChnZXRSYXdBdHRyaWJ1dGUoZWx0LCAndHlwZScpID09PSAnc3VibWl0JyAmJiBoYXNBdHRyaWJ1dGUoZWx0LCAnZm9ybScpKSkge1xuICAgICAgICBpbml0QnV0dG9uVHJhY2tpbmcoZWx0KVxuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnQoZWx0LCAnaHRteDphZnRlclByb2Nlc3NOb2RlJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIG5ldyBjb250ZW50LCBlbmFibGluZyBodG14IGJlaGF2aW9yLiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgeW91IGhhdmUgY29udGVudCB0aGF0IGlzIGFkZGVkIHRvIHRoZSBET00gb3V0c2lkZSBvZiB0aGUgbm9ybWFsIGh0bXggcmVxdWVzdCBjeWNsZSBidXQgc3RpbGwgd2FudCBodG14IGF0dHJpYnV0ZXMgdG8gd29yay5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bXgub3JnL2FwaS8jcHJvY2Vzc1xuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbHQgZWxlbWVudCB0byBwcm9jZXNzXG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzTm9kZShlbHQpIHtcbiAgICBlbHQgPSByZXNvbHZlVGFyZ2V0KGVsdClcbiAgICBpZiAoY2xvc2VzdChlbHQsIGh0bXguY29uZmlnLmRpc2FibGVTZWxlY3RvcikpIHtcbiAgICAgIGNsZWFuVXBFbGVtZW50KGVsdClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpbml0Tm9kZShlbHQpXG4gICAgZm9yRWFjaChmaW5kRWxlbWVudHNUb1Byb2Nlc3MoZWx0KSwgZnVuY3Rpb24oY2hpbGQpIHsgaW5pdE5vZGUoY2hpbGQpIH0pXG4gICAgZm9yRWFjaChmaW5kSHhPbldpbGRjYXJkRWxlbWVudHMoZWx0KSwgcHJvY2Vzc0h4T25XaWxkY2FyZClcbiAgfVxuXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEV2ZW50L0xvZyBTdXBwb3J0XG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGtlYmFiRXZlbnROYW1lKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHthbnl9IGRldGFpbFxuICAgKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnR9XG4gICAqL1xuICBmdW5jdGlvbiBtYWtlRXZlbnQoZXZlbnROYW1lLCBkZXRhaWwpIHtcbiAgICBsZXQgZXZ0XG4gICAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiB0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUT0RPOiBgY29tcG9zZWQ6IHRydWVgIGhlcmUgaXMgYSBoYWNrIHRvIG1ha2UgZ2xvYmFsIGV2ZW50IGhhbmRsZXJzIHdvcmsgd2l0aCBldmVudHMgaW4gc2hhZG93IERPTVxuICAgICAgLy8gVGhpcyBicmVha3MgZXhwZWN0ZWQgZW5jYXBzdWxhdGlvbiBidXQgbmVlZHMgdG8gYmUgaGVyZSB1bnRpbCBkZWNpZGVkIG90aGVyd2lzZSBieSBjb3JlIGRldnNcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgY29tcG9zZWQ6IHRydWUsIGRldGFpbCB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBnZXREb2N1bWVudCgpLmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgZGV0YWlsKVxuICAgIH1cbiAgICByZXR1cm4gZXZ0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldHxzdHJpbmd9IGVsdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7YW55PX0gZGV0YWlsXG4gICAqL1xuICBmdW5jdGlvbiB0cmlnZ2VyRXJyb3JFdmVudChlbHQsIGV2ZW50TmFtZSwgZGV0YWlsKSB7XG4gICAgdHJpZ2dlckV2ZW50KGVsdCwgZXZlbnROYW1lLCBtZXJnZU9iamVjdHMoeyBlcnJvcjogZXZlbnROYW1lIH0sIGRldGFpbCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlnbm9yZUV2ZW50Rm9yTG9nZ2luZyhldmVudE5hbWUpIHtcbiAgICByZXR1cm4gZXZlbnROYW1lID09PSAnaHRteDphZnRlclByb2Nlc3NOb2RlJ1xuICB9XG5cbiAgLyoqXG4gICAqIGB3aXRoRXh0ZW5zaW9uc2AgbG9jYXRlcyBhbGwgYWN0aXZlIGV4dGVuc2lvbnMgZm9yIGEgcHJvdmlkZWQgZWxlbWVudCwgdGhlblxuICAgKiBleGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gdXNpbmcgZWFjaCBvZiB0aGUgYWN0aXZlIGV4dGVuc2lvbnMuICBJdCBzaG91bGRcbiAgICogYmUgY2FsbGVkIGludGVybmFsbHkgYXQgZXZlcnkgZXh0ZW5kYWJsZSBleGVjdXRpb24gcG9pbnQgaW4gaHRteC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHBhcmFtIHsoZXh0ZW5zaW9uOkh0bXhFeHRlbnNpb24pID0+IHZvaWR9IHRvRG9cbiAgICogQHJldHVybnMgdm9pZFxuICAgKi9cbiAgZnVuY3Rpb24gd2l0aEV4dGVuc2lvbnMoZWx0LCB0b0RvKSB7XG4gICAgZm9yRWFjaChnZXRFeHRlbnNpb25zKGVsdCksIGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdG9EbyhleHRlbnNpb24pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ0Vycm9yKGUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvZ0Vycm9yKG1zZykge1xuICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1zZylcbiAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICBjb25zb2xlLmxvZygnRVJST1I6ICcsIG1zZylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSBnaXZlbiBldmVudCBvbiBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9odG14Lm9yZy9hcGkvI3RyaWdnZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldHxzdHJpbmd9IGVsdCB0aGUgZWxlbWVudCB0byB0cmlnZ2VyIHRoZSBldmVudCBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7YW55PX0gZGV0YWlsIGRldGFpbHMgZm9yIHRoZSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChlbHQsIGV2ZW50TmFtZSwgZGV0YWlsKSB7XG4gICAgZWx0ID0gcmVzb2x2ZVRhcmdldChlbHQpXG4gICAgaWYgKGRldGFpbCA9PSBudWxsKSB7XG4gICAgICBkZXRhaWwgPSB7fVxuICAgIH1cbiAgICBkZXRhaWwuZWx0ID0gZWx0XG4gICAgY29uc3QgZXZlbnQgPSBtYWtlRXZlbnQoZXZlbnROYW1lLCBkZXRhaWwpXG4gICAgaWYgKGh0bXgubG9nZ2VyICYmICFpZ25vcmVFdmVudEZvckxvZ2dpbmcoZXZlbnROYW1lKSkge1xuICAgICAgaHRteC5sb2dnZXIoZWx0LCBldmVudE5hbWUsIGRldGFpbClcbiAgICB9XG4gICAgaWYgKGRldGFpbC5lcnJvcikge1xuICAgICAgbG9nRXJyb3IoZGV0YWlsLmVycm9yKVxuICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6ZXJyb3InLCB7IGVycm9ySW5mbzogZGV0YWlsIH0pXG4gICAgfVxuICAgIGxldCBldmVudFJlc3VsdCA9IGVsdC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgIGNvbnN0IGtlYmFiTmFtZSA9IGtlYmFiRXZlbnROYW1lKGV2ZW50TmFtZSlcbiAgICBpZiAoZXZlbnRSZXN1bHQgJiYga2ViYWJOYW1lICE9PSBldmVudE5hbWUpIHtcbiAgICAgIGNvbnN0IGtlYmFiZWRFdmVudCA9IG1ha2VFdmVudChrZWJhYk5hbWUsIGV2ZW50LmRldGFpbClcbiAgICAgIGV2ZW50UmVzdWx0ID0gZXZlbnRSZXN1bHQgJiYgZWx0LmRpc3BhdGNoRXZlbnQoa2ViYWJlZEV2ZW50KVxuICAgIH1cbiAgICB3aXRoRXh0ZW5zaW9ucyhhc0VsZW1lbnQoZWx0KSwgZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgICBldmVudFJlc3VsdCA9IGV2ZW50UmVzdWx0ICYmIChleHRlbnNpb24ub25FdmVudChldmVudE5hbWUsIGV2ZW50KSAhPT0gZmFsc2UgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgfSlcbiAgICByZXR1cm4gZXZlbnRSZXN1bHRcbiAgfVxuXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEhpc3RvcnkgU3VwcG9ydFxuICAvLz0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBsZXQgY3VycmVudFBhdGhGb3JIaXN0b3J5ID0gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2hcblxuICAvKipcbiAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRIaXN0b3J5RWxlbWVudCgpIHtcbiAgICBjb25zdCBoaXN0b3J5RWx0ID0gZ2V0RG9jdW1lbnQoKS5xdWVyeVNlbGVjdG9yKCdbaHgtaGlzdG9yeS1lbHRdLFtkYXRhLWh4LWhpc3RvcnktZWx0XScpXG4gICAgcmV0dXJuIGhpc3RvcnlFbHQgfHwgZ2V0RG9jdW1lbnQoKS5ib2R5XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHJvb3RFbHRcbiAgICovXG4gIGZ1bmN0aW9uIHNhdmVUb0hpc3RvcnlDYWNoZSh1cmwsIHJvb3RFbHQpIHtcbiAgICBpZiAoIWNhbkFjY2Vzc0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBnZXQgc3RhdGUgdG8gc2F2ZVxuICAgIGNvbnN0IGlubmVySFRNTCA9IGNsZWFuSW5uZXJIdG1sRm9ySGlzdG9yeShyb290RWx0KVxuICAgIGNvbnN0IHRpdGxlID0gZ2V0RG9jdW1lbnQoKS50aXRsZVxuICAgIGNvbnN0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZXG5cbiAgICBpZiAoaHRteC5jb25maWcuaGlzdG9yeUNhY2hlU2l6ZSA8PSAwKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBhbiBldmVudHVhbGx5IGFscmVhZHkgZXhpc3RpbmcgY2FjaGUgaXMgcHVyZ2VkXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnaHRteC1oaXN0b3J5LWNhY2hlJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHVybCA9IG5vcm1hbGl6ZVBhdGgodXJsKVxuXG4gICAgY29uc3QgaGlzdG9yeUNhY2hlID0gcGFyc2VKU09OKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdodG14LWhpc3RvcnktY2FjaGUnKSkgfHwgW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvcnlDYWNoZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhpc3RvcnlDYWNoZVtpXS51cmwgPT09IHVybCkge1xuICAgICAgICBoaXN0b3J5Q2FjaGUuc3BsaWNlKGksIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIEh0bXhIaXN0b3J5SXRlbSAqL1xuICAgIGNvbnN0IG5ld0hpc3RvcnlJdGVtID0geyB1cmwsIGNvbnRlbnQ6IGlubmVySFRNTCwgdGl0bGUsIHNjcm9sbCB9XG5cbiAgICB0cmlnZ2VyRXZlbnQoZ2V0RG9jdW1lbnQoKS5ib2R5LCAnaHRteDpoaXN0b3J5SXRlbUNyZWF0ZWQnLCB7IGl0ZW06IG5ld0hpc3RvcnlJdGVtLCBjYWNoZTogaGlzdG9yeUNhY2hlIH0pXG5cbiAgICBoaXN0b3J5Q2FjaGUucHVzaChuZXdIaXN0b3J5SXRlbSlcbiAgICB3aGlsZSAoaGlzdG9yeUNhY2hlLmxlbmd0aCA+IGh0bXguY29uZmlnLmhpc3RvcnlDYWNoZVNpemUpIHtcbiAgICAgIGhpc3RvcnlDYWNoZS5zaGlmdCgpXG4gICAgfVxuXG4gICAgLy8ga2VlcCB0cnlpbmcgdG8gc2F2ZSB0aGUgY2FjaGUgdW50aWwgaXQgc3VjY2VlZHMgb3IgaXMgZW1wdHlcbiAgICB3aGlsZSAoaGlzdG9yeUNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdodG14LWhpc3RvcnktY2FjaGUnLCBKU09OLnN0cmluZ2lmeShoaXN0b3J5Q2FjaGUpKVxuICAgICAgICBicmVha1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cmlnZ2VyRXJyb3JFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14Omhpc3RvcnlDYWNoZUVycm9yJywgeyBjYXVzZTogZSwgY2FjaGU6IGhpc3RvcnlDYWNoZSB9KVxuICAgICAgICBoaXN0b3J5Q2FjaGUuc2hpZnQoKSAvLyBzaHJpbmsgdGhlIGNhY2hlIGFuZCByZXRyeVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBIdG14SGlzdG9yeUl0ZW1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHVybFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29udGVudFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGl0bGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNjcm9sbFxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcmV0dXJucyB7SHRteEhpc3RvcnlJdGVtfG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRDYWNoZWRIaXN0b3J5KHVybCkge1xuICAgIGlmICghY2FuQWNjZXNzTG9jYWxTdG9yYWdlKCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdXJsID0gbm9ybWFsaXplUGF0aCh1cmwpXG5cbiAgICBjb25zdCBoaXN0b3J5Q2FjaGUgPSBwYXJzZUpTT04obG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2h0bXgtaGlzdG9yeS1jYWNoZScpKSB8fCBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGlzdG9yeUNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaGlzdG9yeUNhY2hlW2ldLnVybCA9PT0gdXJsKSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5Q2FjaGVbaV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYW5Jbm5lckh0bWxGb3JIaXN0b3J5KGVsdCkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGh0bXguY29uZmlnLnJlcXVlc3RDbGFzc1xuICAgIGNvbnN0IGNsb25lID0gLyoqIEB0eXBlIEVsZW1lbnQgKi8gKGVsdC5jbG9uZU5vZGUodHJ1ZSkpXG4gICAgZm9yRWFjaChmaW5kQWxsKGNsb25lLCAnLicgKyBjbGFzc05hbWUpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmVtb3ZlQ2xhc3NGcm9tRWxlbWVudChjaGlsZCwgY2xhc3NOYW1lKVxuICAgIH0pXG4gICAgLy8gcmVtb3ZlIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgZm9yIGFueSBlbGVtZW50IGRpc2FibGVkIGR1ZSB0byBhbiBodG14IHJlcXVlc3RcbiAgICBmb3JFYWNoKGZpbmRBbGwoY2xvbmUsICdbZGF0YS1kaXNhYmxlZC1ieS1odG14XScpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgY2hpbGQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpXG4gICAgfSlcbiAgICByZXR1cm4gY2xvbmUuaW5uZXJIVE1MXG4gIH1cblxuICBmdW5jdGlvbiBzYXZlQ3VycmVudFBhZ2VUb0hpc3RvcnkoKSB7XG4gICAgY29uc3QgZWx0ID0gZ2V0SGlzdG9yeUVsZW1lbnQoKVxuICAgIGNvbnN0IHBhdGggPSBjdXJyZW50UGF0aEZvckhpc3RvcnkgfHwgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2hcblxuICAgIC8vIEFsbG93IGhpc3Rvcnkgc25hcHNob3QgZmVhdHVyZSB0byBiZSBkaXNhYmxlZCB3aGVyZSBoeC1oaXN0b3J5PVwiZmFsc2VcIlxuICAgIC8vIGlzIHByZXNlbnQgKmFueXdoZXJlKiBpbiB0aGUgY3VycmVudCBkb2N1bWVudCB3ZSdyZSBhYm91dCB0byBzYXZlLFxuICAgIC8vIHNvIHdlIGNhbiBwcmV2ZW50IHByaXZpbGVnZWQgZGF0YSBlbnRlcmluZyB0aGUgY2FjaGUuXG4gICAgLy8gVGhlIHBhZ2Ugd2lsbCBzdGlsbCBiZSByZWFjaGFibGUgYXMgYSBoaXN0b3J5IGVudHJ5LCBidXQgaHRteCB3aWxsIGZldGNoIGl0XG4gICAgLy8gbGl2ZSBmcm9tIHRoZSBzZXJ2ZXIgb25wb3BzdGF0ZSByYXRoZXIgdGhhbiBsb29rIGluIHRoZSBsb2NhbFN0b3JhZ2UgY2FjaGVcbiAgICBsZXQgZGlzYWJsZUhpc3RvcnlDYWNoZVxuICAgIHRyeSB7XG4gICAgICBkaXNhYmxlSGlzdG9yeUNhY2hlID0gZ2V0RG9jdW1lbnQoKS5xdWVyeVNlbGVjdG9yKCdbaHgtaGlzdG9yeT1cImZhbHNlXCIgaV0sW2RhdGEtaHgtaGlzdG9yeT1cImZhbHNlXCIgaV0nKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRTExOiBpbnNlbnNpdGl2ZSBtb2RpZmllciBub3Qgc3VwcG9ydGVkIHNvIGZhbGxiYWNrIHRvIGNhc2Ugc2Vuc2l0aXZlIHNlbGVjdG9yXG4gICAgICBkaXNhYmxlSGlzdG9yeUNhY2hlID0gZ2V0RG9jdW1lbnQoKS5xdWVyeVNlbGVjdG9yKCdbaHgtaGlzdG9yeT1cImZhbHNlXCJdLFtkYXRhLWh4LWhpc3Rvcnk9XCJmYWxzZVwiXScpXG4gICAgfVxuICAgIGlmICghZGlzYWJsZUhpc3RvcnlDYWNoZSkge1xuICAgICAgdHJpZ2dlckV2ZW50KGdldERvY3VtZW50KCkuYm9keSwgJ2h0bXg6YmVmb3JlSGlzdG9yeVNhdmUnLCB7IHBhdGgsIGhpc3RvcnlFbHQ6IGVsdCB9KVxuICAgICAgc2F2ZVRvSGlzdG9yeUNhY2hlKHBhdGgsIGVsdClcbiAgICB9XG5cbiAgICBpZiAoaHRteC5jb25maWcuaGlzdG9yeUVuYWJsZWQpIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsgaHRteDogdHJ1ZSB9LCBnZXREb2N1bWVudCgpLnRpdGxlLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICAgKi9cbiAgZnVuY3Rpb24gcHVzaFVybEludG9IaXN0b3J5KHBhdGgpIHtcbiAgLy8gcmVtb3ZlIHRoZSBjYWNoZSBidXN0ZXIgcGFyYW1ldGVyLCBpZiBhbnlcbiAgICBpZiAoaHRteC5jb25maWcuZ2V0Q2FjaGVCdXN0ZXJQYXJhbSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvb3JnXFwuaHRteFxcLmNhY2hlLWJ1c3Rlcj1bXiZdKiY/LywgJycpXG4gICAgICBpZiAoZW5kc1dpdGgocGF0aCwgJyYnKSB8fCBlbmRzV2l0aChwYXRoLCAnPycpKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaHRteC5jb25maWcuaGlzdG9yeUVuYWJsZWQpIHtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsgaHRteDogdHJ1ZSB9LCAnJywgcGF0aClcbiAgICB9XG4gICAgY3VycmVudFBhdGhGb3JIaXN0b3J5ID0gcGF0aFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlVXJsSW5IaXN0b3J5KHBhdGgpIHtcbiAgICBpZiAoaHRteC5jb25maWcuaGlzdG9yeUVuYWJsZWQpIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsgaHRteDogdHJ1ZSB9LCAnJywgcGF0aClcbiAgICBjdXJyZW50UGF0aEZvckhpc3RvcnkgPSBwYXRoXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIdG14U2V0dGxlVGFza1tdfSB0YXNrc1xuICAgKi9cbiAgZnVuY3Rpb24gc2V0dGxlSW1tZWRpYXRlbHkodGFza3MpIHtcbiAgICBmb3JFYWNoKHRhc2tzLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICB0YXNrLmNhbGwodW5kZWZpbmVkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIGxvYWRIaXN0b3J5RnJvbVNlcnZlcihwYXRoKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgY29uc3QgZGV0YWlscyA9IHsgcGF0aCwgeGhyOiByZXF1ZXN0IH1cbiAgICB0cmlnZ2VyRXZlbnQoZ2V0RG9jdW1lbnQoKS5ib2R5LCAnaHRteDpoaXN0b3J5Q2FjaGVNaXNzJywgZGV0YWlscylcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHBhdGgsIHRydWUpXG4gICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdIWC1SZXF1ZXN0JywgJ3RydWUnKVxuICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignSFgtSGlzdG9yeS1SZXN0b3JlLVJlcXVlc3QnLCAndHJ1ZScpXG4gICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdIWC1DdXJyZW50LVVSTCcsIGdldERvY3VtZW50KCkubG9jYXRpb24uaHJlZilcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICB0cmlnZ2VyRXZlbnQoZ2V0RG9jdW1lbnQoKS5ib2R5LCAnaHRteDpoaXN0b3J5Q2FjaGVNaXNzTG9hZCcsIGRldGFpbHMpXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gbWFrZUZyYWdtZW50KHRoaXMucmVzcG9uc2UpXG4gICAgICAgIC8qKiBAdHlwZSBQYXJlbnROb2RlICovXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yKCdbaHgtaGlzdG9yeS1lbHRdLFtkYXRhLWh4LWhpc3RvcnktZWx0XScpIHx8IGZyYWdtZW50XG4gICAgICAgIGNvbnN0IGhpc3RvcnlFbGVtZW50ID0gZ2V0SGlzdG9yeUVsZW1lbnQoKVxuICAgICAgICBjb25zdCBzZXR0bGVJbmZvID0gbWFrZVNldHRsZUluZm8oaGlzdG9yeUVsZW1lbnQpXG4gICAgICAgIGhhbmRsZVRpdGxlKGZyYWdtZW50LnRpdGxlKVxuXG4gICAgICAgIGhhbmRsZVByZXNlcnZlZEVsZW1lbnRzKGZyYWdtZW50KVxuICAgICAgICBzd2FwSW5uZXJIVE1MKGhpc3RvcnlFbGVtZW50LCBjb250ZW50LCBzZXR0bGVJbmZvKVxuICAgICAgICByZXN0b3JlUHJlc2VydmVkRWxlbWVudHMoKVxuICAgICAgICBzZXR0bGVJbW1lZGlhdGVseShzZXR0bGVJbmZvLnRhc2tzKVxuICAgICAgICBjdXJyZW50UGF0aEZvckhpc3RvcnkgPSBwYXRoXG4gICAgICAgIHRyaWdnZXJFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14Omhpc3RvcnlSZXN0b3JlJywgeyBwYXRoLCBjYWNoZU1pc3M6IHRydWUsIHNlcnZlclJlc3BvbnNlOiB0aGlzLnJlc3BvbnNlIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmlnZ2VyRXJyb3JFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14Omhpc3RvcnlDYWNoZU1pc3NMb2FkRXJyb3InLCBkZXRhaWxzKVxuICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0LnNlbmQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aF1cbiAgICovXG4gIGZ1bmN0aW9uIHJlc3RvcmVIaXN0b3J5KHBhdGgpIHtcbiAgICBzYXZlQ3VycmVudFBhZ2VUb0hpc3RvcnkoKVxuICAgIHBhdGggPSBwYXRoIHx8IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoXG4gICAgY29uc3QgY2FjaGVkID0gZ2V0Q2FjaGVkSGlzdG9yeShwYXRoKVxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gbWFrZUZyYWdtZW50KGNhY2hlZC5jb250ZW50KVxuICAgICAgY29uc3QgaGlzdG9yeUVsZW1lbnQgPSBnZXRIaXN0b3J5RWxlbWVudCgpXG4gICAgICBjb25zdCBzZXR0bGVJbmZvID0gbWFrZVNldHRsZUluZm8oaGlzdG9yeUVsZW1lbnQpXG4gICAgICBoYW5kbGVUaXRsZShjYWNoZWQudGl0bGUpXG4gICAgICBoYW5kbGVQcmVzZXJ2ZWRFbGVtZW50cyhmcmFnbWVudClcbiAgICAgIHN3YXBJbm5lckhUTUwoaGlzdG9yeUVsZW1lbnQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKVxuICAgICAgcmVzdG9yZVByZXNlcnZlZEVsZW1lbnRzKClcbiAgICAgIHNldHRsZUltbWVkaWF0ZWx5KHNldHRsZUluZm8udGFza3MpXG4gICAgICBnZXRXaW5kb3coKS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgY2FjaGVkLnNjcm9sbClcbiAgICAgIH0sIDApIC8vIG5leHQgJ3RpY2snLCBzbyBicm93c2VyIGhhcyB0aW1lIHRvIHJlbmRlciBsYXlvdXRcbiAgICAgIGN1cnJlbnRQYXRoRm9ySGlzdG9yeSA9IHBhdGhcbiAgICAgIHRyaWdnZXJFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14Omhpc3RvcnlSZXN0b3JlJywgeyBwYXRoLCBpdGVtOiBjYWNoZWQgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGh0bXguY29uZmlnLnJlZnJlc2hPbkhpc3RvcnlNaXNzKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IG9wdGlvbmFsIHBhcmFtZXRlciBpbiByZWxvYWQoKSBmdW5jdGlvbiB0aHJvd3MgZXJyb3JcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW5yZXNvbHZlZFJlZmVyZW5jZVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkSGlzdG9yeUZyb21TZXJ2ZXIocGF0aClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAgICovXG4gIGZ1bmN0aW9uIGFkZFJlcXVlc3RJbmRpY2F0b3JDbGFzc2VzKGVsdCkge1xuICAgIGxldCBpbmRpY2F0b3JzID0gLyoqIEB0eXBlIEVsZW1lbnRbXSAqLyAoZmluZEF0dHJpYnV0ZVRhcmdldHMoZWx0LCAnaHgtaW5kaWNhdG9yJykpXG4gICAgaWYgKGluZGljYXRvcnMgPT0gbnVsbCkge1xuICAgICAgaW5kaWNhdG9ycyA9IFtlbHRdXG4gICAgfVxuICAgIGZvckVhY2goaW5kaWNhdG9ycywgZnVuY3Rpb24oaWMpIHtcbiAgICAgIGNvbnN0IGludGVybmFsRGF0YSA9IGdldEludGVybmFsRGF0YShpYylcbiAgICAgIGludGVybmFsRGF0YS5yZXF1ZXN0Q291bnQgPSAoaW50ZXJuYWxEYXRhLnJlcXVlc3RDb3VudCB8fCAwKSArIDFcbiAgICAgIGljLmNsYXNzTGlzdC5hZGQuY2FsbChpYy5jbGFzc0xpc3QsIGh0bXguY29uZmlnLnJlcXVlc3RDbGFzcylcbiAgICB9KVxuICAgIHJldHVybiBpbmRpY2F0b3JzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAgICovXG4gIGZ1bmN0aW9uIGRpc2FibGVFbGVtZW50cyhlbHQpIHtcbiAgICBsZXQgZGlzYWJsZWRFbHRzID0gLyoqIEB0eXBlIEVsZW1lbnRbXSAqLyAoZmluZEF0dHJpYnV0ZVRhcmdldHMoZWx0LCAnaHgtZGlzYWJsZWQtZWx0JykpXG4gICAgaWYgKGRpc2FibGVkRWx0cyA9PSBudWxsKSB7XG4gICAgICBkaXNhYmxlZEVsdHMgPSBbXVxuICAgIH1cbiAgICBmb3JFYWNoKGRpc2FibGVkRWx0cywgZnVuY3Rpb24oZGlzYWJsZWRFbGVtZW50KSB7XG4gICAgICBjb25zdCBpbnRlcm5hbERhdGEgPSBnZXRJbnRlcm5hbERhdGEoZGlzYWJsZWRFbGVtZW50KVxuICAgICAgaW50ZXJuYWxEYXRhLnJlcXVlc3RDb3VudCA9IChpbnRlcm5hbERhdGEucmVxdWVzdENvdW50IHx8IDApICsgMVxuICAgICAgZGlzYWJsZWRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnJylcbiAgICAgIGRpc2FibGVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZWQtYnktaHRteCcsICcnKVxuICAgIH0pXG4gICAgcmV0dXJuIGRpc2FibGVkRWx0c1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudFtdfSBpbmRpY2F0b3JzXG4gICAqIEBwYXJhbSB7RWxlbWVudFtdfSBkaXNhYmxlZFxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlUmVxdWVzdEluZGljYXRvcnMoaW5kaWNhdG9ycywgZGlzYWJsZWQpIHtcbiAgICBmb3JFYWNoKGluZGljYXRvcnMuY29uY2F0KGRpc2FibGVkKSwgZnVuY3Rpb24oZWxlKSB7XG4gICAgICBjb25zdCBpbnRlcm5hbERhdGEgPSBnZXRJbnRlcm5hbERhdGEoZWxlKVxuICAgICAgaW50ZXJuYWxEYXRhLnJlcXVlc3RDb3VudCA9IChpbnRlcm5hbERhdGEucmVxdWVzdENvdW50IHx8IDEpIC0gMVxuICAgIH0pXG4gICAgZm9yRWFjaChpbmRpY2F0b3JzLCBmdW5jdGlvbihpYykge1xuICAgICAgY29uc3QgaW50ZXJuYWxEYXRhID0gZ2V0SW50ZXJuYWxEYXRhKGljKVxuICAgICAgaWYgKGludGVybmFsRGF0YS5yZXF1ZXN0Q291bnQgPT09IDApIHtcbiAgICAgICAgaWMuY2xhc3NMaXN0LnJlbW92ZS5jYWxsKGljLmNsYXNzTGlzdCwgaHRteC5jb25maWcucmVxdWVzdENsYXNzKVxuICAgICAgfVxuICAgIH0pXG4gICAgZm9yRWFjaChkaXNhYmxlZCwgZnVuY3Rpb24oZGlzYWJsZWRFbGVtZW50KSB7XG4gICAgICBjb25zdCBpbnRlcm5hbERhdGEgPSBnZXRJbnRlcm5hbERhdGEoZGlzYWJsZWRFbGVtZW50KVxuICAgICAgaWYgKGludGVybmFsRGF0YS5yZXF1ZXN0Q291bnQgPT09IDApIHtcbiAgICAgICAgZGlzYWJsZWRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKVxuICAgICAgICBkaXNhYmxlZEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpc2FibGVkLWJ5LWh0bXgnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLz0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBJbnB1dCBWYWx1ZSBQcm9jZXNzaW5nXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudFtdfSBwcm9jZXNzZWRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBoYXZlU2Vlbk5vZGUocHJvY2Vzc2VkLCBlbHQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2Nlc3NlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHByb2Nlc3NlZFtpXVxuICAgICAgaWYgKG5vZGUuaXNTYW1lTm9kZShlbHQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gc2hvdWxkSW5jbHVkZShlbGVtZW50KSB7XG4gICAgLy8gQ2FzdCB0byB0cmljayB0c2MsIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCB3b3JrIGZpbmUgaGVyZVxuICAgIGNvbnN0IGVsdCA9IC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi8gKGVsZW1lbnQpXG4gICAgaWYgKGVsdC5uYW1lID09PSAnJyB8fCBlbHQubmFtZSA9PSBudWxsIHx8IGVsdC5kaXNhYmxlZCB8fCBjbG9zZXN0KGVsdCwgJ2ZpZWxkc2V0W2Rpc2FibGVkXScpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gaWdub3JlIFwic3VibWl0dGVyXCIgdHlwZXMgKHNlZSBqUXVlcnkgc3JjL3NlcmlhbGl6ZS5qcylcbiAgICBpZiAoZWx0LnR5cGUgPT09ICdidXR0b24nIHx8IGVsdC50eXBlID09PSAnc3VibWl0JyB8fCBlbHQudGFnTmFtZSA9PT0gJ2ltYWdlJyB8fCBlbHQudGFnTmFtZSA9PT0gJ3Jlc2V0JyB8fCBlbHQudGFnTmFtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGVsdC50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsdC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICByZXR1cm4gZWx0LmNoZWNrZWRcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheXxGb3JtRGF0YUVudHJ5VmFsdWV9IHZhbHVlXG4gICAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1EYXRhICovXG4gIGZ1bmN0aW9uIGFkZFZhbHVlVG9Gb3JtRGF0YShuYW1lLCB2YWx1ZSwgZm9ybURhdGEpIHtcbiAgICBpZiAobmFtZSAhPSBudWxsICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHsgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHYpIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Zvcm1EYXRhfSBmb3JtRGF0YSAqL1xuICBmdW5jdGlvbiByZW1vdmVWYWx1ZUZyb21Gb3JtRGF0YShuYW1lLCB2YWx1ZSwgZm9ybURhdGEpIHtcbiAgICBpZiAobmFtZSAhPSBudWxsICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGxldCB2YWx1ZXMgPSBmb3JtRGF0YS5nZXRBbGwobmFtZSlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdmFsdWUuaW5kZXhPZih2KSA8IDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdiAhPT0gdmFsdWUpXG4gICAgICB9XG4gICAgICBmb3JtRGF0YS5kZWxldGUobmFtZSlcbiAgICAgIGZvckVhY2godmFsdWVzLCB2ID0+IGZvcm1EYXRhLmFwcGVuZChuYW1lLCB2KSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50W119IHByb2Nlc3NlZFxuICAgKiBAcGFyYW0ge0Zvcm1EYXRhfSBmb3JtRGF0YVxuICAgKiBAcGFyYW0ge0h0bXhFbGVtZW50VmFsaWRhdGlvbkVycm9yW119IGVycm9yc1xuICAgKiBAcGFyYW0ge0VsZW1lbnR8SFRNTElucHV0RWxlbWVudHxIVE1MU2VsZWN0RWxlbWVudHxIVE1MRm9ybUVsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbGlkYXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzSW5wdXRWYWx1ZShwcm9jZXNzZWQsIGZvcm1EYXRhLCBlcnJvcnMsIGVsdCwgdmFsaWRhdGUpIHtcbiAgICBpZiAoZWx0ID09IG51bGwgfHwgaGF2ZVNlZW5Ob2RlKHByb2Nlc3NlZCwgZWx0KSkge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NlZC5wdXNoKGVsdClcbiAgICB9XG4gICAgaWYgKHNob3VsZEluY2x1ZGUoZWx0KSkge1xuICAgICAgY29uc3QgbmFtZSA9IGdldFJhd0F0dHJpYnV0ZShlbHQsICduYW1lJylcbiAgICAgIC8vIEB0cy1pZ25vcmUgdmFsdWUgd2lsbCBiZSB1bmRlZmluZWQgZm9yIG5vbi1pbnB1dCBlbGVtZW50cywgd2hpY2ggaXMgZmluZVxuICAgICAgbGV0IHZhbHVlID0gZWx0LnZhbHVlXG4gICAgICBpZiAoZWx0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQgJiYgZWx0Lm11bHRpcGxlKSB7XG4gICAgICAgIHZhbHVlID0gdG9BcnJheShlbHQucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uOmNoZWNrZWQnKSkubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuICgvKiogQHR5cGUgSFRNTE9wdGlvbkVsZW1lbnQgKi8oZSkpLnZhbHVlIH0pXG4gICAgICB9XG4gICAgICAvLyBpbmNsdWRlIGZpbGUgaW5wdXRzXG4gICAgICBpZiAoZWx0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBlbHQuZmlsZXMpIHtcbiAgICAgICAgdmFsdWUgPSB0b0FycmF5KGVsdC5maWxlcylcbiAgICAgIH1cbiAgICAgIGFkZFZhbHVlVG9Gb3JtRGF0YShuYW1lLCB2YWx1ZSwgZm9ybURhdGEpXG4gICAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgICAgdmFsaWRhdGVFbGVtZW50KGVsdCwgZXJyb3JzKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWx0IGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSB7XG4gICAgICBmb3JFYWNoKGVsdC5lbGVtZW50cywgZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3NlZC5pbmRleE9mKGlucHV0KSA+PSAwKSB7XG4gICAgICAgICAgLy8gVGhlIGlucHV0IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkIGFuZCBhZGRlZCB0byB0aGUgdmFsdWVzLCBidXQgdGhlIEZvcm1EYXRhIHRoYXQgd2lsbCBiZVxuICAgICAgICAgIC8vICBjb25zdHJ1Y3RlZCByaWdodCBhZnRlciBvbiB0aGUgZm9ybSwgd2lsbCBpbmNsdWRlIGl0IG9uY2UgYWdhaW4uIFNvIHJlbW92ZSB0aGF0IGlucHV0J3MgdmFsdWVcbiAgICAgICAgICAvLyAgbm93IHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICAgICAgICByZW1vdmVWYWx1ZUZyb21Gb3JtRGF0YShpbnB1dC5uYW1lLCBpbnB1dC52YWx1ZSwgZm9ybURhdGEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzc2VkLnB1c2goaW5wdXQpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbGlkYXRlKSB7XG4gICAgICAgICAgdmFsaWRhdGVFbGVtZW50KGlucHV0LCBlcnJvcnMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBuZXcgRm9ybURhdGEoZWx0KS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpbGUgJiYgdmFsdWUubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICByZXR1cm4gLy8gaWdub3JlIG5vLW5hbWUgZmlsZXNcbiAgICAgICAgfVxuICAgICAgICBhZGRWYWx1ZVRvRm9ybURhdGEobmFtZSwgdmFsdWUsIGZvcm1EYXRhKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHBhcmFtIHtIdG14RWxlbWVudFZhbGlkYXRpb25FcnJvcltdfSBlcnJvcnNcbiAgICovXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRWxlbWVudChlbHQsIGVycm9ycykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50ICYgRWxlbWVudEludGVybmFsc30gKi8gKGVsdClcbiAgICBpZiAoZWxlbWVudC53aWxsVmFsaWRhdGUpIHtcbiAgICAgIHRyaWdnZXJFdmVudChlbGVtZW50LCAnaHRteDp2YWxpZGF0aW9uOnZhbGlkYXRlJylcbiAgICAgIGlmICghZWxlbWVudC5jaGVja1ZhbGlkaXR5KCkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goeyBlbHQ6IGVsZW1lbnQsIG1lc3NhZ2U6IGVsZW1lbnQudmFsaWRhdGlvbk1lc3NhZ2UsIHZhbGlkaXR5OiBlbGVtZW50LnZhbGlkaXR5IH0pXG4gICAgICAgIHRyaWdnZXJFdmVudChlbGVtZW50LCAnaHRteDp2YWxpZGF0aW9uOmZhaWxlZCcsIHsgbWVzc2FnZTogZWxlbWVudC52YWxpZGF0aW9uTWVzc2FnZSwgdmFsaWRpdHk6IGVsZW1lbnQudmFsaWRpdHkgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdmFsdWVzIGluIHRoZSBvbmUgRm9ybURhdGEgd2l0aCB0aG9zZSBmcm9tIGFub3RoZXIuXG4gICAqIEBwYXJhbSB7Rm9ybURhdGF9IHJlY2VpdmVyIHRoZSBmb3JtZGF0YSB0aGF0IHdpbGwgYmUgbXV0YXRlZFxuICAgKiBAcGFyYW0ge0Zvcm1EYXRhfSBkb25vciB0aGUgZm9ybWRhdGEgdGhhdCB3aWxsIHByb3ZpZGUgdGhlIG92ZXJyaWRpbmcgdmFsdWVzXG4gICAqIEByZXR1cm5zIHtGb3JtRGF0YX0gdGhlIHtAbGlua2NvZGUgcmVjZWl2ZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBvdmVycmlkZUZvcm1EYXRhKHJlY2VpdmVyLCBkb25vcikge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGRvbm9yLmtleXMoKSkge1xuICAgICAgcmVjZWl2ZXIuZGVsZXRlKGtleSlcbiAgICB9XG4gICAgZG9ub3IuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZWNlaXZlci5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICB9KVxuICAgIHJldHVybiByZWNlaXZlclxuICB9XG5cbiAgLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR8SFRNTEZvcm1FbGVtZW50fSBlbHRcbiAqIEBwYXJhbSB7SHR0cFZlcmJ9IHZlcmJcbiAqIEByZXR1cm5zIHt7ZXJyb3JzOiBIdG14RWxlbWVudFZhbGlkYXRpb25FcnJvcltdLCBmb3JtRGF0YTogRm9ybURhdGEsIHZhbHVlczogT2JqZWN0fX1cbiAqL1xuICBmdW5jdGlvbiBnZXRJbnB1dFZhbHVlcyhlbHQsIHZlcmIpIHtcbiAgICAvKiogQHR5cGUgRWxlbWVudFtdICovXG4gICAgY29uc3QgcHJvY2Vzc2VkID0gW11cbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgY29uc3QgcHJpb3JpdHlGb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgLyoqIEB0eXBlIEh0bXhFbGVtZW50VmFsaWRhdGlvbkVycm9yW10gKi9cbiAgICBjb25zdCBlcnJvcnMgPSBbXVxuICAgIGNvbnN0IGludGVybmFsRGF0YSA9IGdldEludGVybmFsRGF0YShlbHQpXG4gICAgaWYgKGludGVybmFsRGF0YS5sYXN0QnV0dG9uQ2xpY2tlZCAmJiAhYm9keUNvbnRhaW5zKGludGVybmFsRGF0YS5sYXN0QnV0dG9uQ2xpY2tlZCkpIHtcbiAgICAgIGludGVybmFsRGF0YS5sYXN0QnV0dG9uQ2xpY2tlZCA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBvbmx5IHZhbGlkYXRlIHdoZW4gZm9ybSBpcyBkaXJlY3RseSBzdWJtaXR0ZWQgYW5kIG5vdmFsaWRhdGUgb3IgZm9ybW5vdmFsaWRhdGUgYXJlIG5vdCBzZXRcbiAgICAvLyBvciBpZiB0aGUgZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgaHgtdmFsaWRhdGU9XCJ0cnVlXCIgb24gaXRcbiAgICBsZXQgdmFsaWRhdGUgPSAoZWx0IGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50ICYmIGVsdC5ub1ZhbGlkYXRlICE9PSB0cnVlKSB8fCBnZXRBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC12YWxpZGF0ZScpID09PSAndHJ1ZSdcbiAgICBpZiAoaW50ZXJuYWxEYXRhLmxhc3RCdXR0b25DbGlja2VkKSB7XG4gICAgICB2YWxpZGF0ZSA9IHZhbGlkYXRlICYmIGludGVybmFsRGF0YS5sYXN0QnV0dG9uQ2xpY2tlZC5mb3JtTm9WYWxpZGF0ZSAhPT0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIGZvciBhIG5vbi1HRVQgaW5jbHVkZSB0aGUgY2xvc2VzdCBmb3JtXG4gICAgaWYgKHZlcmIgIT09ICdnZXQnKSB7XG4gICAgICBwcm9jZXNzSW5wdXRWYWx1ZShwcm9jZXNzZWQsIHByaW9yaXR5Rm9ybURhdGEsIGVycm9ycywgY2xvc2VzdChlbHQsICdmb3JtJyksIHZhbGlkYXRlKVxuICAgIH1cblxuICAgIC8vIGluY2x1ZGUgdGhlIGVsZW1lbnQgaXRzZWxmXG4gICAgcHJvY2Vzc0lucHV0VmFsdWUocHJvY2Vzc2VkLCBmb3JtRGF0YSwgZXJyb3JzLCBlbHQsIHZhbGlkYXRlKVxuXG4gICAgLy8gaWYgYSBidXR0b24gb3Igc3VibWl0IHdhcyBjbGlja2VkIGxhc3QsIGluY2x1ZGUgaXRzIHZhbHVlXG4gICAgaWYgKGludGVybmFsRGF0YS5sYXN0QnV0dG9uQ2xpY2tlZCB8fCBlbHQudGFnTmFtZSA9PT0gJ0JVVFRPTicgfHxcbiAgICAoZWx0LnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgZ2V0UmF3QXR0cmlidXRlKGVsdCwgJ3R5cGUnKSA9PT0gJ3N1Ym1pdCcpKSB7XG4gICAgICBjb25zdCBidXR0b24gPSBpbnRlcm5hbERhdGEubGFzdEJ1dHRvbkNsaWNrZWQgfHwgKC8qKiBAdHlwZSBIVE1MSW5wdXRFbGVtZW50fEhUTUxCdXR0b25FbGVtZW50ICovKGVsdCkpXG4gICAgICBjb25zdCBuYW1lID0gZ2V0UmF3QXR0cmlidXRlKGJ1dHRvbiwgJ25hbWUnKVxuICAgICAgYWRkVmFsdWVUb0Zvcm1EYXRhKG5hbWUsIGJ1dHRvbi52YWx1ZSwgcHJpb3JpdHlGb3JtRGF0YSlcbiAgICB9XG5cbiAgICAvLyBpbmNsdWRlIGFueSBleHBsaWNpdCBpbmNsdWRlc1xuICAgIGNvbnN0IGluY2x1ZGVzID0gZmluZEF0dHJpYnV0ZVRhcmdldHMoZWx0LCAnaHgtaW5jbHVkZScpXG4gICAgZm9yRWFjaChpbmNsdWRlcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgcHJvY2Vzc0lucHV0VmFsdWUocHJvY2Vzc2VkLCBmb3JtRGF0YSwgZXJyb3JzLCBhc0VsZW1lbnQobm9kZSksIHZhbGlkYXRlKVxuICAgICAgLy8gaWYgYSBub24tZm9ybSBpcyBpbmNsdWRlZCwgaW5jbHVkZSBhbnkgaW5wdXQgdmFsdWVzIHdpdGhpbiBpdFxuICAgICAgaWYgKCFtYXRjaGVzKG5vZGUsICdmb3JtJykpIHtcbiAgICAgICAgZm9yRWFjaChhc1BhcmVudE5vZGUobm9kZSkucXVlcnlTZWxlY3RvckFsbChJTlBVVF9TRUxFQ1RPUiksIGZ1bmN0aW9uKGRlc2NlbmRhbnQpIHtcbiAgICAgICAgICBwcm9jZXNzSW5wdXRWYWx1ZShwcm9jZXNzZWQsIGZvcm1EYXRhLCBlcnJvcnMsIGRlc2NlbmRhbnQsIHZhbGlkYXRlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyB2YWx1ZXMgZnJvbSBhIDxmb3JtPiB0YWtlIHByZWNlZGVuY2UsIG92ZXJyaWRpbmcgdGhlIHJlZ3VsYXIgdmFsdWVzXG4gICAgb3ZlcnJpZGVGb3JtRGF0YShmb3JtRGF0YSwgcHJpb3JpdHlGb3JtRGF0YSlcblxuICAgIHJldHVybiB7IGVycm9ycywgZm9ybURhdGEsIHZhbHVlczogZm9ybURhdGFQcm94eShmb3JtRGF0YSkgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXR1cm5TdHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHthbnl9IHJlYWxWYWx1ZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gYXBwZW5kUGFyYW0ocmV0dXJuU3RyLCBuYW1lLCByZWFsVmFsdWUpIHtcbiAgICBpZiAocmV0dXJuU3RyICE9PSAnJykge1xuICAgICAgcmV0dXJuU3RyICs9ICcmJ1xuICAgIH1cbiAgICBpZiAoU3RyaW5nKHJlYWxWYWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICByZWFsVmFsdWUgPSBKU09OLnN0cmluZ2lmeShyZWFsVmFsdWUpXG4gICAgfVxuICAgIGNvbnN0IHMgPSBlbmNvZGVVUklDb21wb25lbnQocmVhbFZhbHVlKVxuICAgIHJldHVyblN0ciArPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyAnPScgKyBzXG4gICAgcmV0dXJuIHJldHVyblN0clxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Rm9ybURhdGF8T2JqZWN0fSB2YWx1ZXNcbiAgICogQHJldHVybnMgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiB1cmxFbmNvZGUodmFsdWVzKSB7XG4gICAgdmFsdWVzID0gZm9ybURhdGFGcm9tT2JqZWN0KHZhbHVlcylcbiAgICBsZXQgcmV0dXJuU3RyID0gJydcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm5TdHIgPSBhcHBlbmRQYXJhbShyZXR1cm5TdHIsIGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gcmV0dXJuU3RyXG4gIH1cblxuICAvLz0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBBamF4XG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9tcHRcbiAqIEByZXR1cm5zIHtIdG14SGVhZGVyU3BlY2lmaWNhdGlvbn1cbiAqL1xuICBmdW5jdGlvbiBnZXRIZWFkZXJzKGVsdCwgdGFyZ2V0LCBwcm9tcHQpIHtcbiAgICAvKiogQHR5cGUgSHRteEhlYWRlclNwZWNpZmljYXRpb24gKi9cbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgJ0hYLVJlcXVlc3QnOiAndHJ1ZScsXG4gICAgICAnSFgtVHJpZ2dlcic6IGdldFJhd0F0dHJpYnV0ZShlbHQsICdpZCcpLFxuICAgICAgJ0hYLVRyaWdnZXItTmFtZSc6IGdldFJhd0F0dHJpYnV0ZShlbHQsICduYW1lJyksXG4gICAgICAnSFgtVGFyZ2V0JzogZ2V0QXR0cmlidXRlVmFsdWUodGFyZ2V0LCAnaWQnKSxcbiAgICAgICdIWC1DdXJyZW50LVVSTCc6IGdldERvY3VtZW50KCkubG9jYXRpb24uaHJlZlxuICAgIH1cbiAgICBnZXRWYWx1ZXNGb3JFbGVtZW50KGVsdCwgJ2h4LWhlYWRlcnMnLCBmYWxzZSwgaGVhZGVycylcbiAgICBpZiAocHJvbXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnNbJ0hYLVByb21wdCddID0gcHJvbXB0XG4gICAgfVxuICAgIGlmIChnZXRJbnRlcm5hbERhdGEoZWx0KS5ib29zdGVkKSB7XG4gICAgICBoZWFkZXJzWydIWC1Cb29zdGVkJ10gPSAndHJ1ZSdcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIC8qKlxuICogZmlsdGVyVmFsdWVzIHRha2VzIGFuIG9iamVjdCBjb250YWluaW5nIGZvcm0gaW5wdXQgdmFsdWVzXG4gKiBhbmQgcmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBvbmx5IGNvbnRhaW5zIGtleXMgdGhhdCBhcmVcbiAqIHNwZWNpZmllZCBieSB0aGUgY2xvc2VzdCBcImh4LXBhcmFtc1wiIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtGb3JtRGF0YX0gaW5wdXRWYWx1ZXNcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gKiBAcmV0dXJucyB7Rm9ybURhdGF9XG4gKi9cbiAgZnVuY3Rpb24gZmlsdGVyVmFsdWVzKGlucHV0VmFsdWVzLCBlbHQpIHtcbiAgICBjb25zdCBwYXJhbXNWYWx1ZSA9IGdldENsb3Nlc3RBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC1wYXJhbXMnKVxuICAgIGlmIChwYXJhbXNWYWx1ZSkge1xuICAgICAgaWYgKHBhcmFtc1ZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtRGF0YSgpXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtc1ZhbHVlID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWVzXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtc1ZhbHVlLmluZGV4T2YoJ25vdCAnKSA9PT0gMCkge1xuICAgICAgICBmb3JFYWNoKHBhcmFtc1ZhbHVlLnN1YnN0cig0KS5zcGxpdCgnLCcpLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUudHJpbSgpXG4gICAgICAgICAgaW5wdXRWYWx1ZXMuZGVsZXRlKG5hbWUpXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWVzID0gbmV3IEZvcm1EYXRhKClcbiAgICAgICAgZm9yRWFjaChwYXJhbXNWYWx1ZS5zcGxpdCgnLCcpLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUudHJpbSgpXG4gICAgICAgICAgaWYgKGlucHV0VmFsdWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZXMuZ2V0QWxsKG5hbWUpLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsgbmV3VmFsdWVzLmFwcGVuZChuYW1lLCB2YWx1ZSkgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBuZXdWYWx1ZXNcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGlucHV0VmFsdWVzXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0FuY2hvckxpbmsoZWx0KSB7XG4gICAgcmV0dXJuICEhZ2V0UmF3QXR0cmlidXRlKGVsdCwgJ2hyZWYnKSAmJiBnZXRSYXdBdHRyaWJ1dGUoZWx0LCAnaHJlZicpLmluZGV4T2YoJyMnKSA+PSAwXG4gIH1cblxuICAvKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gKiBAcGFyYW0ge0h0bXhTd2FwU3R5bGV9IFtzd2FwSW5mb092ZXJyaWRlXVxuICogQHJldHVybnMge0h0bXhTd2FwU3BlY2lmaWNhdGlvbn1cbiAqL1xuICBmdW5jdGlvbiBnZXRTd2FwU3BlY2lmaWNhdGlvbihlbHQsIHN3YXBJbmZvT3ZlcnJpZGUpIHtcbiAgICBjb25zdCBzd2FwSW5mbyA9IHN3YXBJbmZvT3ZlcnJpZGUgfHwgZ2V0Q2xvc2VzdEF0dHJpYnV0ZVZhbHVlKGVsdCwgJ2h4LXN3YXAnKVxuICAgIC8qKiBAdHlwZSBIdG14U3dhcFNwZWNpZmljYXRpb24gKi9cbiAgICBjb25zdCBzd2FwU3BlYyA9IHtcbiAgICAgIHN3YXBTdHlsZTogZ2V0SW50ZXJuYWxEYXRhKGVsdCkuYm9vc3RlZCA/ICdpbm5lckhUTUwnIDogaHRteC5jb25maWcuZGVmYXVsdFN3YXBTdHlsZSxcbiAgICAgIHN3YXBEZWxheTogaHRteC5jb25maWcuZGVmYXVsdFN3YXBEZWxheSxcbiAgICAgIHNldHRsZURlbGF5OiBodG14LmNvbmZpZy5kZWZhdWx0U2V0dGxlRGVsYXlcbiAgICB9XG4gICAgaWYgKGh0bXguY29uZmlnLnNjcm9sbEludG9WaWV3T25Cb29zdCAmJiBnZXRJbnRlcm5hbERhdGEoZWx0KS5ib29zdGVkICYmICFpc0FuY2hvckxpbmsoZWx0KSkge1xuICAgICAgc3dhcFNwZWMuc2hvdyA9ICd0b3AnXG4gICAgfVxuICAgIGlmIChzd2FwSW5mbykge1xuICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdE9uV2hpdGVzcGFjZShzd2FwSW5mbylcbiAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNwbGl0W2ldXG4gICAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoJ3N3YXA6JykgPT09IDApIHtcbiAgICAgICAgICAgIHN3YXBTcGVjLnN3YXBEZWxheSA9IHBhcnNlSW50ZXJ2YWwodmFsdWUuc3Vic3RyKDUpKVxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignc2V0dGxlOicpID09PSAwKSB7XG4gICAgICAgICAgICBzd2FwU3BlYy5zZXR0bGVEZWxheSA9IHBhcnNlSW50ZXJ2YWwodmFsdWUuc3Vic3RyKDcpKVxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZigndHJhbnNpdGlvbjonKSA9PT0gMCkge1xuICAgICAgICAgICAgc3dhcFNwZWMudHJhbnNpdGlvbiA9IHZhbHVlLnN1YnN0cigxMSkgPT09ICd0cnVlJ1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignaWdub3JlVGl0bGU6JykgPT09IDApIHtcbiAgICAgICAgICAgIHN3YXBTcGVjLmlnbm9yZVRpdGxlID0gdmFsdWUuc3Vic3RyKDEyKSA9PT0gJ3RydWUnXG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCdzY3JvbGw6JykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFNwZWMgPSB2YWx1ZS5zdWJzdHIoNylcbiAgICAgICAgICAgIHZhciBzcGxpdFNwZWMgPSBzY3JvbGxTcGVjLnNwbGl0KCc6JylcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbFZhbCA9IHNwbGl0U3BlYy5wb3AoKVxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yVmFsID0gc3BsaXRTcGVjLmxlbmd0aCA+IDAgPyBzcGxpdFNwZWMuam9pbignOicpIDogbnVsbFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc3dhcFNwZWMuc2Nyb2xsID0gc2Nyb2xsVmFsXG4gICAgICAgICAgICBzd2FwU3BlYy5zY3JvbGxUYXJnZXQgPSBzZWxlY3RvclZhbFxuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignc2hvdzonKSA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2hvd1NwZWMgPSB2YWx1ZS5zdWJzdHIoNSlcbiAgICAgICAgICAgIHZhciBzcGxpdFNwZWMgPSBzaG93U3BlYy5zcGxpdCgnOicpXG4gICAgICAgICAgICBjb25zdCBzaG93VmFsID0gc3BsaXRTcGVjLnBvcCgpXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JWYWwgPSBzcGxpdFNwZWMubGVuZ3RoID4gMCA/IHNwbGl0U3BlYy5qb2luKCc6JykgOiBudWxsXG4gICAgICAgICAgICBzd2FwU3BlYy5zaG93ID0gc2hvd1ZhbFxuICAgICAgICAgICAgc3dhcFNwZWMuc2hvd1RhcmdldCA9IHNlbGVjdG9yVmFsXG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCdmb2N1cy1zY3JvbGw6JykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzU2Nyb2xsVmFsID0gdmFsdWUuc3Vic3RyKCdmb2N1cy1zY3JvbGw6Jy5sZW5ndGgpXG4gICAgICAgICAgICBzd2FwU3BlYy5mb2N1c1Njcm9sbCA9IGZvY3VzU2Nyb2xsVmFsID09ICd0cnVlJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICBzd2FwU3BlYy5zd2FwU3R5bGUgPSB2YWx1ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dFcnJvcignVW5rbm93biBtb2RpZmllciBpbiBoeC1zd2FwOiAnICsgdmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzd2FwU3BlY1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiB1c2VzRm9ybURhdGEoZWx0KSB7XG4gICAgcmV0dXJuIGdldENsb3Nlc3RBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC1lbmNvZGluZycpID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScgfHxcbiAgICAobWF0Y2hlcyhlbHQsICdmb3JtJykgJiYgZ2V0UmF3QXR0cmlidXRlKGVsdCwgJ2VuY3R5cGUnKSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge0Zvcm1EYXRhfSBmaWx0ZXJlZFBhcmFtZXRlcnNcbiAgICogQHJldHVybnMgeyp8c3RyaW5nfG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBlbmNvZGVQYXJhbXNGb3JCb2R5KHhociwgZWx0LCBmaWx0ZXJlZFBhcmFtZXRlcnMpIHtcbiAgICBsZXQgZW5jb2RlZFBhcmFtZXRlcnMgPSBudWxsXG4gICAgd2l0aEV4dGVuc2lvbnMoZWx0LCBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICAgIGlmIChlbmNvZGVkUGFyYW1ldGVycyA9PSBudWxsKSB7XG4gICAgICAgIGVuY29kZWRQYXJhbWV0ZXJzID0gZXh0ZW5zaW9uLmVuY29kZVBhcmFtZXRlcnMoeGhyLCBmaWx0ZXJlZFBhcmFtZXRlcnMsIGVsdClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChlbmNvZGVkUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlZFBhcmFtZXRlcnNcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHVzZXNGb3JtRGF0YShlbHQpKSB7XG4gICAgICAgIC8vIEZvcmNlIGNvbnZlcnNpb24gdG8gYW4gYWN0dWFsIEZvcm1EYXRhIG9iamVjdCBpbiBjYXNlIGZpbHRlcmVkUGFyYW1ldGVycyBpcyBhIGZvcm1EYXRhUHJveHlcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaWdza3lzb2Z0d2FyZS9odG14L2lzc3Vlcy8yMzE3XG4gICAgICAgIHJldHVybiBvdmVycmlkZUZvcm1EYXRhKG5ldyBGb3JtRGF0YSgpLCBmb3JtRGF0YUZyb21PYmplY3QoZmlsdGVyZWRQYXJhbWV0ZXJzKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1cmxFbmNvZGUoZmlsdGVyZWRQYXJhbWV0ZXJzKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcmV0dXJucyB7SHRteFNldHRsZUluZm99XG4gKi9cbiAgZnVuY3Rpb24gbWFrZVNldHRsZUluZm8odGFyZ2V0KSB7XG4gICAgcmV0dXJuIHsgdGFza3M6IFtdLCBlbHRzOiBbdGFyZ2V0XSB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50W119IGNvbnRlbnRcbiAgICogQHBhcmFtIHtIdG14U3dhcFNwZWNpZmljYXRpb259IHN3YXBTcGVjXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxTdGF0ZShjb250ZW50LCBzd2FwU3BlYykge1xuICAgIGNvbnN0IGZpcnN0ID0gY29udGVudFswXVxuICAgIGNvbnN0IGxhc3QgPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV1cbiAgICBpZiAoc3dhcFNwZWMuc2Nyb2xsKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gbnVsbFxuICAgICAgaWYgKHN3YXBTcGVjLnNjcm9sbFRhcmdldCkge1xuICAgICAgICB0YXJnZXQgPSBhc0VsZW1lbnQocXVlcnlTZWxlY3RvckV4dChmaXJzdCwgc3dhcFNwZWMuc2Nyb2xsVGFyZ2V0KSlcbiAgICAgIH1cbiAgICAgIGlmIChzd2FwU3BlYy5zY3JvbGwgPT09ICd0b3AnICYmIChmaXJzdCB8fCB0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBmaXJzdFxuICAgICAgICB0YXJnZXQuc2Nyb2xsVG9wID0gMFxuICAgICAgfVxuICAgICAgaWYgKHN3YXBTcGVjLnNjcm9sbCA9PT0gJ2JvdHRvbScgJiYgKGxhc3QgfHwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbGFzdFxuICAgICAgICB0YXJnZXQuc2Nyb2xsVG9wID0gdGFyZ2V0LnNjcm9sbEhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3dhcFNwZWMuc2hvdykge1xuICAgICAgdmFyIHRhcmdldCA9IG51bGxcbiAgICAgIGlmIChzd2FwU3BlYy5zaG93VGFyZ2V0KSB7XG4gICAgICAgIGxldCB0YXJnZXRTdHIgPSBzd2FwU3BlYy5zaG93VGFyZ2V0XG4gICAgICAgIGlmIChzd2FwU3BlYy5zaG93VGFyZ2V0ID09PSAnd2luZG93Jykge1xuICAgICAgICAgIHRhcmdldFN0ciA9ICdib2R5J1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IGFzRWxlbWVudChxdWVyeVNlbGVjdG9yRXh0KGZpcnN0LCB0YXJnZXRTdHIpKVxuICAgICAgfVxuICAgICAgaWYgKHN3YXBTcGVjLnNob3cgPT09ICd0b3AnICYmIChmaXJzdCB8fCB0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBmaXJzdFxuICAgICAgICAvLyBAdHMtaWdub3JlIEZvciBzb21lIHJlYXNvbiB0c2MgZG9lc24ndCByZWNvZ25pemUgXCJpbnN0YW50XCIgYXMgYSB2YWxpZCBvcHRpb24gZm9yIG5vd1xuICAgICAgICB0YXJnZXQuc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ3N0YXJ0JywgYmVoYXZpb3I6IGh0bXguY29uZmlnLnNjcm9sbEJlaGF2aW9yIH0pXG4gICAgICB9XG4gICAgICBpZiAoc3dhcFNwZWMuc2hvdyA9PT0gJ2JvdHRvbScgJiYgKGxhc3QgfHwgdGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbGFzdFxuICAgICAgICAvLyBAdHMtaWdub3JlIEZvciBzb21lIHJlYXNvbiB0c2MgZG9lc24ndCByZWNvZ25pemUgXCJpbnN0YW50XCIgYXMgYSB2YWxpZCBvcHRpb24gZm9yIG5vd1xuICAgICAgICB0YXJnZXQuc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ2VuZCcsIGJlaGF2aW9yOiBodG14LmNvbmZpZy5zY3JvbGxCZWhhdmlvciB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBldmFsQXNEZWZhdWx0XG4gKiBAcGFyYW0ge09iamVjdD19IHZhbHVlc1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZXNGb3JFbGVtZW50KGVsdCwgYXR0ciwgZXZhbEFzRGVmYXVsdCwgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICB2YWx1ZXMgPSB7fVxuICAgIH1cbiAgICBpZiAoZWx0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZXNcbiAgICB9XG4gICAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZShlbHQsIGF0dHIpXG4gICAgaWYgKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICBsZXQgc3RyID0gYXR0cmlidXRlVmFsdWUudHJpbSgpXG4gICAgICBsZXQgZXZhbHVhdGVWYWx1ZSA9IGV2YWxBc0RlZmF1bHRcbiAgICAgIGlmIChzdHIgPT09ICd1bnNldCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCkge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDExKVxuICAgICAgICBldmFsdWF0ZVZhbHVlID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdHIuaW5kZXhPZignanM6JykgPT09IDApIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cigzKVxuICAgICAgICBldmFsdWF0ZVZhbHVlID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCd7JykgIT09IDApIHtcbiAgICAgICAgc3RyID0gJ3snICsgc3RyICsgJ30nXG4gICAgICB9XG4gICAgICBsZXQgdmFyc1ZhbHVlc1xuICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgdmFyc1ZhbHVlcyA9IG1heWJlRXZhbChlbHQsIGZ1bmN0aW9uKCkgeyByZXR1cm4gRnVuY3Rpb24oJ3JldHVybiAoJyArIHN0ciArICcpJykoKSB9LCB7fSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcnNWYWx1ZXMgPSBwYXJzZUpTT04oc3RyKVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFyc1ZhbHVlcykge1xuICAgICAgICBpZiAodmFyc1ZhbHVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlc1trZXldID0gdmFyc1ZhbHVlc1trZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZXRWYWx1ZXNGb3JFbGVtZW50KGFzRWxlbWVudChwYXJlbnRFbHQoZWx0KSksIGF0dHIsIGV2YWxBc0RlZmF1bHQsIHZhbHVlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fHN0cmluZ30gZWx0XG4gICAqIEBwYXJhbSB7KCkgPT4gYW55fSB0b0V2YWxcbiAgICogQHBhcmFtIHthbnk9fSBkZWZhdWx0VmFsXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBmdW5jdGlvbiBtYXliZUV2YWwoZWx0LCB0b0V2YWwsIGRlZmF1bHRWYWwpIHtcbiAgICBpZiAoaHRteC5jb25maWcuYWxsb3dFdmFsKSB7XG4gICAgICByZXR1cm4gdG9FdmFsKClcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlckVycm9yRXZlbnQoZWx0LCAnaHRteDpldmFsRGlzYWxsb3dlZEVycm9yJylcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICogQHBhcmFtIHsqP30gZXhwcmVzc2lvblZhcnNcbiAqIEByZXR1cm5zXG4gKi9cbiAgZnVuY3Rpb24gZ2V0SFhWYXJzRm9yRWxlbWVudChlbHQsIGV4cHJlc3Npb25WYXJzKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlc0ZvckVsZW1lbnQoZWx0LCAnaHgtdmFycycsIHRydWUsIGV4cHJlc3Npb25WYXJzKVxuICB9XG5cbiAgLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICogQHBhcmFtIHsqP30gZXhwcmVzc2lvblZhcnNcbiAqIEByZXR1cm5zXG4gKi9cbiAgZnVuY3Rpb24gZ2V0SFhWYWxzRm9yRWxlbWVudChlbHQsIGV4cHJlc3Npb25WYXJzKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlc0ZvckVsZW1lbnQoZWx0LCAnaHgtdmFscycsIGZhbHNlLCBleHByZXNzaW9uVmFycylcbiAgfVxuXG4gIC8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAqIEByZXR1cm5zIHtGb3JtRGF0YX1cbiAqL1xuICBmdW5jdGlvbiBnZXRFeHByZXNzaW9uVmFycyhlbHQpIHtcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGdldEhYVmFyc0ZvckVsZW1lbnQoZWx0KSwgZ2V0SFhWYWxzRm9yRWxlbWVudChlbHQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGVhZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGhlYWRlclZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiBzYWZlbHlTZXRIZWFkZXJWYWx1ZSh4aHIsIGhlYWRlciwgaGVhZGVyVmFsdWUpIHtcbiAgICBpZiAoaGVhZGVyVmFsdWUgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgaGVhZGVyVmFsdWUpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBPbiBhbiBleGNlcHRpb24sIHRyeSB0byBzZXQgdGhlIGhlYWRlciBVUkkgZW5jb2RlZCBpbnN0ZWFkXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgZW5jb2RlVVJJQ29tcG9uZW50KGhlYWRlclZhbHVlKSlcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyICsgJy1VUkktQXV0b0VuY29kZWQnLCAndHJ1ZScpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRQYXRoRnJvbVJlc3BvbnNlKHhocikge1xuICAvLyBOQjogSUUxMSBkb2VzIG5vdCBzdXBwb3J0IHRoaXMgc3R1ZmZcbiAgICBpZiAoeGhyLnJlc3BvbnNlVVJMICYmIHR5cGVvZiAoVVJMKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoeGhyLnJlc3BvbnNlVVJMKVxuICAgICAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cmlnZ2VyRXJyb3JFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14OmJhZFJlc3BvbnNlVXJsJywgeyB1cmw6IHhoci5yZXNwb25zZVVSTCB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fSB4aHJcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzSGVhZGVyKHhociwgcmVnZXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJc3N1ZXMgYW4gaHRteC1zdHlsZSBBSkFYIHJlcXVlc3RcbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bXgub3JnL2FwaS8jYWpheFxuICAgKlxuICAgKiBAcGFyYW0ge0h0dHBWZXJifSB2ZXJiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBVUkwgcGF0aCB0byBtYWtlIHRoZSBBSkFYXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd8SHRteEFqYXhIZWxwZXJDb250ZXh0fSBjb250ZXh0IHRoZSBlbGVtZW50IHRvIHRhcmdldCAoZGVmYXVsdHMgdG8gdGhlICoqYm9keSoqKSB8IGEgc2VsZWN0b3IgZm9yIHRoZSB0YXJnZXQgfCBhIGNvbnRleHQgb2JqZWN0IHRoYXQgY29udGFpbnMgYW55IG9mIHRoZSBmb2xsb3dpbmdcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIGltbWVkaWF0ZWx5IGlmIG5vIHJlcXVlc3QgaXMgc2VudCwgb3Igd2hlbiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZVxuICAgKi9cbiAgZnVuY3Rpb24gYWpheEhlbHBlcih2ZXJiLCBwYXRoLCBjb250ZXh0KSB7XG4gICAgdmVyYiA9ICgvKiogQHR5cGUgSHR0cFZlcmIgKi8odmVyYi50b0xvd2VyQ2FzZSgpKSlcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHR5cGVvZiBjb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaXNzdWVBamF4UmVxdWVzdCh2ZXJiLCBwYXRoLCBudWxsLCBudWxsLCB7XG4gICAgICAgICAgdGFyZ2V0T3ZlcnJpZGU6IHJlc29sdmVUYXJnZXQoY29udGV4dCkgfHwgRFVNTVlfRUxULFxuICAgICAgICAgIHJldHVyblByb21pc2U6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByZXNvbHZlZFRhcmdldCA9IHJlc29sdmVUYXJnZXQoY29udGV4dC50YXJnZXQpXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBzdXBwbGllZCBidXQgY2FuJ3QgcmVzb2x2ZSBPUiBib3RoIHRhcmdldCBhbmQgc291cmNlIGNhbid0IGJlIHJlc29sdmVkXG4gICAgICAgIC8vIHRoZW4gdXNlIERVTU1ZX0VMVCB0byBhYm9ydCB0aGUgcmVxdWVzdCB3aXRoIGh0bXg6dGFyZ2V0RXJyb3IgdG8gYXZvaWQgaXQgcmVwbGFjaW5nIGJvZHkgYnkgbWlzdGFrZVxuICAgICAgICBpZiAoKGNvbnRleHQudGFyZ2V0ICYmICFyZXNvbHZlZFRhcmdldCkgfHwgKCFyZXNvbHZlZFRhcmdldCAmJiAhcmVzb2x2ZVRhcmdldChjb250ZXh0LnNvdXJjZSkpKSB7XG4gICAgICAgICAgcmVzb2x2ZWRUYXJnZXQgPSBEVU1NWV9FTFRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNzdWVBamF4UmVxdWVzdCh2ZXJiLCBwYXRoLCByZXNvbHZlVGFyZ2V0KGNvbnRleHQuc291cmNlKSwgY29udGV4dC5ldmVudCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBoYW5kbGVyOiBjb250ZXh0LmhhbmRsZXIsXG4gICAgICAgICAgICBoZWFkZXJzOiBjb250ZXh0LmhlYWRlcnMsXG4gICAgICAgICAgICB2YWx1ZXM6IGNvbnRleHQudmFsdWVzLFxuICAgICAgICAgICAgdGFyZ2V0T3ZlcnJpZGU6IHJlc29sdmVkVGFyZ2V0LFxuICAgICAgICAgICAgc3dhcE92ZXJyaWRlOiBjb250ZXh0LnN3YXAsXG4gICAgICAgICAgICBzZWxlY3Q6IGNvbnRleHQuc2VsZWN0LFxuICAgICAgICAgICAgcmV0dXJuUHJvbWlzZTogdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc3N1ZUFqYXhSZXF1ZXN0KHZlcmIsIHBhdGgsIG51bGwsIG51bGwsIHtcbiAgICAgICAgcmV0dXJuUHJvbWlzZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHJldHVybiB7RWxlbWVudFtdfVxuICAgKi9cbiAgZnVuY3Rpb24gaGllcmFyY2h5Rm9yRWx0KGVsdCkge1xuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgd2hpbGUgKGVsdCkge1xuICAgICAgYXJyLnB1c2goZWx0KVxuICAgICAgZWx0ID0gZWx0LnBhcmVudEVsZW1lbnRcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7SHRteFJlcXVlc3RDb25maWd9IHJlcXVlc3RDb25maWdcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIHZlcmlmeVBhdGgoZWx0LCBwYXRoLCByZXF1ZXN0Q29uZmlnKSB7XG4gICAgbGV0IHNhbWVIb3N0XG4gICAgbGV0IHVybFxuICAgIGlmICh0eXBlb2YgVVJMID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGRvY3VtZW50LmxvY2F0aW9uLmhyZWYpXG4gICAgICBjb25zdCBvcmlnaW4gPSBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW5cbiAgICAgIHNhbWVIb3N0ID0gb3JpZ2luID09PSB1cmwub3JpZ2luXG4gICAgfSBlbHNlIHtcbiAgICAvLyBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBVUkxcbiAgICAgIHVybCA9IHBhdGhcbiAgICAgIHNhbWVIb3N0ID0gc3RhcnRzV2l0aChwYXRoLCBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW4pXG4gICAgfVxuXG4gICAgaWYgKGh0bXguY29uZmlnLnNlbGZSZXF1ZXN0c09ubHkpIHtcbiAgICAgIGlmICghc2FtZUhvc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cmlnZ2VyRXZlbnQoZWx0LCAnaHRteDp2YWxpZGF0ZVVybCcsIG1lcmdlT2JqZWN0cyh7IHVybCwgc2FtZUhvc3QgfSwgcmVxdWVzdENvbmZpZykpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R8Rm9ybURhdGF9IG9ialxuICAgKiBAcmV0dXJuIHtGb3JtRGF0YX1cbiAgICovXG4gIGZ1bmN0aW9uIGZvcm1EYXRhRnJvbU9iamVjdChvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9ybURhdGEpIHJldHVybiBvYmpcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaWYgKG9ialtrZXldICYmIHR5cGVvZiBvYmpba2V5XS5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb2JqW2tleV0uZm9yRWFjaChmdW5jdGlvbih2KSB7IGZvcm1EYXRhLmFwcGVuZChrZXksIHYpIH0pXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0JyAmJiAhKG9ialtrZXldIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCBKU09OLnN0cmluZ2lmeShvYmpba2V5XSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgb2JqW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1EYXRhXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGb3JtRGF0YX0gZm9ybURhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gZm9ybURhdGFBcnJheVByb3h5KGZvcm1EYXRhLCBuYW1lLCBhcnJheSkge1xuICAgIC8vIG11dGF0aW5nIHRoZSBhcnJheSBzaG91bGQgbXV0YXRlIHRoZSB1bmRlcmx5aW5nIGZvcm0gZGF0YVxuICAgIHJldHVybiBuZXcgUHJveHkoYXJyYXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcpIHJldHVybiB0YXJnZXQubGVuZ3RoXG4gICAgICAgIGlmIChrZXkgPT09ICdwdXNoJykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2godmFsdWUpXG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XS5hcHBseSh0YXJnZXQsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIGZvcm1EYXRhLmRlbGV0ZShuYW1lKVxuICAgICAgICAgICAgdGFyZ2V0LmZvckVhY2goZnVuY3Rpb24odikgeyBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdikgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0W2tleV0gJiYgdGFyZ2V0W2tleV0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldWzBdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHRhcmdldCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtpbmRleF0gPSB2YWx1ZVxuICAgICAgICBmb3JtRGF0YS5kZWxldGUobmFtZSlcbiAgICAgICAgdGFyZ2V0LmZvckVhY2goZnVuY3Rpb24odikgeyBmb3JtRGF0YS5hcHBlbmQobmFtZSwgdikgfSlcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Rm9ybURhdGF9IGZvcm1EYXRhXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiBmb3JtRGF0YVByb3h5KGZvcm1EYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eShmb3JtRGF0YSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbih0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIC8vIEZvcndhcmQgc3ltYm9sIGNhbGxzIHRvIHRoZSBGb3JtRGF0YSBpdHNlbGYgZGlyZWN0bHlcbiAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBuYW1lKVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAndG9KU09OJykge1xuICAgICAgICAgIC8vIFN1cHBvcnQgSlNPTi5zdHJpbmdpZnkgY2FsbCBvbiBwcm94eVxuICAgICAgICAgIHJldHVybiAoKSA9PiBPYmplY3QuZnJvbUVudHJpZXMoZm9ybURhdGEpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgLy8gV3JhcCBpbiBmdW5jdGlvbiB3aXRoIGFwcGx5IHRvIGNvcnJlY3RseSBiaW5kIHRoZSBGb3JtRGF0YSBjb250ZXh0LCBhcyBhIGRpcmVjdCBjYWxsIHdvdWxkIHJlc3VsdCBpbiBhbiBpbGxlZ2FsIGludm9jYXRpb24gZXJyb3JcbiAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZm9ybURhdGFbbmFtZV0uYXBwbHkoZm9ybURhdGEsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheSA9IGZvcm1EYXRhLmdldEFsbChuYW1lKVxuICAgICAgICAvLyBUaG9zZSAyIHVuZGVmaW5lZCAmIHNpbmdsZSB2YWx1ZSByZXR1cm5zIGFyZSBmb3IgcmV0cm8tY29tcGF0aWJpbGl0eSBhcyB3ZSB3ZXJlbid0IHVzaW5nIEZvcm1EYXRhIGJlZm9yZVxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9IGVsc2UgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBhcnJheVswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmb3JtRGF0YUFycmF5UHJveHkodGFyZ2V0LCBuYW1lLCBhcnJheSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmRlbGV0ZShuYW1lKVxuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHsgdGFyZ2V0LmFwcGVuZChuYW1lLCB2KSB9KVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcbiAgICAgIGRlbGV0ZVByb3BlcnR5OiBmdW5jdGlvbih0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRhcmdldC5kZWxldGUobmFtZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIFN1cHBvcnQgT2JqZWN0LmFzc2lnbiBjYWxsIGZyb20gcHJveHlcbiAgICAgIG93bktleXM6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKE9iamVjdC5mcm9tRW50cmllcyh0YXJnZXQpKVxuICAgICAgfSxcbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24odGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZnJvbUVudHJpZXModGFyZ2V0KSwgcHJvcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SHR0cFZlcmJ9IHZlcmJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbHRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtIdG14QWpheEV0Y30gW2V0Y11cbiAgICogQHBhcmFtIHtib29sZWFufSBbY29uZmlybWVkXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgZnVuY3Rpb24gaXNzdWVBamF4UmVxdWVzdCh2ZXJiLCBwYXRoLCBlbHQsIGV2ZW50LCBldGMsIGNvbmZpcm1lZCkge1xuICAgIGxldCByZXNvbHZlID0gbnVsbFxuICAgIGxldCByZWplY3QgPSBudWxsXG4gICAgZXRjID0gZXRjICE9IG51bGwgPyBldGMgOiB7fVxuICAgIGlmIChldGMucmV0dXJuUHJvbWlzZSAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oX3Jlc29sdmUsIF9yZWplY3QpIHtcbiAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlXG4gICAgICAgIHJlamVjdCA9IF9yZWplY3RcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChlbHQgPT0gbnVsbCkge1xuICAgICAgZWx0ID0gZ2V0RG9jdW1lbnQoKS5ib2R5XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IGV0Yy5oYW5kbGVyIHx8IGhhbmRsZUFqYXhSZXNwb25zZVxuICAgIGNvbnN0IHNlbGVjdCA9IGV0Yy5zZWxlY3QgfHwgbnVsbFxuXG4gICAgaWYgKCFib2R5Q29udGFpbnMoZWx0KSkge1xuICAgIC8vIGRvIG5vdCBpc3N1ZSByZXF1ZXN0cyBmb3IgZWxlbWVudHMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAgIG1heWJlQ2FsbChyZXNvbHZlKVxuICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXRjLnRhcmdldE92ZXJyaWRlIHx8IGFzRWxlbWVudChnZXRUYXJnZXQoZWx0KSlcbiAgICBpZiAodGFyZ2V0ID09IG51bGwgfHwgdGFyZ2V0ID09IERVTU1ZX0VMVCkge1xuICAgICAgdHJpZ2dlckVycm9yRXZlbnQoZWx0LCAnaHRteDp0YXJnZXRFcnJvcicsIHsgdGFyZ2V0OiBnZXRBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC10YXJnZXQnKSB9KVxuICAgICAgbWF5YmVDYWxsKHJlamVjdClcbiAgICAgIHJldHVybiBwcm9taXNlXG4gICAgfVxuXG4gICAgbGV0IGVsdERhdGEgPSBnZXRJbnRlcm5hbERhdGEoZWx0KVxuICAgIGNvbnN0IHN1Ym1pdHRlciA9IGVsdERhdGEubGFzdEJ1dHRvbkNsaWNrZWRcblxuICAgIGlmIChzdWJtaXR0ZXIpIHtcbiAgICAgIGNvbnN0IGJ1dHRvblBhdGggPSBnZXRSYXdBdHRyaWJ1dGUoc3VibWl0dGVyLCAnZm9ybWFjdGlvbicpXG4gICAgICBpZiAoYnV0dG9uUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIHBhdGggPSBidXR0b25QYXRoXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1dHRvblZlcmIgPSBnZXRSYXdBdHRyaWJ1dGUoc3VibWl0dGVyLCAnZm9ybW1ldGhvZCcpXG4gICAgICBpZiAoYnV0dG9uVmVyYiAhPSBudWxsKSB7XG4gICAgICAvLyBpZ25vcmUgYnV0dG9ucyB3aXRoIGZvcm1tZXRob2Q9XCJkaWFsb2dcIlxuICAgICAgICBpZiAoYnV0dG9uVmVyYi50b0xvd2VyQ2FzZSgpICE9PSAnZGlhbG9nJykge1xuICAgICAgICAgIHZlcmIgPSAoLyoqIEB0eXBlIEh0dHBWZXJiICovKGJ1dHRvblZlcmIpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlybVF1ZXN0aW9uID0gZ2V0Q2xvc2VzdEF0dHJpYnV0ZVZhbHVlKGVsdCwgJ2h4LWNvbmZpcm0nKVxuICAgIC8vIGFsbG93IGV2ZW50LWJhc2VkIGNvbmZpcm1hdGlvbiB3LyBhIGNhbGxiYWNrXG4gICAgaWYgKGNvbmZpcm1lZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBpc3N1ZVJlcXVlc3QgPSBmdW5jdGlvbihza2lwQ29uZmlybWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBpc3N1ZUFqYXhSZXF1ZXN0KHZlcmIsIHBhdGgsIGVsdCwgZXZlbnQsIGV0YywgISFza2lwQ29uZmlybWF0aW9uKVxuICAgICAgfVxuICAgICAgY29uc3QgY29uZmlybURldGFpbHMgPSB7IHRhcmdldCwgZWx0LCBwYXRoLCB2ZXJiLCB0cmlnZ2VyaW5nRXZlbnQ6IGV2ZW50LCBldGMsIGlzc3VlUmVxdWVzdCwgcXVlc3Rpb246IGNvbmZpcm1RdWVzdGlvbiB9XG4gICAgICBpZiAodHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6Y29uZmlybScsIGNvbmZpcm1EZXRhaWxzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWF5YmVDYWxsKHJlc29sdmUpXG4gICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHN5bmNFbHQgPSBlbHRcbiAgICBsZXQgc3luY1N0cmF0ZWd5ID0gZ2V0Q2xvc2VzdEF0dHJpYnV0ZVZhbHVlKGVsdCwgJ2h4LXN5bmMnKVxuICAgIGxldCBxdWV1ZVN0cmF0ZWd5ID0gbnVsbFxuICAgIGxldCBhYm9ydGFibGUgPSBmYWxzZVxuICAgIGlmIChzeW5jU3RyYXRlZ3kpIHtcbiAgICAgIGNvbnN0IHN5bmNTdHJpbmdzID0gc3luY1N0cmF0ZWd5LnNwbGl0KCc6JylcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gc3luY1N0cmluZ3NbMF0udHJpbSgpXG4gICAgICBpZiAoc2VsZWN0b3IgPT09ICd0aGlzJykge1xuICAgICAgICBzeW5jRWx0ID0gZmluZFRoaXNFbGVtZW50KGVsdCwgJ2h4LXN5bmMnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3luY0VsdCA9IGFzRWxlbWVudChxdWVyeVNlbGVjdG9yRXh0KGVsdCwgc2VsZWN0b3IpKVxuICAgICAgfVxuICAgICAgLy8gZGVmYXVsdCB0byB0aGUgZHJvcCBzdHJhdGVneVxuICAgICAgc3luY1N0cmF0ZWd5ID0gKHN5bmNTdHJpbmdzWzFdIHx8ICdkcm9wJykudHJpbSgpXG4gICAgICBlbHREYXRhID0gZ2V0SW50ZXJuYWxEYXRhKHN5bmNFbHQpXG4gICAgICBpZiAoc3luY1N0cmF0ZWd5ID09PSAnZHJvcCcgJiYgZWx0RGF0YS54aHIgJiYgZWx0RGF0YS5hYm9ydGFibGUgIT09IHRydWUpIHtcbiAgICAgICAgbWF5YmVDYWxsKHJlc29sdmUpXG4gICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgICB9IGVsc2UgaWYgKHN5bmNTdHJhdGVneSA9PT0gJ2Fib3J0Jykge1xuICAgICAgICBpZiAoZWx0RGF0YS54aHIpIHtcbiAgICAgICAgICBtYXliZUNhbGwocmVzb2x2ZSlcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFib3J0YWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzeW5jU3RyYXRlZ3kgPT09ICdyZXBsYWNlJykge1xuICAgICAgICB0cmlnZ2VyRXZlbnQoc3luY0VsdCwgJ2h0bXg6YWJvcnQnKSAvLyBhYm9ydCB0aGUgY3VycmVudCByZXF1ZXN0IGFuZCBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChzeW5jU3RyYXRlZ3kuaW5kZXhPZigncXVldWUnKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBxdWV1ZVN0ckFycmF5ID0gc3luY1N0cmF0ZWd5LnNwbGl0KCcgJylcbiAgICAgICAgcXVldWVTdHJhdGVneSA9IChxdWV1ZVN0ckFycmF5WzFdIHx8ICdsYXN0JykudHJpbSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsdERhdGEueGhyKSB7XG4gICAgICBpZiAoZWx0RGF0YS5hYm9ydGFibGUpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50KHN5bmNFbHQsICdodG14OmFib3J0JykgLy8gYWJvcnQgdGhlIGN1cnJlbnQgcmVxdWVzdCBhbmQgY29udGludWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChxdWV1ZVN0cmF0ZWd5ID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGdldEludGVybmFsRGF0YShldmVudClcbiAgICAgICAgICAgIGlmIChldmVudERhdGEgJiYgZXZlbnREYXRhLnRyaWdnZXJTcGVjICYmIGV2ZW50RGF0YS50cmlnZ2VyU3BlYy5xdWV1ZSkge1xuICAgICAgICAgICAgICBxdWV1ZVN0cmF0ZWd5ID0gZXZlbnREYXRhLnRyaWdnZXJTcGVjLnF1ZXVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChxdWV1ZVN0cmF0ZWd5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlU3RyYXRlZ3kgPSAnbGFzdCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsdERhdGEucXVldWVkUmVxdWVzdHMgPT0gbnVsbCkge1xuICAgICAgICAgIGVsdERhdGEucXVldWVkUmVxdWVzdHMgPSBbXVxuICAgICAgICB9XG4gICAgICAgIGlmIChxdWV1ZVN0cmF0ZWd5ID09PSAnZmlyc3QnICYmIGVsdERhdGEucXVldWVkUmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZWx0RGF0YS5xdWV1ZWRSZXF1ZXN0cy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaXNzdWVBamF4UmVxdWVzdCh2ZXJiLCBwYXRoLCBlbHQsIGV2ZW50LCBldGMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmIChxdWV1ZVN0cmF0ZWd5ID09PSAnYWxsJykge1xuICAgICAgICAgIGVsdERhdGEucXVldWVkUmVxdWVzdHMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlzc3VlQWpheFJlcXVlc3QodmVyYiwgcGF0aCwgZWx0LCBldmVudCwgZXRjKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAocXVldWVTdHJhdGVneSA9PT0gJ2xhc3QnKSB7XG4gICAgICAgICAgZWx0RGF0YS5xdWV1ZWRSZXF1ZXN0cyA9IFtdIC8vIGR1bXAgZXhpc3RpbmcgcXVldWVcbiAgICAgICAgICBlbHREYXRhLnF1ZXVlZFJlcXVlc3RzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpc3N1ZUFqYXhSZXF1ZXN0KHZlcmIsIHBhdGgsIGVsdCwgZXZlbnQsIGV0YylcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIG1heWJlQ2FsbChyZXNvbHZlKVxuICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgZWx0RGF0YS54aHIgPSB4aHJcbiAgICBlbHREYXRhLmFib3J0YWJsZSA9IGFib3J0YWJsZVxuICAgIGNvbnN0IGVuZFJlcXVlc3RMb2NrID0gZnVuY3Rpb24oKSB7XG4gICAgICBlbHREYXRhLnhociA9IG51bGxcbiAgICAgIGVsdERhdGEuYWJvcnRhYmxlID0gZmFsc2VcbiAgICAgIGlmIChlbHREYXRhLnF1ZXVlZFJlcXVlc3RzICE9IG51bGwgJiZcbiAgICAgIGVsdERhdGEucXVldWVkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBxdWV1ZWRSZXF1ZXN0ID0gZWx0RGF0YS5xdWV1ZWRSZXF1ZXN0cy5zaGlmdCgpXG4gICAgICAgIHF1ZXVlZFJlcXVlc3QoKVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9tcHRRdWVzdGlvbiA9IGdldENsb3Nlc3RBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC1wcm9tcHQnKVxuICAgIGlmIChwcm9tcHRRdWVzdGlvbikge1xuICAgICAgdmFyIHByb21wdFJlc3BvbnNlID0gcHJvbXB0KHByb21wdFF1ZXN0aW9uKVxuICAgICAgLy8gcHJvbXB0IHJldHVybnMgbnVsbCBpZiBjYW5jZWxsZWQgYW5kIGVtcHR5IHN0cmluZyBpZiBhY2NlcHRlZCB3aXRoIG5vIGVudHJ5XG4gICAgICBpZiAocHJvbXB0UmVzcG9uc2UgPT09IG51bGwgfHxcbiAgICAgICF0cmlnZ2VyRXZlbnQoZWx0LCAnaHRteDpwcm9tcHQnLCB7IHByb21wdDogcHJvbXB0UmVzcG9uc2UsIHRhcmdldCB9KSkge1xuICAgICAgICBtYXliZUNhbGwocmVzb2x2ZSlcbiAgICAgICAgZW5kUmVxdWVzdExvY2soKVxuICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25maXJtUXVlc3Rpb24gJiYgIWNvbmZpcm1lZCkge1xuICAgICAgaWYgKCFjb25maXJtKGNvbmZpcm1RdWVzdGlvbikpIHtcbiAgICAgICAgbWF5YmVDYWxsKHJlc29sdmUpXG4gICAgICAgIGVuZFJlcXVlc3RMb2NrKClcbiAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaGVhZGVycyA9IGdldEhlYWRlcnMoZWx0LCB0YXJnZXQsIHByb21wdFJlc3BvbnNlKVxuXG4gICAgaWYgKHZlcmIgIT09ICdnZXQnICYmICF1c2VzRm9ybURhdGEoZWx0KSkge1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgIH1cblxuICAgIGlmIChldGMuaGVhZGVycykge1xuICAgICAgaGVhZGVycyA9IG1lcmdlT2JqZWN0cyhoZWFkZXJzLCBldGMuaGVhZGVycylcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IGdldElucHV0VmFsdWVzKGVsdCwgdmVyYilcbiAgICBsZXQgZXJyb3JzID0gcmVzdWx0cy5lcnJvcnNcbiAgICBjb25zdCByYXdGb3JtRGF0YSA9IHJlc3VsdHMuZm9ybURhdGFcbiAgICBpZiAoZXRjLnZhbHVlcykge1xuICAgICAgb3ZlcnJpZGVGb3JtRGF0YShyYXdGb3JtRGF0YSwgZm9ybURhdGFGcm9tT2JqZWN0KGV0Yy52YWx1ZXMpKVxuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9uVmFycyA9IGZvcm1EYXRhRnJvbU9iamVjdChnZXRFeHByZXNzaW9uVmFycyhlbHQpKVxuICAgIGNvbnN0IGFsbEZvcm1EYXRhID0gb3ZlcnJpZGVGb3JtRGF0YShyYXdGb3JtRGF0YSwgZXhwcmVzc2lvblZhcnMpXG4gICAgbGV0IGZpbHRlcmVkRm9ybURhdGEgPSBmaWx0ZXJWYWx1ZXMoYWxsRm9ybURhdGEsIGVsdClcblxuICAgIGlmIChodG14LmNvbmZpZy5nZXRDYWNoZUJ1c3RlclBhcmFtICYmIHZlcmIgPT09ICdnZXQnKSB7XG4gICAgICBmaWx0ZXJlZEZvcm1EYXRhLnNldCgnb3JnLmh0bXguY2FjaGUtYnVzdGVyJywgZ2V0UmF3QXR0cmlidXRlKHRhcmdldCwgJ2lkJykgfHwgJ3RydWUnKVxuICAgIH1cblxuICAgIC8vIGJlaGF2aW9yIG9mIGFuY2hvcnMgdy8gZW1wdHkgaHJlZiBpcyB0byB1c2UgdGhlIGN1cnJlbnQgVVJMXG4gICAgaWYgKHBhdGggPT0gbnVsbCB8fCBwYXRoID09PSAnJykge1xuICAgICAgcGF0aCA9IGdldERvY3VtZW50KCkubG9jYXRpb24uaHJlZlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY3JlZGVudGlhbHNdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aW1lb3V0XVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25vSGVhZGVyc11cbiAgICAgKi9cbiAgICBjb25zdCByZXF1ZXN0QXR0clZhbHVlcyA9IGdldFZhbHVlc0ZvckVsZW1lbnQoZWx0LCAnaHgtcmVxdWVzdCcpXG5cbiAgICBjb25zdCBlbHRJc0Jvb3N0ZWQgPSBnZXRJbnRlcm5hbERhdGEoZWx0KS5ib29zdGVkXG5cbiAgICBsZXQgdXNlVXJsUGFyYW1zID0gaHRteC5jb25maWcubWV0aG9kc1RoYXRVc2VVcmxQYXJhbXMuaW5kZXhPZih2ZXJiKSA+PSAwXG5cbiAgICAvKiogQHR5cGUgSHRteFJlcXVlc3RDb25maWcgKi9cbiAgICBjb25zdCByZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgYm9vc3RlZDogZWx0SXNCb29zdGVkLFxuICAgICAgdXNlVXJsUGFyYW1zLFxuICAgICAgZm9ybURhdGE6IGZpbHRlcmVkRm9ybURhdGEsXG4gICAgICBwYXJhbWV0ZXJzOiBmb3JtRGF0YVByb3h5KGZpbHRlcmVkRm9ybURhdGEpLFxuICAgICAgdW5maWx0ZXJlZEZvcm1EYXRhOiBhbGxGb3JtRGF0YSxcbiAgICAgIHVuZmlsdGVyZWRQYXJhbWV0ZXJzOiBmb3JtRGF0YVByb3h5KGFsbEZvcm1EYXRhKSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICB0YXJnZXQsXG4gICAgICB2ZXJiLFxuICAgICAgZXJyb3JzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBldGMuY3JlZGVudGlhbHMgfHwgcmVxdWVzdEF0dHJWYWx1ZXMuY3JlZGVudGlhbHMgfHwgaHRteC5jb25maWcud2l0aENyZWRlbnRpYWxzLFxuICAgICAgdGltZW91dDogZXRjLnRpbWVvdXQgfHwgcmVxdWVzdEF0dHJWYWx1ZXMudGltZW91dCB8fCBodG14LmNvbmZpZy50aW1lb3V0LFxuICAgICAgcGF0aCxcbiAgICAgIHRyaWdnZXJpbmdFdmVudDogZXZlbnRcbiAgICB9XG5cbiAgICBpZiAoIXRyaWdnZXJFdmVudChlbHQsICdodG14OmNvbmZpZ1JlcXVlc3QnLCByZXF1ZXN0Q29uZmlnKSkge1xuICAgICAgbWF5YmVDYWxsKHJlc29sdmUpXG4gICAgICBlbmRSZXF1ZXN0TG9jaygpXG4gICAgICByZXR1cm4gcHJvbWlzZVxuICAgIH1cblxuICAgIC8vIGNvcHkgb3V0IGluIGNhc2UgdGhlIG9iamVjdCB3YXMgb3ZlcndyaXR0ZW5cbiAgICBwYXRoID0gcmVxdWVzdENvbmZpZy5wYXRoXG4gICAgdmVyYiA9IHJlcXVlc3RDb25maWcudmVyYlxuICAgIGhlYWRlcnMgPSByZXF1ZXN0Q29uZmlnLmhlYWRlcnNcbiAgICBmaWx0ZXJlZEZvcm1EYXRhID0gZm9ybURhdGFGcm9tT2JqZWN0KHJlcXVlc3RDb25maWcucGFyYW1ldGVycylcbiAgICBlcnJvcnMgPSByZXF1ZXN0Q29uZmlnLmVycm9yc1xuICAgIHVzZVVybFBhcmFtcyA9IHJlcXVlc3RDb25maWcudXNlVXJsUGFyYW1zXG5cbiAgICBpZiAoZXJyb3JzICYmIGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0cmlnZ2VyRXZlbnQoZWx0LCAnaHRteDp2YWxpZGF0aW9uOmhhbHRlZCcsIHJlcXVlc3RDb25maWcpXG4gICAgICBtYXliZUNhbGwocmVzb2x2ZSlcbiAgICAgIGVuZFJlcXVlc3RMb2NrKClcbiAgICAgIHJldHVybiBwcm9taXNlXG4gICAgfVxuXG4gICAgY29uc3Qgc3BsaXRQYXRoID0gcGF0aC5zcGxpdCgnIycpXG4gICAgY29uc3QgcGF0aE5vQW5jaG9yID0gc3BsaXRQYXRoWzBdXG4gICAgY29uc3QgYW5jaG9yID0gc3BsaXRQYXRoWzFdXG5cbiAgICBsZXQgZmluYWxQYXRoID0gcGF0aFxuICAgIGlmICh1c2VVcmxQYXJhbXMpIHtcbiAgICAgIGZpbmFsUGF0aCA9IHBhdGhOb0FuY2hvclxuICAgICAgY29uc3QgaGFzVmFsdWVzID0gIWZpbHRlcmVkRm9ybURhdGEua2V5cygpLm5leHQoKS5kb25lXG4gICAgICBpZiAoaGFzVmFsdWVzKSB7XG4gICAgICAgIGlmIChmaW5hbFBhdGguaW5kZXhPZignPycpIDwgMCkge1xuICAgICAgICAgIGZpbmFsUGF0aCArPSAnPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaW5hbFBhdGggKz0gJyYnXG4gICAgICAgIH1cbiAgICAgICAgZmluYWxQYXRoICs9IHVybEVuY29kZShmaWx0ZXJlZEZvcm1EYXRhKVxuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgZmluYWxQYXRoICs9ICcjJyArIGFuY2hvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF2ZXJpZnlQYXRoKGVsdCwgZmluYWxQYXRoLCByZXF1ZXN0Q29uZmlnKSkge1xuICAgICAgdHJpZ2dlckVycm9yRXZlbnQoZWx0LCAnaHRteDppbnZhbGlkUGF0aCcsIHJlcXVlc3RDb25maWcpXG4gICAgICBtYXliZUNhbGwocmVqZWN0KVxuICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG5cbiAgICB4aHIub3Blbih2ZXJiLnRvVXBwZXJDYXNlKCksIGZpbmFsUGF0aCwgdHJ1ZSlcbiAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9odG1sJylcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gcmVxdWVzdENvbmZpZy53aXRoQ3JlZGVudGlhbHNcbiAgICB4aHIudGltZW91dCA9IHJlcXVlc3RDb25maWcudGltZW91dFxuXG4gICAgLy8gcmVxdWVzdCBoZWFkZXJzXG4gICAgaWYgKHJlcXVlc3RBdHRyVmFsdWVzLm5vSGVhZGVycykge1xuICAgIC8vIGlnbm9yZSBhbGwgaGVhZGVyc1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICBjb25zdCBoZWFkZXJWYWx1ZSA9IGhlYWRlcnNbaGVhZGVyXVxuICAgICAgICAgIHNhZmVseVNldEhlYWRlclZhbHVlKHhociwgaGVhZGVyLCBoZWFkZXJWYWx1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7SHRteFJlc3BvbnNlSW5mb30gKi9cbiAgICBjb25zdCByZXNwb25zZUluZm8gPSB7XG4gICAgICB4aHIsXG4gICAgICB0YXJnZXQsXG4gICAgICByZXF1ZXN0Q29uZmlnLFxuICAgICAgZXRjLFxuICAgICAgYm9vc3RlZDogZWx0SXNCb29zdGVkLFxuICAgICAgc2VsZWN0LFxuICAgICAgcGF0aEluZm86IHtcbiAgICAgICAgcmVxdWVzdFBhdGg6IHBhdGgsXG4gICAgICAgIGZpbmFsUmVxdWVzdFBhdGg6IGZpbmFsUGF0aCxcbiAgICAgICAgcmVzcG9uc2VQYXRoOiBudWxsLFxuICAgICAgICBhbmNob3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoaWVyYXJjaHkgPSBoaWVyYXJjaHlGb3JFbHQoZWx0KVxuICAgICAgICByZXNwb25zZUluZm8ucGF0aEluZm8ucmVzcG9uc2VQYXRoID0gZ2V0UGF0aEZyb21SZXNwb25zZSh4aHIpXG4gICAgICAgIHJlc3BvbnNlSGFuZGxlcihlbHQsIHJlc3BvbnNlSW5mbylcbiAgICAgICAgaWYgKHJlc3BvbnNlSW5mby5rZWVwSW5kaWNhdG9ycyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJlbW92ZVJlcXVlc3RJbmRpY2F0b3JzKGluZGljYXRvcnMsIGRpc2FibGVFbHRzKVxuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJFdmVudChlbHQsICdodG14OmFmdGVyUmVxdWVzdCcsIHJlc3BvbnNlSW5mbylcbiAgICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6YWZ0ZXJPbkxvYWQnLCByZXNwb25zZUluZm8pXG4gICAgICAgIC8vIGlmIHRoZSBib2R5IG5vIGxvbmdlciBjb250YWlucyB0aGUgZWxlbWVudCwgdHJpZ2dlciB0aGUgZXZlbnQgb24gdGhlIGNsb3Nlc3QgcGFyZW50XG4gICAgICAgIC8vIHJlbWFpbmluZyBpbiB0aGUgRE9NXG4gICAgICAgIGlmICghYm9keUNvbnRhaW5zKGVsdCkpIHtcbiAgICAgICAgICBsZXQgc2Vjb25kYXJ5VHJpZ2dlckVsdCA9IG51bGxcbiAgICAgICAgICB3aGlsZSAoaGllcmFyY2h5Lmxlbmd0aCA+IDAgJiYgc2Vjb25kYXJ5VHJpZ2dlckVsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFbHRJbkhpZXJhcmNoeSA9IGhpZXJhcmNoeS5zaGlmdCgpXG4gICAgICAgICAgICBpZiAoYm9keUNvbnRhaW5zKHBhcmVudEVsdEluSGllcmFyY2h5KSkge1xuICAgICAgICAgICAgICBzZWNvbmRhcnlUcmlnZ2VyRWx0ID0gcGFyZW50RWx0SW5IaWVyYXJjaHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlY29uZGFyeVRyaWdnZXJFbHQpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChzZWNvbmRhcnlUcmlnZ2VyRWx0LCAnaHRteDphZnRlclJlcXVlc3QnLCByZXNwb25zZUluZm8pXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoc2Vjb25kYXJ5VHJpZ2dlckVsdCwgJ2h0bXg6YWZ0ZXJPbkxvYWQnLCByZXNwb25zZUluZm8pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1heWJlQ2FsbChyZXNvbHZlKVxuICAgICAgICBlbmRSZXF1ZXN0TG9jaygpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyaWdnZXJFcnJvckV2ZW50KGVsdCwgJ2h0bXg6b25Mb2FkRXJyb3InLCBtZXJnZU9iamVjdHMoeyBlcnJvcjogZSB9LCByZXNwb25zZUluZm8pKVxuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfVxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZW1vdmVSZXF1ZXN0SW5kaWNhdG9ycyhpbmRpY2F0b3JzLCBkaXNhYmxlRWx0cylcbiAgICAgIHRyaWdnZXJFcnJvckV2ZW50KGVsdCwgJ2h0bXg6YWZ0ZXJSZXF1ZXN0JywgcmVzcG9uc2VJbmZvKVxuICAgICAgdHJpZ2dlckVycm9yRXZlbnQoZWx0LCAnaHRteDpzZW5kRXJyb3InLCByZXNwb25zZUluZm8pXG4gICAgICBtYXliZUNhbGwocmVqZWN0KVxuICAgICAgZW5kUmVxdWVzdExvY2soKVxuICAgIH1cbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVtb3ZlUmVxdWVzdEluZGljYXRvcnMoaW5kaWNhdG9ycywgZGlzYWJsZUVsdHMpXG4gICAgICB0cmlnZ2VyRXJyb3JFdmVudChlbHQsICdodG14OmFmdGVyUmVxdWVzdCcsIHJlc3BvbnNlSW5mbylcbiAgICAgIHRyaWdnZXJFcnJvckV2ZW50KGVsdCwgJ2h0bXg6c2VuZEFib3J0JywgcmVzcG9uc2VJbmZvKVxuICAgICAgbWF5YmVDYWxsKHJlamVjdClcbiAgICAgIGVuZFJlcXVlc3RMb2NrKClcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVtb3ZlUmVxdWVzdEluZGljYXRvcnMoaW5kaWNhdG9ycywgZGlzYWJsZUVsdHMpXG4gICAgICB0cmlnZ2VyRXJyb3JFdmVudChlbHQsICdodG14OmFmdGVyUmVxdWVzdCcsIHJlc3BvbnNlSW5mbylcbiAgICAgIHRyaWdnZXJFcnJvckV2ZW50KGVsdCwgJ2h0bXg6dGltZW91dCcsIHJlc3BvbnNlSW5mbylcbiAgICAgIG1heWJlQ2FsbChyZWplY3QpXG4gICAgICBlbmRSZXF1ZXN0TG9jaygpXG4gICAgfVxuICAgIGlmICghdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6YmVmb3JlUmVxdWVzdCcsIHJlc3BvbnNlSW5mbykpIHtcbiAgICAgIG1heWJlQ2FsbChyZXNvbHZlKVxuICAgICAgZW5kUmVxdWVzdExvY2soKVxuICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG4gICAgdmFyIGluZGljYXRvcnMgPSBhZGRSZXF1ZXN0SW5kaWNhdG9yQ2xhc3NlcyhlbHQpXG4gICAgdmFyIGRpc2FibGVFbHRzID0gZGlzYWJsZUVsZW1lbnRzKGVsdClcblxuICAgIGZvckVhY2goWydsb2Fkc3RhcnQnLCAnbG9hZGVuZCcsICdwcm9ncmVzcycsICdhYm9ydCddLCBmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGZvckVhY2goW3hociwgeGhyLnVwbG9hZF0sIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6eGhyOicgKyBldmVudE5hbWUsIHtcbiAgICAgICAgICAgIGxlbmd0aENvbXB1dGFibGU6IGV2ZW50Lmxlbmd0aENvbXB1dGFibGUsXG4gICAgICAgICAgICBsb2FkZWQ6IGV2ZW50LmxvYWRlZCxcbiAgICAgICAgICAgIHRvdGFsOiBldmVudC50b3RhbFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gICAgdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6YmVmb3JlU2VuZCcsIHJlc3BvbnNlSW5mbylcbiAgICBjb25zdCBwYXJhbXMgPSB1c2VVcmxQYXJhbXMgPyBudWxsIDogZW5jb2RlUGFyYW1zRm9yQm9keSh4aHIsIGVsdCwgZmlsdGVyZWRGb3JtRGF0YSlcbiAgICB4aHIuc2VuZChwYXJhbXMpXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBIdG14SGlzdG9yeVVwZGF0ZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdHlwZV1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3BhdGhdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge0h0bXhSZXNwb25zZUluZm99IHJlc3BvbnNlSW5mb1xuICAgKiBAcmV0dXJuIHtIdG14SGlzdG9yeVVwZGF0ZX1cbiAgICovXG4gIGZ1bmN0aW9uIGRldGVybWluZUhpc3RvcnlVcGRhdGVzKGVsdCwgcmVzcG9uc2VJbmZvKSB7XG4gICAgY29uc3QgeGhyID0gcmVzcG9uc2VJbmZvLnhoclxuXG4gICAgLy89ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEZpcnN0IGNvbnN1bHQgcmVzcG9uc2UgaGVhZGVyc1xuICAgIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBsZXQgcGF0aEZyb21IZWFkZXJzID0gbnVsbFxuICAgIGxldCB0eXBlRnJvbUhlYWRlcnMgPSBudWxsXG4gICAgaWYgKGhhc0hlYWRlcih4aHIsIC9IWC1QdXNoOi9pKSkge1xuICAgICAgcGF0aEZyb21IZWFkZXJzID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1QdXNoJylcbiAgICAgIHR5cGVGcm9tSGVhZGVycyA9ICdwdXNoJ1xuICAgIH0gZWxzZSBpZiAoaGFzSGVhZGVyKHhociwgL0hYLVB1c2gtVXJsOi9pKSkge1xuICAgICAgcGF0aEZyb21IZWFkZXJzID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1QdXNoLVVybCcpXG4gICAgICB0eXBlRnJvbUhlYWRlcnMgPSAncHVzaCdcbiAgICB9IGVsc2UgaWYgKGhhc0hlYWRlcih4aHIsIC9IWC1SZXBsYWNlLVVybDovaSkpIHtcbiAgICAgIHBhdGhGcm9tSGVhZGVycyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignSFgtUmVwbGFjZS1VcmwnKVxuICAgICAgdHlwZUZyb21IZWFkZXJzID0gJ3JlcGxhY2UnXG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgd2FzIGEgcmVzcG9uc2UgaGVhZGVyLCB0aGF0IGhhcyBwcmlvcml0eVxuICAgIGlmIChwYXRoRnJvbUhlYWRlcnMpIHtcbiAgICAgIGlmIChwYXRoRnJvbUhlYWRlcnMgPT09ICdmYWxzZScpIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGVGcm9tSGVhZGVycyxcbiAgICAgICAgICBwYXRoOiBwYXRoRnJvbUhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBOZXh0IHJlc29sdmUgdmlhIERPTSB2YWx1ZXNcbiAgICAvLz0gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgY29uc3QgcmVxdWVzdFBhdGggPSByZXNwb25zZUluZm8ucGF0aEluZm8uZmluYWxSZXF1ZXN0UGF0aFxuICAgIGNvbnN0IHJlc3BvbnNlUGF0aCA9IHJlc3BvbnNlSW5mby5wYXRoSW5mby5yZXNwb25zZVBhdGhcblxuICAgIGNvbnN0IHB1c2hVcmwgPSBnZXRDbG9zZXN0QXR0cmlidXRlVmFsdWUoZWx0LCAnaHgtcHVzaC11cmwnKVxuICAgIGNvbnN0IHJlcGxhY2VVcmwgPSBnZXRDbG9zZXN0QXR0cmlidXRlVmFsdWUoZWx0LCAnaHgtcmVwbGFjZS11cmwnKVxuICAgIGNvbnN0IGVsZW1lbnRJc0Jvb3N0ZWQgPSBnZXRJbnRlcm5hbERhdGEoZWx0KS5ib29zdGVkXG5cbiAgICBsZXQgc2F2ZVR5cGUgPSBudWxsXG4gICAgbGV0IHBhdGggPSBudWxsXG5cbiAgICBpZiAocHVzaFVybCkge1xuICAgICAgc2F2ZVR5cGUgPSAncHVzaCdcbiAgICAgIHBhdGggPSBwdXNoVXJsXG4gICAgfSBlbHNlIGlmIChyZXBsYWNlVXJsKSB7XG4gICAgICBzYXZlVHlwZSA9ICdyZXBsYWNlJ1xuICAgICAgcGF0aCA9IHJlcGxhY2VVcmxcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRJc0Jvb3N0ZWQpIHtcbiAgICAgIHNhdmVUeXBlID0gJ3B1c2gnXG4gICAgICBwYXRoID0gcmVzcG9uc2VQYXRoIHx8IHJlcXVlc3RQYXRoIC8vIGlmIHRoZXJlIGlzIG5vIHJlc3BvbnNlIHBhdGgsIGdvIHdpdGggdGhlIG9yaWdpbmFsIHJlcXVlc3QgcGF0aFxuICAgIH1cblxuICAgIGlmIChwYXRoKSB7XG4gICAgLy8gZmFsc2UgaW5kaWNhdGVzIG5vIHB1c2gsIHJldHVybiBlbXB0eSBvYmplY3RcbiAgICAgIGlmIChwYXRoID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgICAgfVxuXG4gICAgICAvLyB0cnVlIGluZGljYXRlcyB3ZSB3YW50IHRvIGZvbGxvdyB3aGVyZXZlciB0aGUgc2VydmVyIGVuZGVkIHVwIHNlbmRpbmcgdXNcbiAgICAgIGlmIChwYXRoID09PSAndHJ1ZScpIHtcbiAgICAgICAgcGF0aCA9IHJlc3BvbnNlUGF0aCB8fCByZXF1ZXN0UGF0aCAvLyBpZiB0aGVyZSBpcyBubyByZXNwb25zZSBwYXRoLCBnbyB3aXRoIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHBhdGhcbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSBhbnkgYW5jaG9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVxdWVzdFxuICAgICAgaWYgKHJlc3BvbnNlSW5mby5wYXRoSW5mby5hbmNob3IgJiYgcGF0aC5pbmRleE9mKCcjJykgPT09IC0xKSB7XG4gICAgICAgIHBhdGggPSBwYXRoICsgJyMnICsgcmVzcG9uc2VJbmZvLnBhdGhJbmZvLmFuY2hvclxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBzYXZlVHlwZSxcbiAgICAgICAgcGF0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge31cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIdG14UmVzcG9uc2VIYW5kbGluZ0NvbmZpZ30gcmVzcG9uc2VIYW5kbGluZ0NvbmZpZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBjb2RlTWF0Y2hlcyhyZXNwb25zZUhhbmRsaW5nQ29uZmlnLCBzdGF0dXMpIHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cChyZXNwb25zZUhhbmRsaW5nQ29uZmlnLmNvZGUpXG4gICAgcmV0dXJuIHJlZ0V4cC50ZXN0KHN0YXR1cy50b1N0cmluZygxMCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0geGhyXG4gICAqIEByZXR1cm4ge0h0bXhSZXNwb25zZUhhbmRsaW5nQ29uZmlnfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVJlc3BvbnNlSGFuZGxpbmcoeGhyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBodG14LmNvbmZpZy5yZXNwb25zZUhhbmRsaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvKiogQHR5cGUgSHRteFJlc3BvbnNlSGFuZGxpbmdDb25maWcgKi9cbiAgICAgIHZhciByZXNwb25zZUhhbmRsaW5nRWxlbWVudCA9IGh0bXguY29uZmlnLnJlc3BvbnNlSGFuZGxpbmdbaV1cbiAgICAgIGlmIChjb2RlTWF0Y2hlcyhyZXNwb25zZUhhbmRsaW5nRWxlbWVudCwgeGhyLnN0YXR1cykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlSGFuZGxpbmdFbGVtZW50XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vIG1hdGNoZXMsIHJldHVybiBubyBzd2FwXG4gICAgcmV0dXJuIHtcbiAgICAgIHN3YXA6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlVGl0bGUodGl0bGUpIHtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IHRpdGxlRWx0ID0gZmluZCgndGl0bGUnKVxuICAgICAgaWYgKHRpdGxlRWx0KSB7XG4gICAgICAgIHRpdGxlRWx0LmlubmVySFRNTCA9IHRpdGxlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQudGl0bGUgPSB0aXRsZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsdFxuICAgKiBAcGFyYW0ge0h0bXhSZXNwb25zZUluZm99IHJlc3BvbnNlSW5mb1xuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlQWpheFJlc3BvbnNlKGVsdCwgcmVzcG9uc2VJbmZvKSB7XG4gICAgY29uc3QgeGhyID0gcmVzcG9uc2VJbmZvLnhoclxuICAgIGxldCB0YXJnZXQgPSByZXNwb25zZUluZm8udGFyZ2V0XG4gICAgY29uc3QgZXRjID0gcmVzcG9uc2VJbmZvLmV0Y1xuICAgIGNvbnN0IHJlc3BvbnNlSW5mb1NlbGVjdCA9IHJlc3BvbnNlSW5mby5zZWxlY3RcblxuICAgIGlmICghdHJpZ2dlckV2ZW50KGVsdCwgJ2h0bXg6YmVmb3JlT25Mb2FkJywgcmVzcG9uc2VJbmZvKSkgcmV0dXJuXG5cbiAgICBpZiAoaGFzSGVhZGVyKHhociwgL0hYLVRyaWdnZXI6L2kpKSB7XG4gICAgICBoYW5kbGVUcmlnZ2VySGVhZGVyKHhociwgJ0hYLVRyaWdnZXInLCBlbHQpXG4gICAgfVxuXG4gICAgaWYgKGhhc0hlYWRlcih4aHIsIC9IWC1Mb2NhdGlvbjovaSkpIHtcbiAgICAgIHNhdmVDdXJyZW50UGFnZVRvSGlzdG9yeSgpXG4gICAgICBsZXQgcmVkaXJlY3RQYXRoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1Mb2NhdGlvbicpXG4gICAgICAvKiogQHR5cGUge0h0bXhBamF4SGVscGVyQ29udGV4dCZ7cGF0aDpzdHJpbmd9fSAqL1xuICAgICAgdmFyIHJlZGlyZWN0U3dhcFNwZWNcbiAgICAgIGlmIChyZWRpcmVjdFBhdGguaW5kZXhPZigneycpID09PSAwKSB7XG4gICAgICAgIHJlZGlyZWN0U3dhcFNwZWMgPSBwYXJzZUpTT04ocmVkaXJlY3RQYXRoKVxuICAgICAgICAvLyB3aGF0J3MgdGhlIGJlc3Qgd2F5IHRvIHRocm93IGFuIGVycm9yIGlmIHRoZSB1c2VyIGRpZG4ndCBpbmNsdWRlIHRoaXNcbiAgICAgICAgcmVkaXJlY3RQYXRoID0gcmVkaXJlY3RTd2FwU3BlYy5wYXRoXG4gICAgICAgIGRlbGV0ZSByZWRpcmVjdFN3YXBTcGVjLnBhdGhcbiAgICAgIH1cbiAgICAgIGFqYXhIZWxwZXIoJ2dldCcsIHJlZGlyZWN0UGF0aCwgcmVkaXJlY3RTd2FwU3BlYykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcHVzaFVybEludG9IaXN0b3J5KHJlZGlyZWN0UGF0aClcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzaG91bGRSZWZyZXNoID0gaGFzSGVhZGVyKHhociwgL0hYLVJlZnJlc2g6L2kpICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcignSFgtUmVmcmVzaCcpID09PSAndHJ1ZSdcblxuICAgIGlmIChoYXNIZWFkZXIoeGhyLCAvSFgtUmVkaXJlY3Q6L2kpKSB7XG4gICAgICByZXNwb25zZUluZm8ua2VlcEluZGljYXRvcnMgPSB0cnVlXG4gICAgICBsb2NhdGlvbi5ocmVmID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1SZWRpcmVjdCcpXG4gICAgICBzaG91bGRSZWZyZXNoICYmIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmVmcmVzaCkge1xuICAgICAgcmVzcG9uc2VJbmZvLmtlZXBJbmRpY2F0b3JzID0gdHJ1ZVxuICAgICAgbG9jYXRpb24ucmVsb2FkKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChoYXNIZWFkZXIoeGhyLCAvSFgtUmV0YXJnZXQ6L2kpKSB7XG4gICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1SZXRhcmdldCcpID09PSAndGhpcycpIHtcbiAgICAgICAgcmVzcG9uc2VJbmZvLnRhcmdldCA9IGVsdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VJbmZvLnRhcmdldCA9IGFzRWxlbWVudChxdWVyeVNlbGVjdG9yRXh0KGVsdCwgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1SZXRhcmdldCcpKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoaXN0b3J5VXBkYXRlID0gZGV0ZXJtaW5lSGlzdG9yeVVwZGF0ZXMoZWx0LCByZXNwb25zZUluZm8pXG5cbiAgICBjb25zdCByZXNwb25zZUhhbmRsaW5nID0gcmVzb2x2ZVJlc3BvbnNlSGFuZGxpbmcoeGhyKVxuICAgIGNvbnN0IHNob3VsZFN3YXAgPSByZXNwb25zZUhhbmRsaW5nLnN3YXBcbiAgICBsZXQgaXNFcnJvciA9ICEhcmVzcG9uc2VIYW5kbGluZy5lcnJvclxuICAgIGxldCBpZ25vcmVUaXRsZSA9IGh0bXguY29uZmlnLmlnbm9yZVRpdGxlIHx8IHJlc3BvbnNlSGFuZGxpbmcuaWdub3JlVGl0bGVcbiAgICBsZXQgc2VsZWN0T3ZlcnJpZGUgPSByZXNwb25zZUhhbmRsaW5nLnNlbGVjdFxuICAgIGlmIChyZXNwb25zZUhhbmRsaW5nLnRhcmdldCkge1xuICAgICAgcmVzcG9uc2VJbmZvLnRhcmdldCA9IGFzRWxlbWVudChxdWVyeVNlbGVjdG9yRXh0KGVsdCwgcmVzcG9uc2VIYW5kbGluZy50YXJnZXQpKVxuICAgIH1cbiAgICB2YXIgc3dhcE92ZXJyaWRlID0gZXRjLnN3YXBPdmVycmlkZVxuICAgIGlmIChzd2FwT3ZlcnJpZGUgPT0gbnVsbCAmJiByZXNwb25zZUhhbmRsaW5nLnN3YXBPdmVycmlkZSkge1xuICAgICAgc3dhcE92ZXJyaWRlID0gcmVzcG9uc2VIYW5kbGluZy5zd2FwT3ZlcnJpZGVcbiAgICB9XG5cbiAgICAvLyByZXNwb25zZSBoZWFkZXJzIG92ZXJyaWRlIHJlc3BvbnNlIGhhbmRsaW5nIGNvbmZpZ1xuICAgIGlmIChoYXNIZWFkZXIoeGhyLCAvSFgtUmV0YXJnZXQ6L2kpKSB7XG4gICAgICBpZiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1SZXRhcmdldCcpID09PSAndGhpcycpIHtcbiAgICAgICAgcmVzcG9uc2VJbmZvLnRhcmdldCA9IGVsdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VJbmZvLnRhcmdldCA9IGFzRWxlbWVudChxdWVyeVNlbGVjdG9yRXh0KGVsdCwgeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdIWC1SZXRhcmdldCcpKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0hlYWRlcih4aHIsIC9IWC1SZXN3YXA6L2kpKSB7XG4gICAgICBzd2FwT3ZlcnJpZGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0hYLVJlc3dhcCcpXG4gICAgfVxuXG4gICAgdmFyIHNlcnZlclJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG4gICAgLyoqIEB0eXBlIEh0bXhCZWZvcmVTd2FwRGV0YWlscyAqL1xuICAgIHZhciBiZWZvcmVTd2FwRGV0YWlscyA9IG1lcmdlT2JqZWN0cyh7XG4gICAgICBzaG91bGRTd2FwLFxuICAgICAgc2VydmVyUmVzcG9uc2UsXG4gICAgICBpc0Vycm9yLFxuICAgICAgaWdub3JlVGl0bGUsXG4gICAgICBzZWxlY3RPdmVycmlkZSxcbiAgICAgIHN3YXBPdmVycmlkZVxuICAgIH0sIHJlc3BvbnNlSW5mbylcblxuICAgIGlmIChyZXNwb25zZUhhbmRsaW5nLmV2ZW50ICYmICF0cmlnZ2VyRXZlbnQodGFyZ2V0LCByZXNwb25zZUhhbmRsaW5nLmV2ZW50LCBiZWZvcmVTd2FwRGV0YWlscykpIHJldHVyblxuXG4gICAgaWYgKCF0cmlnZ2VyRXZlbnQodGFyZ2V0LCAnaHRteDpiZWZvcmVTd2FwJywgYmVmb3JlU3dhcERldGFpbHMpKSByZXR1cm5cblxuICAgIHRhcmdldCA9IGJlZm9yZVN3YXBEZXRhaWxzLnRhcmdldCAvLyBhbGxvdyByZS10YXJnZXRpbmdcbiAgICBzZXJ2ZXJSZXNwb25zZSA9IGJlZm9yZVN3YXBEZXRhaWxzLnNlcnZlclJlc3BvbnNlIC8vIGFsbG93IHVwZGF0aW5nIGNvbnRlbnRcbiAgICBpc0Vycm9yID0gYmVmb3JlU3dhcERldGFpbHMuaXNFcnJvciAvLyBhbGxvdyB1cGRhdGluZyBlcnJvclxuICAgIGlnbm9yZVRpdGxlID0gYmVmb3JlU3dhcERldGFpbHMuaWdub3JlVGl0bGUgLy8gYWxsb3cgdXBkYXRpbmcgaWdub3JpbmcgdGl0bGVcbiAgICBzZWxlY3RPdmVycmlkZSA9IGJlZm9yZVN3YXBEZXRhaWxzLnNlbGVjdE92ZXJyaWRlIC8vIGFsbG93IHVwZGF0aW5nIHNlbGVjdCBvdmVycmlkZVxuICAgIHN3YXBPdmVycmlkZSA9IGJlZm9yZVN3YXBEZXRhaWxzLnN3YXBPdmVycmlkZSAvLyBhbGxvdyB1cGRhdGluZyBzd2FwIG92ZXJyaWRlXG5cbiAgICByZXNwb25zZUluZm8udGFyZ2V0ID0gdGFyZ2V0IC8vIE1ha2UgdXBkYXRlZCB0YXJnZXQgYXZhaWxhYmxlIHRvIHJlc3BvbnNlIGV2ZW50c1xuICAgIHJlc3BvbnNlSW5mby5mYWlsZWQgPSBpc0Vycm9yIC8vIE1ha2UgZmFpbGVkIHByb3BlcnR5IGF2YWlsYWJsZSB0byByZXNwb25zZSBldmVudHNcbiAgICByZXNwb25zZUluZm8uc3VjY2Vzc2Z1bCA9ICFpc0Vycm9yIC8vIE1ha2Ugc3VjY2Vzc2Z1bCBwcm9wZXJ0eSBhdmFpbGFibGUgdG8gcmVzcG9uc2UgZXZlbnRzXG5cbiAgICBpZiAoYmVmb3JlU3dhcERldGFpbHMuc2hvdWxkU3dhcCkge1xuICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDI4Nikge1xuICAgICAgICBjYW5jZWxQb2xsaW5nKGVsdClcbiAgICAgIH1cblxuICAgICAgd2l0aEV4dGVuc2lvbnMoZWx0LCBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICAgICAgc2VydmVyUmVzcG9uc2UgPSBleHRlbnNpb24udHJhbnNmb3JtUmVzcG9uc2Uoc2VydmVyUmVzcG9uc2UsIHhociwgZWx0KVxuICAgICAgfSlcblxuICAgICAgLy8gU2F2ZSBjdXJyZW50IHBhZ2UgaWYgdGhlcmUgd2lsbCBiZSBhIGhpc3RvcnkgdXBkYXRlXG4gICAgICBpZiAoaGlzdG9yeVVwZGF0ZS50eXBlKSB7XG4gICAgICAgIHNhdmVDdXJyZW50UGFnZVRvSGlzdG9yeSgpXG4gICAgICB9XG5cbiAgICAgIHZhciBzd2FwU3BlYyA9IGdldFN3YXBTcGVjaWZpY2F0aW9uKGVsdCwgc3dhcE92ZXJyaWRlKVxuXG4gICAgICBpZiAoIXN3YXBTcGVjLmhhc093blByb3BlcnR5KCdpZ25vcmVUaXRsZScpKSB7XG4gICAgICAgIHN3YXBTcGVjLmlnbm9yZVRpdGxlID0gaWdub3JlVGl0bGVcbiAgICAgIH1cblxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoaHRteC5jb25maWcuc3dhcHBpbmdDbGFzcylcblxuICAgICAgLy8gb3B0aW9uYWwgdHJhbnNpdGlvbiBBUEkgcHJvbWlzZSBjYWxsYmFja3NcbiAgICAgIGxldCBzZXR0bGVSZXNvbHZlID0gbnVsbFxuICAgICAgbGV0IHNldHRsZVJlamVjdCA9IG51bGxcblxuICAgICAgaWYgKHJlc3BvbnNlSW5mb1NlbGVjdCkge1xuICAgICAgICBzZWxlY3RPdmVycmlkZSA9IHJlc3BvbnNlSW5mb1NlbGVjdFxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzSGVhZGVyKHhociwgL0hYLVJlc2VsZWN0Oi9pKSkge1xuICAgICAgICBzZWxlY3RPdmVycmlkZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignSFgtUmVzZWxlY3QnKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxlY3RPT0IgPSBnZXRDbG9zZXN0QXR0cmlidXRlVmFsdWUoZWx0LCAnaHgtc2VsZWN0LW9vYicpXG4gICAgICBjb25zdCBzZWxlY3QgPSBnZXRDbG9zZXN0QXR0cmlidXRlVmFsdWUoZWx0LCAnaHgtc2VsZWN0JylcblxuICAgICAgbGV0IGRvU3dhcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGlmIHdlIG5lZWQgdG8gc2F2ZSBoaXN0b3J5LCBkbyBzbywgYmVmb3JlIHN3YXBwaW5nIHNvIHRoYXQgcmVsYXRpdmUgcmVzb3VyY2VzIGhhdmUgdGhlIGNvcnJlY3QgYmFzZSBVUkxcbiAgICAgICAgICBpZiAoaGlzdG9yeVVwZGF0ZS50eXBlKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoZ2V0RG9jdW1lbnQoKS5ib2R5LCAnaHRteDpiZWZvcmVIaXN0b3J5VXBkYXRlJywgbWVyZ2VPYmplY3RzKHsgaGlzdG9yeTogaGlzdG9yeVVwZGF0ZSB9LCByZXNwb25zZUluZm8pKVxuICAgICAgICAgICAgaWYgKGhpc3RvcnlVcGRhdGUudHlwZSA9PT0gJ3B1c2gnKSB7XG4gICAgICAgICAgICAgIHB1c2hVcmxJbnRvSGlzdG9yeShoaXN0b3J5VXBkYXRlLnBhdGgpXG4gICAgICAgICAgICAgIHRyaWdnZXJFdmVudChnZXREb2N1bWVudCgpLmJvZHksICdodG14OnB1c2hlZEludG9IaXN0b3J5JywgeyBwYXRoOiBoaXN0b3J5VXBkYXRlLnBhdGggfSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VVcmxJbkhpc3RvcnkoaGlzdG9yeVVwZGF0ZS5wYXRoKVxuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoZ2V0RG9jdW1lbnQoKS5ib2R5LCAnaHRteDpyZXBsYWNlZEluSGlzdG9yeScsIHsgcGF0aDogaGlzdG9yeVVwZGF0ZS5wYXRoIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dhcCh0YXJnZXQsIHNlcnZlclJlc3BvbnNlLCBzd2FwU3BlYywge1xuICAgICAgICAgICAgc2VsZWN0OiBzZWxlY3RPdmVycmlkZSB8fCBzZWxlY3QsXG4gICAgICAgICAgICBzZWxlY3RPT0IsXG4gICAgICAgICAgICBldmVudEluZm86IHJlc3BvbnNlSW5mbyxcbiAgICAgICAgICAgIGFuY2hvcjogcmVzcG9uc2VJbmZvLnBhdGhJbmZvLmFuY2hvcixcbiAgICAgICAgICAgIGNvbnRleHRFbGVtZW50OiBlbHQsXG4gICAgICAgICAgICBhZnRlclN3YXBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNIZWFkZXIoeGhyLCAvSFgtVHJpZ2dlci1BZnRlci1Td2FwOi9pKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaW5hbEVsdCA9IGVsdFxuICAgICAgICAgICAgICAgIGlmICghYm9keUNvbnRhaW5zKGVsdCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmFsRWx0ID0gZ2V0RG9jdW1lbnQoKS5ib2R5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZVRyaWdnZXJIZWFkZXIoeGhyLCAnSFgtVHJpZ2dlci1BZnRlci1Td2FwJywgZmluYWxFbHQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlclNldHRsZUNhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc0hlYWRlcih4aHIsIC9IWC1UcmlnZ2VyLUFmdGVyLVNldHRsZTovaSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmluYWxFbHQgPSBlbHRcbiAgICAgICAgICAgICAgICBpZiAoIWJvZHlDb250YWlucyhlbHQpKSB7XG4gICAgICAgICAgICAgICAgICBmaW5hbEVsdCA9IGdldERvY3VtZW50KCkuYm9keVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVUcmlnZ2VySGVhZGVyKHhociwgJ0hYLVRyaWdnZXItQWZ0ZXItU2V0dGxlJywgZmluYWxFbHQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWF5YmVDYWxsKHNldHRsZVJlc29sdmUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRyaWdnZXJFcnJvckV2ZW50KGVsdCwgJ2h0bXg6c3dhcEVycm9yJywgcmVzcG9uc2VJbmZvKVxuICAgICAgICAgIG1heWJlQ2FsbChzZXR0bGVSZWplY3QpXG4gICAgICAgICAgdGhyb3cgZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBzaG91bGRUcmFuc2l0aW9uID0gaHRteC5jb25maWcuZ2xvYmFsVmlld1RyYW5zaXRpb25zXG4gICAgICBpZiAoc3dhcFNwZWMuaGFzT3duUHJvcGVydHkoJ3RyYW5zaXRpb24nKSkge1xuICAgICAgICBzaG91bGRUcmFuc2l0aW9uID0gc3dhcFNwZWMudHJhbnNpdGlvblxuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoZWx0LCAnaHRteDpiZWZvcmVUcmFuc2l0aW9uJywgcmVzcG9uc2VJbmZvKSAmJlxuICAgICAgICAgICAgICB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBleHBlcmltZW50YWwgZmVhdHVyZSBhdG1cbiAgICAgICAgICAgICAgZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbikge1xuICAgICAgICBjb25zdCBzZXR0bGVQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oX3Jlc29sdmUsIF9yZWplY3QpIHtcbiAgICAgICAgICBzZXR0bGVSZXNvbHZlID0gX3Jlc29sdmVcbiAgICAgICAgICBzZXR0bGVSZWplY3QgPSBfcmVqZWN0XG4gICAgICAgIH0pXG4gICAgICAgIC8vIHdyYXAgdGhlIG9yaWdpbmFsIGRvU3dhcCgpIGluIGEgY2FsbCB0byBzdGFydFZpZXdUcmFuc2l0aW9uKClcbiAgICAgICAgY29uc3QgaW5uZXJEb1N3YXAgPSBkb1N3YXBcbiAgICAgICAgZG9Td2FwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBleHBlcmltZW50YWwgZmVhdHVyZSBhdG1cbiAgICAgICAgICBkb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaW5uZXJEb1N3YXAoKVxuICAgICAgICAgICAgcmV0dXJuIHNldHRsZVByb21pc2VcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2FwU3BlYy5zd2FwRGVsYXkgPiAwKSB7XG4gICAgICAgIGdldFdpbmRvdygpLnNldFRpbWVvdXQoZG9Td2FwLCBzd2FwU3BlYy5zd2FwRGVsYXkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb1N3YXAoKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNFcnJvcikge1xuICAgICAgdHJpZ2dlckVycm9yRXZlbnQoZWx0LCAnaHRteDpyZXNwb25zZUVycm9yJywgbWVyZ2VPYmplY3RzKHsgZXJyb3I6ICdSZXNwb25zZSBTdGF0dXMgRXJyb3IgQ29kZSAnICsgeGhyLnN0YXR1cyArICcgZnJvbSAnICsgcmVzcG9uc2VJbmZvLnBhdGhJbmZvLnJlcXVlc3RQYXRoIH0sIHJlc3BvbnNlSW5mbykpXG4gICAgfVxuICB9XG5cbiAgLy89ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRXh0ZW5zaW9ucyBBUElcbiAgLy89ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIEh0bXhFeHRlbnNpb24+fSAqL1xuICBjb25zdCBleHRlbnNpb25zID0ge31cblxuICAvKipcbiAgICogZXh0ZW5zaW9uQmFzZSBkZWZpbmVzIHRoZSBkZWZhdWx0IGZ1bmN0aW9ucyBmb3IgYWxsIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIHtIdG14RXh0ZW5zaW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZXh0ZW5zaW9uQmFzZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogZnVuY3Rpb24oYXBpKSB7IHJldHVybiBudWxsIH0sXG4gICAgICBnZXRTZWxlY3RvcnM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbCB9LFxuICAgICAgb25FdmVudDogZnVuY3Rpb24obmFtZSwgZXZ0KSB7IHJldHVybiB0cnVlIH0sXG4gICAgICB0cmFuc2Zvcm1SZXNwb25zZTogZnVuY3Rpb24odGV4dCwgeGhyLCBlbHQpIHsgcmV0dXJuIHRleHQgfSxcbiAgICAgIGlzSW5saW5lU3dhcDogZnVuY3Rpb24oc3dhcFN0eWxlKSB7IHJldHVybiBmYWxzZSB9LFxuICAgICAgaGFuZGxlU3dhcDogZnVuY3Rpb24oc3dhcFN0eWxlLCB0YXJnZXQsIGZyYWdtZW50LCBzZXR0bGVJbmZvKSB7IHJldHVybiBmYWxzZSB9LFxuICAgICAgZW5jb2RlUGFyYW1ldGVyczogZnVuY3Rpb24oeGhyLCBwYXJhbWV0ZXJzLCBlbHQpIHsgcmV0dXJuIG51bGwgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBkZWZpbmVFeHRlbnNpb24gaW5pdGlhbGl6ZXMgdGhlIGV4dGVuc2lvbiBhbmQgYWRkcyBpdCB0byB0aGUgaHRteCByZWdpc3RyeVxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRteC5vcmcvYXBpLyNkZWZpbmVFeHRlbnNpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGV4dGVuc2lvbiBuYW1lXG4gICAqIEBwYXJhbSB7SHRteEV4dGVuc2lvbn0gZXh0ZW5zaW9uIHRoZSBleHRlbnNpb24gZGVmaW5pdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lRXh0ZW5zaW9uKG5hbWUsIGV4dGVuc2lvbikge1xuICAgIGlmIChleHRlbnNpb24uaW5pdCkge1xuICAgICAgZXh0ZW5zaW9uLmluaXQoaW50ZXJuYWxBUEkpXG4gICAgfVxuICAgIGV4dGVuc2lvbnNbbmFtZV0gPSBtZXJnZU9iamVjdHMoZXh0ZW5zaW9uQmFzZSgpLCBleHRlbnNpb24pXG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlRXh0ZW5zaW9uIHJlbW92ZXMgYW4gZXh0ZW5zaW9uIGZyb20gdGhlIGh0bXggcmVnaXN0cnlcbiAgICpcbiAgICogQHNlZSBodHRwczovL2h0bXgub3JnL2FwaS8jcmVtb3ZlRXh0ZW5zaW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVFeHRlbnNpb24obmFtZSkge1xuICAgIGRlbGV0ZSBleHRlbnNpb25zW25hbWVdXG4gIH1cblxuICAvKipcbiAgICogZ2V0RXh0ZW5zaW9ucyBzZWFyY2hlcyB1cCB0aGUgRE9NIHRyZWUgdG8gcmV0dXJuIGFsbCBleHRlbnNpb25zIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gYSBnaXZlbiBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gICAqIEBwYXJhbSB7SHRteEV4dGVuc2lvbltdPX0gZXh0ZW5zaW9uc1RvUmV0dXJuXG4gICAqIEBwYXJhbSB7c3RyaW5nW109fSBleHRlbnNpb25zVG9JZ25vcmVcbiAgICogQHJldHVybnMge0h0bXhFeHRlbnNpb25bXX1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbnMoZWx0LCBleHRlbnNpb25zVG9SZXR1cm4sIGV4dGVuc2lvbnNUb0lnbm9yZSkge1xuICAgIGlmIChleHRlbnNpb25zVG9SZXR1cm4gPT0gdW5kZWZpbmVkKSB7XG4gICAgICBleHRlbnNpb25zVG9SZXR1cm4gPSBbXVxuICAgIH1cbiAgICBpZiAoZWx0ID09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbnNUb1JldHVyblxuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uc1RvSWdub3JlID09IHVuZGVmaW5lZCkge1xuICAgICAgZXh0ZW5zaW9uc1RvSWdub3JlID0gW11cbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uc0ZvckVsZW1lbnQgPSBnZXRBdHRyaWJ1dGVWYWx1ZShlbHQsICdoeC1leHQnKVxuICAgIGlmIChleHRlbnNpb25zRm9yRWxlbWVudCkge1xuICAgICAgZm9yRWFjaChleHRlbnNpb25zRm9yRWxlbWVudC5zcGxpdCgnLCcpLCBmdW5jdGlvbihleHRlbnNpb25OYW1lKSB7XG4gICAgICAgIGV4dGVuc2lvbk5hbWUgPSBleHRlbnNpb25OYW1lLnJlcGxhY2UoLyAvZywgJycpXG4gICAgICAgIGlmIChleHRlbnNpb25OYW1lLnNsaWNlKDAsIDcpID09ICdpZ25vcmU6Jykge1xuICAgICAgICAgIGV4dGVuc2lvbnNUb0lnbm9yZS5wdXNoKGV4dGVuc2lvbk5hbWUuc2xpY2UoNykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVuc2lvbnNUb0lnbm9yZS5pbmRleE9mKGV4dGVuc2lvbk5hbWUpIDwgMCkge1xuICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV1cbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIGV4dGVuc2lvbnNUb1JldHVybi5pbmRleE9mKGV4dGVuc2lvbikgPCAwKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zVG9SZXR1cm4ucHVzaChleHRlbnNpb24pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9ucyhhc0VsZW1lbnQocGFyZW50RWx0KGVsdCkpLCBleHRlbnNpb25zVG9SZXR1cm4sIGV4dGVuc2lvbnNUb0lnbm9yZSlcbiAgfVxuXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEluaXRpYWxpemF0aW9uXG4gIC8vPSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHZhciBpc1JlYWR5ID0gZmFsc2VcbiAgZ2V0RG9jdW1lbnQoKS5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgaXNSZWFkeSA9IHRydWVcbiAgfSlcblxuICAvKipcbiAgICogRXhlY3V0ZSBhIGZ1bmN0aW9uIG5vdyBpZiBET01Db250ZW50TG9hZGVkIGhhcyBmaXJlZCwgb3RoZXJ3aXNlIGxpc3RlbiBmb3IgaXQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBpc1JlYWR5IGJlY2F1c2UgdGhlcmUgaXMgbm8gcmVsaWFibGUgd2F5IHRvIGFzayB0aGUgYnJvd3NlciB3aGV0aGVyXG4gICAqIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gZmlyZWQ7IHRoZXJlJ3MgYSBnYXAgYmV0d2VlbiBET01Db250ZW50TG9hZGVkXG4gICAqIGZpcmluZyBhbmQgcmVhZHlzdGF0ZT1jb21wbGV0ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgLy8gQ2hlY2tpbmcgcmVhZHlTdGF0ZSBoZXJlIGlzIGEgZmFpbHNhZmUgaW4gY2FzZSB0aGUgaHRteCBzY3JpcHQgdGFnIGVudGVyZWQgdGhlIERPTSBieVxuICAgIC8vIHNvbWUgbWVhbnMgb3RoZXIgdGhhbiB0aGUgaW5pdGlhbCBwYWdlIGxvYWQuXG4gICAgaWYgKGlzUmVhZHkgfHwgZ2V0RG9jdW1lbnQoKS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBmbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdldERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZuKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEluZGljYXRvclN0eWxlcygpIHtcbiAgICBpZiAoaHRteC5jb25maWcuaW5jbHVkZUluZGljYXRvclN0eWxlcyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IG5vbmNlQXR0cmlidXRlID0gaHRteC5jb25maWcuaW5saW5lU3R5bGVOb25jZSA/IGAgbm9uY2U9XCIke2h0bXguY29uZmlnLmlubGluZVN0eWxlTm9uY2V9XCJgIDogJydcbiAgICAgIGdldERvY3VtZW50KCkuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsXG4gICAgICAgICc8c3R5bGUnICsgbm9uY2VBdHRyaWJ1dGUgKyAnPlxcXG4gICAgICAuJyArIGh0bXguY29uZmlnLmluZGljYXRvckNsYXNzICsgJ3tvcGFjaXR5OjB9XFxcbiAgICAgIC4nICsgaHRteC5jb25maWcucmVxdWVzdENsYXNzICsgJyAuJyArIGh0bXguY29uZmlnLmluZGljYXRvckNsYXNzICsgJ3tvcGFjaXR5OjE7IHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgZWFzZS1pbjt9XFxcbiAgICAgIC4nICsgaHRteC5jb25maWcucmVxdWVzdENsYXNzICsgJy4nICsgaHRteC5jb25maWcuaW5kaWNhdG9yQ2xhc3MgKyAne29wYWNpdHk6MTsgdHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcyBlYXNlLWluO31cXFxuICAgICAgPC9zdHlsZT4nKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1ldGFDb25maWcoKSB7XG4gICAgLyoqIEB0eXBlIEhUTUxNZXRhRWxlbWVudCAqL1xuICAgIGNvbnN0IGVsZW1lbnQgPSBnZXREb2N1bWVudCgpLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImh0bXgtY29uZmlnXCJdJylcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHBhcnNlSlNPTihlbGVtZW50LmNvbnRlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VNZXRhQ29uZmlnKCkge1xuICAgIGNvbnN0IG1ldGFDb25maWcgPSBnZXRNZXRhQ29uZmlnKClcbiAgICBpZiAobWV0YUNvbmZpZykge1xuICAgICAgaHRteC5jb25maWcgPSBtZXJnZU9iamVjdHMoaHRteC5jb25maWcsIG1ldGFDb25maWcpXG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgZG9jdW1lbnRcbiAgcmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgbWVyZ2VNZXRhQ29uZmlnKClcbiAgICBpbnNlcnRJbmRpY2F0b3JTdHlsZXMoKVxuICAgIGxldCBib2R5ID0gZ2V0RG9jdW1lbnQoKS5ib2R5XG4gICAgcHJvY2Vzc05vZGUoYm9keSlcbiAgICBjb25zdCByZXN0b3JlZEVsdHMgPSBnZXREb2N1bWVudCgpLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICBcIltoeC10cmlnZ2VyPSdyZXN0b3JlZCddLFtkYXRhLWh4LXRyaWdnZXI9J3Jlc3RvcmVkJ11cIlxuICAgIClcbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2h0bXg6YWJvcnQnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGV2dC50YXJnZXRcbiAgICAgIGNvbnN0IGludGVybmFsRGF0YSA9IGdldEludGVybmFsRGF0YSh0YXJnZXQpXG4gICAgICBpZiAoaW50ZXJuYWxEYXRhICYmIGludGVybmFsRGF0YS54aHIpIHtcbiAgICAgICAgaW50ZXJuYWxEYXRhLnhoci5hYm9ydCgpXG4gICAgICB9XG4gICAgfSlcbiAgICAvKiogQHR5cGUgeyhldjogUG9wU3RhdGVFdmVudCkgPT4gYW55fSAqL1xuICAgIGNvbnN0IG9yaWdpbmFsUG9wc3RhdGUgPSB3aW5kb3cub25wb3BzdGF0ZSA/IHdpbmRvdy5vbnBvcHN0YXRlLmJpbmQod2luZG93KSA6IG51bGxcbiAgICAvKiogQHR5cGUgeyhldjogUG9wU3RhdGVFdmVudCkgPT4gYW55fSAqL1xuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zdGF0ZSAmJiBldmVudC5zdGF0ZS5odG14KSB7XG4gICAgICAgIHJlc3RvcmVIaXN0b3J5KClcbiAgICAgICAgZm9yRWFjaChyZXN0b3JlZEVsdHMsIGZ1bmN0aW9uKGVsdCkge1xuICAgICAgICAgIHRyaWdnZXJFdmVudChlbHQsICdodG14OnJlc3RvcmVkJywge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IGdldERvY3VtZW50KCksXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsUG9wc3RhdGUpIHtcbiAgICAgICAgICBvcmlnaW5hbFBvcHN0YXRlKGV2ZW50KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldFdpbmRvdygpLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB0cmlnZ2VyRXZlbnQoYm9keSwgJ2h0bXg6bG9hZCcsIHt9KSAvLyBnaXZlIHJlYWR5IGhhbmRsZXJzIGEgY2hhbmNlIHRvIGxvYWQgdXAgYmVmb3JlIGZpcmluZyB0aGlzIGV2ZW50XG4gICAgICBib2R5ID0gbnVsbCAvLyBraWxsIHJlZmVyZW5jZSBmb3IgZ2NcbiAgICB9LCAwKVxuICB9KVxuXG4gIHJldHVybiBodG14XG59KSgpXG5cbi8qKiBAdHlwZWRlZiB7J2dldCd8J2hlYWQnfCdwb3N0J3wncHV0J3wnZGVsZXRlJ3wnY29ubmVjdCd8J29wdGlvbnMnfCd0cmFjZSd8J3BhdGNoJ30gSHR0cFZlcmIgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTd2FwT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdE9PQl1cbiAqIEBwcm9wZXJ0eSB7Kn0gW2V2ZW50SW5mb11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYW5jaG9yXVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBbY29udGV4dEVsZW1lbnRdXG4gKiBAcHJvcGVydHkge3N3YXBDYWxsYmFja30gW2FmdGVyU3dhcENhbGxiYWNrXVxuICogQHByb3BlcnR5IHtzd2FwQ2FsbGJhY2t9IFthZnRlclNldHRsZUNhbGxiYWNrXVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIHN3YXBDYWxsYmFja1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeydpbm5lckhUTUwnIHwgJ291dGVySFRNTCcgfCAnYmVmb3JlYmVnaW4nIHwgJ2FmdGVyYmVnaW4nIHwgJ2JlZm9yZWVuZCcgfCAnYWZ0ZXJlbmQnIHwgJ2RlbGV0ZScgfCAnbm9uZScgfCBzdHJpbmd9IEh0bXhTd2FwU3R5bGVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEh0bXhTd2FwU3BlY2lmaWNhdGlvblxuICogQHByb3BlcnR5IHtIdG14U3dhcFN0eWxlfSBzd2FwU3R5bGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzd2FwRGVsYXlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZXR0bGVEZWxheVxuICogQHByb3BlcnR5IHtib29sZWFufSBbdHJhbnNpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZVRpdGxlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtoZWFkXVxuICogQHByb3BlcnR5IHsndG9wJyB8ICdib3R0b20nfSBbc2Nyb2xsXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzY3JvbGxUYXJnZXRdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Nob3ddXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Nob3dUYXJnZXRdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb2N1c1Njcm9sbF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoKHRoaXM6Tm9kZSwgZXZ0OkV2ZW50KSA9PiBib29sZWFuKSAmIHtzb3VyY2U6IHN0cmluZ319IENvbmRpdGlvbmFsRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEh0bXhUcmlnZ2VyU3BlY2lmaWNhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRyaWdnZXJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcG9sbEludGVydmFsXVxuICogQHByb3BlcnR5IHtDb25kaXRpb25hbEZ1bmN0aW9ufSBbZXZlbnRGaWx0ZXJdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjaGFuZ2VkXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25jZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NvbnN1bWVdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbGF5XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtmcm9tXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YXJnZXRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Rocm90dGxlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtxdWV1ZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcm9vdF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGhyZXNob2xkXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tlbHQ6IEVsZW1lbnQsIG1lc3NhZ2U6IHN0cmluZywgdmFsaWRpdHk6IFZhbGlkaXR5U3RhdGV9fSBIdG14RWxlbWVudFZhbGlkYXRpb25FcnJvclxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1JlY29yZDxzdHJpbmcsIHN0cmluZz59IEh0bXhIZWFkZXJTcGVjaWZpY2F0aW9uXG4gKiBAcHJvcGVydHkgeyd0cnVlJ30gSFgtUmVxdWVzdFxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gSFgtVHJpZ2dlclxuICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gSFgtVHJpZ2dlci1OYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBIWC1UYXJnZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBIWC1DdXJyZW50LVVSTFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtIWC1Qcm9tcHRdXG4gKiBAcHJvcGVydHkgeyd0cnVlJ30gW0hYLUJvb3N0ZWRdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0NvbnRlbnQtVHlwZV1cbiAqIEBwcm9wZXJ0eSB7J3RydWUnfSBbSFgtSGlzdG9yeS1SZXN0b3JlLVJlcXVlc3RdXG4gKi9cblxuLyoqIEB0eXBlZGVmIEh0bXhBamF4SGVscGVyQ29udGV4dFxuICogQHByb3BlcnR5IHtFbGVtZW50fHN0cmluZ30gW3NvdXJjZV1cbiAqIEBwcm9wZXJ0eSB7RXZlbnR9IFtldmVudF1cbiAqIEBwcm9wZXJ0eSB7SHRteEFqYXhIYW5kbGVyfSBbaGFuZGxlcl1cbiAqIEBwcm9wZXJ0eSB7RWxlbWVudHxzdHJpbmd9IFt0YXJnZXRdXG4gKiBAcHJvcGVydHkge0h0bXhTd2FwU3R5bGV9IFtzd2FwXVxuICogQHByb3BlcnR5IHtPYmplY3R8Rm9ybURhdGF9IFt2YWx1ZXNdXG4gKiBAcHJvcGVydHkge1JlY29yZDxzdHJpbmcsc3RyaW5nPn0gW2hlYWRlcnNdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NlbGVjdF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEh0bXhSZXF1ZXN0Q29uZmlnXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJvb3N0ZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlVXJsUGFyYW1zXG4gKiBAcHJvcGVydHkge0Zvcm1EYXRhfSBmb3JtRGF0YVxuICogQHByb3BlcnR5IHtPYmplY3R9IHBhcmFtZXRlcnMgZm9ybURhdGEgcHJveHlcbiAqIEBwcm9wZXJ0eSB7Rm9ybURhdGF9IHVuZmlsdGVyZWRGb3JtRGF0YVxuICogQHByb3BlcnR5IHtPYmplY3R9IHVuZmlsdGVyZWRQYXJhbWV0ZXJzIHVuZmlsdGVyZWRGb3JtRGF0YSBwcm94eVxuICogQHByb3BlcnR5IHtIdG14SGVhZGVyU3BlY2lmaWNhdGlvbn0gaGVhZGVyc1xuICogQHByb3BlcnR5IHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwcm9wZXJ0eSB7SHR0cFZlcmJ9IHZlcmJcbiAqIEBwcm9wZXJ0eSB7SHRteEVsZW1lbnRWYWxpZGF0aW9uRXJyb3JbXX0gZXJyb3JzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHdpdGhDcmVkZW50aWFsc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbWVvdXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoXG4gKiBAcHJvcGVydHkge0V2ZW50fSB0cmlnZ2VyaW5nRXZlbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEh0bXhSZXNwb25zZUluZm9cbiAqIEBwcm9wZXJ0eSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICogQHByb3BlcnR5IHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwcm9wZXJ0eSB7SHRteFJlcXVlc3RDb25maWd9IHJlcXVlc3RDb25maWdcbiAqIEBwcm9wZXJ0eSB7SHRteEFqYXhFdGN9IGV0Y1xuICogQHByb3BlcnR5IHtib29sZWFufSBib29zdGVkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2VsZWN0XG4gKiBAcHJvcGVydHkge3tyZXF1ZXN0UGF0aDogc3RyaW5nLCBmaW5hbFJlcXVlc3RQYXRoOiBzdHJpbmcsIHJlc3BvbnNlUGF0aDogc3RyaW5nfG51bGwsIGFuY2hvcjogc3RyaW5nfX0gcGF0aEluZm9cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZhaWxlZF1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N1Y2Nlc3NmdWxdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwSW5kaWNhdG9yc11cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEh0bXhBamF4RXRjXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXR1cm5Qcm9taXNlXVxuICogQHByb3BlcnR5IHtIdG14QWpheEhhbmRsZXJ9IFtoYW5kbGVyXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RdXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IFt0YXJnZXRPdmVycmlkZV1cbiAqIEBwcm9wZXJ0eSB7SHRteFN3YXBTdHlsZX0gW3N3YXBPdmVycmlkZV1cbiAqIEBwcm9wZXJ0eSB7UmVjb3JkPHN0cmluZyxzdHJpbmc+fSBbaGVhZGVyc11cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fEZvcm1EYXRhfSBbdmFsdWVzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbY3JlZGVudGlhbHNdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbWVvdXRdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIdG14UmVzcG9uc2VIYW5kbGluZ0NvbmZpZ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2RlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBzd2FwXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtlcnJvcl1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZVRpdGxlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzZWxlY3RdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RhcmdldF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3dhcE92ZXJyaWRlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtldmVudF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtIdG14UmVzcG9uc2VJbmZvICYge3Nob3VsZFN3YXA6IGJvb2xlYW4sIHNlcnZlclJlc3BvbnNlOiBhbnksIGlzRXJyb3I6IGJvb2xlYW4sIGlnbm9yZVRpdGxlOiBib29sZWFuLCBzZWxlY3RPdmVycmlkZTpzdHJpbmcsIHN3YXBPdmVycmlkZTpzdHJpbmd9fSBIdG14QmVmb3JlU3dhcERldGFpbHNcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBIdG14QWpheEhhbmRsZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWx0XG4gKiBAcGFyYW0ge0h0bXhSZXNwb25zZUluZm99IHJlc3BvbnNlSW5mb1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeygoKSA9PiB2b2lkKX0gSHRteFNldHRsZVRhc2tcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEh0bXhTZXR0bGVJbmZvXG4gKiBAcHJvcGVydHkge0h0bXhTZXR0bGVUYXNrW119IHRhc2tzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gZWx0c1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV1cbiAqL1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2JpZ3NreXNvZnR3YXJlL2h0bXgtZXh0ZW5zaW9ucy9ibG9iL21haW4vUkVBRE1FLm1kXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIdG14RXh0ZW5zaW9uXG4gKiBAcHJvcGVydHkgeyhhcGk6IGFueSkgPT4gdm9pZH0gaW5pdFxuICogQHByb3BlcnR5IHsobmFtZTogc3RyaW5nLCBldmVudDogRXZlbnR8Q3VzdG9tRXZlbnQpID0+IGJvb2xlYW59IG9uRXZlbnRcbiAqIEBwcm9wZXJ0eSB7KHRleHQ6IHN0cmluZywgeGhyOiBYTUxIdHRwUmVxdWVzdCwgZWx0OiBFbGVtZW50KSA9PiBzdHJpbmd9IHRyYW5zZm9ybVJlc3BvbnNlXG4gKiBAcHJvcGVydHkgeyhzd2FwU3R5bGU6IEh0bXhTd2FwU3R5bGUpID0+IGJvb2xlYW59IGlzSW5saW5lU3dhcFxuICogQHByb3BlcnR5IHsoc3dhcFN0eWxlOiBIdG14U3dhcFN0eWxlLCB0YXJnZXQ6IE5vZGUsIGZyYWdtZW50OiBOb2RlLCBzZXR0bGVJbmZvOiBIdG14U2V0dGxlSW5mbykgPT4gYm9vbGVhbnxOb2RlW119IGhhbmRsZVN3YXBcbiAqIEBwcm9wZXJ0eSB7KHhocjogWE1MSHR0cFJlcXVlc3QsIHBhcmFtZXRlcnM6IEZvcm1EYXRhLCBlbHQ6IE5vZGUpID0+ICp8c3RyaW5nfG51bGx9IGVuY29kZVBhcmFtZXRlcnNcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gc3RyaW5nW118bnVsbH0gZ2V0U2VsZWN0b3JzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGh0bXhcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4037\n")}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](e,e.exports,__webpack_require__),e.exports}__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t);var __webpack_exports__=__webpack_require__(5293);(SiteJS=void 0===SiteJS?{}:SiteJS).site=__webpack_exports__})();